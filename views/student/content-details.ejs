<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title><%= contentItem.title %> - Content | ELKABLY</title>

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="/images/KImage.png">
  <link rel="shortcut icon" type="image/png" href="/images/KImage.png">
  <link rel="apple-touch-icon" href="/images/KImage.png">

  <!-- CSS -->
  <link rel="stylesheet" href="/css/studentCSS/student-main.css">
  <link rel="stylesheet" href="/css/studentCSS/courses.css">
  <link rel="stylesheet" href="/css/theme-toggle.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">

  <!-- Enhanced Styles -->
  <style>
    /* Content Actions Enhanced */
    .content-actions-completed {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }

    .completion-status {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 12px 16px;
      background: linear-gradient(135deg, #10b981, #059669);
      color: white;
      border-radius: 8px;
      font-weight: 500;
    }

    /* Navigation Styles */
    .content-navigation-section {
      margin-top: 2rem;
      padding: 1.5rem;
      background: var(--card-bg);
      border-radius: 12px;
      border: 1px solid var(--border-color);
    }

    .navigation-container {
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      gap: 1.5rem;
      align-items: center;
    }

    .nav-button {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 16px 20px;
      background: var(--primary-color);
      color: white;
      text-decoration: none;
      border-radius: 10px;
      transition: all 0.3s ease;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      position: relative;
      overflow: hidden;
    }

    /* Animation for when button becomes enabled */
    .nav-button.enabled {
      animation: enableButton 0.6s ease-out;
    }

    @keyframes enableButton {
      0% {
        background: #6b7280;
        transform: scale(1);
      }

      50% {
        background: var(--primary-color);
        transform: scale(1.05);
        box-shadow: 0 4px 20px rgba(220, 38, 38, 0.4);
      }

      100% {
        background: var(--primary-color);
        transform: scale(1);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }
    }

    .nav-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
      color: white;
      text-decoration: none;
    }

    .nav-button:not(.disabled):hover {
      background: var(--primary-hover, #b91c1c);
    }

    .nav-button:not(.disabled):active {
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }

    .nav-button.disabled {
      background: #6b7280;
      color: #9ca3af;
      cursor: not-allowed;
      opacity: 0.7;
      position: relative;
    }

    .nav-button.disabled:hover {
      transform: none;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      background: #6b7280;
      color: #9ca3af;
    }

    .nav-button.disabled::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      pointer-events: none;
    }

    .nav-previous {
      flex-direction: row;
    }

    .nav-next {
      flex-direction: row-reverse;
    }

    .nav-icon {
      font-size: 18px;
      width: 24px;
      text-align: center;
    }

    .nav-content {
      flex: 1;
    }

    .nav-label {
      font-size: 12px;
      font-weight: 500;
      opacity: 0.8;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .nav-title {
      font-size: 14px;
      font-weight: 600;
      margin-top: 2px;
      line-height: 1.3;
    }

    .nav-subtitle {
      font-size: 11px;
      opacity: 0.7;
      margin-top: 2px;
    }

    .nav-progress {
      text-align: center;
      min-width: 120px;
    }

    .progress-info {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      margin-bottom: 8px;
      font-size: 14px;
      font-weight: 600;
      color: var(--text-color);
    }

    .current-position {
      color: var(--primary-color);
    }

    .separator {
      opacity: 0.6;
    }

    .progress-bar {
      width: 100%;
      height: 4px;
      background: var(--border-color);
      border-radius: 2px;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--primary-color), var(--accent-color));
      border-radius: 2px;
      transition: width 0.3s ease;
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      .navigation-container {
        grid-template-columns: 1fr;
        gap: 1rem;
      }

      .nav-progress {
        order: -1;
      }

      .nav-button {
        padding: 12px 16px;
      }

      .nav-title {
        font-size: 13px;
      }
    }

    /* Dark theme adjustments */
    .dark-theme .content-navigation-section {
      background: var(--dark-card-bg);
      border-color: var(--dark-border-color);
    }

    .dark-theme .nav-button.disabled {
      background: var(--dark-muted-bg);
      color: var(--dark-muted-text);
    }

    /* Video Player Styles */
    .player-wrapper {
      position: relative;
      padding-top: 56.25%;
      /* 16:9 aspect ratio */
      margin-bottom: 20px;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    }

    .player-wrapper iframe {
      border: 0;
      position: absolute;
      top: 0;
      height: 100%;
      width: 100%;
    }

    /* Video Watermark Styles */
    .video-watermark-container {
      position: relative;
      width: 100%;
    }

    .video-watermark {
      position: absolute;
      z-index: 1000;
      pointer-events: none;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      padding: 10px 20px;
      -webkit-touch-callout: none;
      background: linear-gradient(135deg, rgba(0, 0, 0, 0.75), rgba(0, 0, 0, 0.85));
      color: #ffffff;
      font-size: 14px;
      font-weight: 600;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      border-radius: 8px;
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4), 
                  0 0 0 1px rgba(255, 255, 255, 0.1) inset;
      transition: opacity 0.3s ease, transform 0.3s ease;
      opacity: 0.85;
      display: flex;
      align-items: center;
      gap: 8px;
      letter-spacing: 0.3px;
    }

    .video-watermark:hover {
      opacity: 1;
    }

    .video-watermark span {
      text-shadow: 0 2px 8px rgba(0, 0, 0, 0.8),
                   0 1px 3px rgba(0, 0, 0, 0.9);
      white-space: nowrap;
    }

    .video-watermark::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, 
        rgba(255, 255, 255, 0.1) 0%, 
        rgba(255, 255, 255, 0.05) 50%, 
        rgba(0, 0, 0, 0.1) 100%);
      border-radius: 8px;
      pointer-events: none;
    }

    /* Responsive watermark positioning */
    @media (max-width: 768px) {
      .video-watermark {
        font-size: 8px !important;
        padding: 4px 8px !important;
        gap: 4px !important;
        border-radius: 4px !important;
      }

      /* Mobile fullscreen optimizations */
      .video-player-wrapper-with-watermark {
        width: 100% !important;
        max-width: 100% !important;
      }

      /* Ensure video container is responsive on mobile */
      .bunny-video-container-inner {
        width: 100% !important;
        max-width: 100% !important;
      }

      /* Mobile video player container - allow fullscreen */
      .video-player-container {
        position: relative !important;
        padding-top: 56.25% !important;
        width: 100% !important;
        max-width: 100% !important;
      }

      .video-player-container iframe,
      .video-player-container > div {
        position: absolute !important;
        top: 0 !important;
        left: 0 !important;
        width: 100% !important;
        height: 100% !important;
      }

      /* Mobile fullscreen watermark */
      :fullscreen .video-watermark,
      :-webkit-full-screen .video-watermark,
      :-moz-full-screen .video-watermark {
        font-size: 10px !important;
        padding: 6px 12px !important;
      }

      /* Fullscreen video container */
      .video-player-container:fullscreen,
      .video-player-container:-webkit-full-screen,
      .video-player-container:-moz-full-screen {
        padding-top: 0 !important;
        width: 100vw !important;
        height: 100vh !important;
      }

      .video-player-container:fullscreen iframe,
      .video-player-container:-webkit-full-screen iframe,
      .video-player-container:-moz-full-screen iframe,
      .video-player-container:fullscreen > div,
      .video-player-container:-webkit-full-screen > div,
      .video-player-container:-moz-full-screen > div {
        width: 100vw !important;
        height: 100vh !important;
      }
    }

    /* Landscape mode on mobile */
    @media (max-width: 768px) and (orientation: landscape) {
      .video-player-wrapper-with-watermark {
        height: 100vh !important;
      }

      /* Watermark in landscape fullscreen */
      :fullscreen .video-watermark,
      :-webkit-full-screen .video-watermark {
        font-size: 11px !important;
        padding: 6px 14px !important;
      }

      /* Landscape fullscreen optimization */
      .video-player-container {
        height: 100vh !important;
        padding-top: 0 !important;
      }
    }

    /* Meeting Compact Info Section */
    .meeting-compact-info {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 20px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      margin-bottom: 20px;
      gap: 15px;
    }

    .compact-info-left {
      display: flex;
      align-items: center;
      gap: 12px;
      font-weight: 600;
      color: var(--text-primary);
      flex: 1;
    }

    .compact-info-left i {
      color: var(--primary-color);
      font-size: 1.1rem;
    }

    .compact-info-right {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 14px;
      border-radius: 50px;
      font-size: 0.85rem;
      font-weight: 600;
    }

    .compact-info-right.completed {
      background: rgba(16, 185, 129, 0.1);
      color: #10b981;
    }

    .dark-theme .meeting-compact-info {
      background: var(--dark-card-bg);
      border-color: var(--dark-border-color);
    }

    @media (max-width: 768px) {
      .meeting-compact-info {
        flex-direction: column;
        align-items: flex-start;
        padding: 10px 15px;
        gap: 8px;
      }

      .compact-info-left {
        font-size: 0.85rem;
      }
      
      .compact-info-right {
        padding: 4px 10px;
        font-size: 0.75rem;
      }
    }

    /* ==================== MOBILE VIDEO REDESIGN ==================== */
    /* Full-width video, no padding, no borders on mobile */
    @media (max-width: 768px) {
      /* Remove card padding and borders on mobile for recording sections */
      .meeting-ended-section,
      .recording-available,
      .recording-player-wrapper,
      .content-main-section {
        padding: 0 !important;
        margin: 0 !important;
        border: none !important;
        border-radius: 0 !important;
        box-shadow: none !important;
      }

      /* Make video container full-width and bigger */
      .video-player-wrapper-with-watermark,
      .bunny-video-wrapper,
      .video-player-container,
      .recording-video-container {
        min-height: 220px !important;
        width: 100% !important;
        border-radius: 8px !important;
        margin: 0 !important;
        overflow: hidden !important;
      }
      
      /* Ensure aspect ratio is maintained */
      .recording-video-container {
        padding-top: 56.25% !important;
        position: relative !important;
      }
      
      /* Recording header - more compact */
      .recording-header {
        padding: 10px 0 !important;
        margin-bottom: 8px !important;
      }
      
      .recording-badge {
        padding: 6px 12px !important;
        font-size: 12px !important;
      }
      
      .recording-completed-badge {
        padding: 4px 10px !important;
        font-size: 11px !important;
      }

      /* HIDE the watch progress overlay inside video on mobile */
      #videoWatchProgress,
      #youtubeWatchProgress,
      #recordingWatchProgressOverlay {
        display: none !important;
      }

      /* Recording info section - more compact */
      .recording-info {
        padding: 8px 0 !important;
        margin: 8px 0 !important;
      }
      
      .recording-meta {
        font-size: 12px !important;
      }
      
      .recording-meta-item {
        padding: 4px 0 !important;
      }

      /* Recording watch requirement / attended / completed badges - compact */
      .recording-watch-requirement,
      .recording-attended-badge,
      .recording-completed-badge {
        padding: 8px 12px !important;
        font-size: 12px !important;
        margin: 8px 0 !important;
        border-radius: 8px !important;
      }

      .recording-watch-requirement p,
      .recording-attended-badge p,
      .recording-completed-badge p {
        font-size: 11px !important;
        margin: 0 !important;
        line-height: 1.3 !important;
      }
      
      .recording-attended-badge i,
      .recording-completed-badge i,
      .recording-watch-requirement i {
        font-size: 1rem !important;
      }

      /* Make watermark smaller on mobile */
      .video-watermark {
        font-size: 9px !important;
        padding: 4px 8px !important;
      }
      
      /* Ended time section */
      .ended-time {
        font-size: 14px !important;
        padding: 8px 12px !important;
      }
      
      /* Hide session recording header text to save space */
      .meeting-ended-section h5 {
        font-size: 14px !important;
        margin-bottom: 4px !important;
      }
      
      .meeting-ended-section .text-muted {
        font-size: 11px !important;
        margin-bottom: 4px !important;
      }
      
      .meeting-ended-section .ended-icon {
        font-size: 2rem !important;
        margin-bottom: 8px !important;
      }
    }

    /* Extra small screens - even more compact */
    @media (max-width: 480px) {
      .video-player-wrapper-with-watermark,
      .bunny-video-wrapper,
      .video-player-container,
      .recording-video-container {
        min-height: 200px !important;
        border-radius: 6px !important;
      }
      
      .video-watermark {
        font-size: 8px !important;
        padding: 3px 6px !important;
      }
      
      .ended-time {
        font-size: 12px !important;
        padding: 6px 10px !important;
      }
      
      .recording-watch-requirement,
      .recording-attended-badge,
      .recording-completed-badge {
        padding: 6px 10px !important;
        font-size: 11px !important;
      }
    }

    /* Quiz/Homework Details Styles */
    .quiz-details-grid,
    .homework-details-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin: 1.5rem 0;
      padding: 1rem;
      background: var(--bg-color);
      border-radius: 8px;
      border: 1px solid var(--border-color);
    }

    .detail-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem;
      background: var(--card-bg);
      border-radius: 6px;
      border: 1px solid var(--border-color);
    }

    .detail-item i {
      color: var(--primary-color);
      font-size: 1.1rem;
    }

    .detail-item span {
      font-weight: 500;
      color: var(--text-color);
    }

    .quiz-progress-info,
    .homework-progress-info {
      margin: 1.5rem 0;
      padding: 1rem;
      background: linear-gradient(135deg, #f8fafc, #e2e8f0);
      border: 1px solid #cbd5e1;
      border-radius: 8px;
    }

    .quiz-progress-info h4,
    .homework-progress-info h4 {
      margin-bottom: 1rem;
      color: #1e293b;
      font-weight: 600;
    }

    .progress-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 1rem;
    }

    .stat-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem 0;
      border-bottom: 1px solid #e2e8f0;
    }

    .stat-item:last-child {
      border-bottom: none;
    }

    .stat-label {
      font-weight: 500;
      color: #374151;
    }

    .stat-value {
      font-weight: 600;
      color: #1f2937;
    }

    .stat-value.text-success {
      color: #10b981;
    }

    .stat-value.text-warning {
      color: #f59e0b;
    }

    /* Dark theme adjustments */
    .dark-theme .quiz-details-grid,
    .dark-theme .homework-details-grid {
      background: var(--dark-bg-color);
      border-color: var(--dark-border-color);
    }

    .dark-theme .detail-item {
      background: var(--dark-card-bg);
      border-color: var(--dark-border-color);
    }

    .dark-theme .detail-item span {
      color: var(--dark-text-color);
    }

    .dark-theme .quiz-progress-info,
    .dark-theme .homework-progress-info {
      background: linear-gradient(135deg, #1e293b, #334155);
      border-color: #475569;
    }

    .dark-theme .quiz-progress-info h4,
    .dark-theme .homework-progress-info h4 {
      color: #f1f5f9;
    }

    .dark-theme .stat-label {
      color: #d1d5db;
    }

    .dark-theme .stat-value {
      color: #f9fafb;
    }

    /* Quiz/Homework Completion Styles */
    .quiz-completed-section,
    .homework-completed-section {
      text-align: center;
      padding: 2rem;
      background: linear-gradient(135deg, #f0f9ff, #e0f2fe);
      border: 1px solid #0ea5e9;
      border-radius: 12px;
      margin: 1.5rem 0;
    }

    .completion-badge {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      background: linear-gradient(135deg, #10b981, #059669);
      color: white;
      padding: 1rem 2rem;
      border-radius: 50px;
      font-weight: 600;
      font-size: 1.1rem;
      margin-bottom: 1.5rem;
      box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
    }

    .completion-badge i {
      font-size: 1.3rem;
    }

    .completion-details {
      margin-bottom: 1.5rem;
    }

    .completion-details p {
      margin: 0.5rem 0;
      color: #374151;
      font-size: 1rem;
    }

    .completion-details strong {
      color: #1f2937;
    }

    .completion-actions {
      display: flex;
      justify-content: center;
      gap: 1rem;
    }

    /* Dark theme adjustments for completion sections */
    .dark-theme .quiz-completed-section,
    .dark-theme .homework-completed-section {
      background: linear-gradient(135deg, #1e293b, #334155);
      border-color: #475569;
    }

    .dark-theme .completion-details p {
      color: #d1d5db;
    }

    .dark-theme .completion-details strong {
      color: #f9fafb;
    }

    /* Content Header Styles */
    .content-header-section {
      background: var(--gradient-primary);
      color: var(--text-white);
      padding: var(--spacing-2xl);
      margin-bottom: var(--spacing-2xl);
      border-radius: var(--radius-xl);
      position: relative;
      overflow: hidden;
    }

    .content-header-section::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grain" width="100" height="100" patternUnits="userSpaceOnUse"><circle cx="25" cy="25" r="1" fill="rgba(255,255,255,0.1)"/><circle cx="75" cy="75" r="1" fill="rgba(255,255,255,0.1)"/><circle cx="50" cy="10" r="0.5" fill="rgba(255,255,255,0.05)"/><circle cx="10" cy="60" r="0.5" fill="rgba(255,255,255,0.05)"/><circle cx="90" cy="40" r="0.5" fill="rgba(255,255,255,0.05)"/></pattern></defs><rect width="100" height="100" fill="url(%23grain)"/></svg>');
      opacity: 0.3;
    }

    .content-header-content {
      position: relative;
      z-index: 1;
      display: flex;
      align-items: center;
      gap: var(--spacing-xl);
    }

    .content-header-info {
      flex: 1;
    }

    .content-type-badge {
      display: inline-flex;
      align-items: center;
      gap: var(--spacing-sm);
      padding: var(--spacing-sm) var(--spacing-md);
      background: rgba(255, 255, 255, 0.2);
      color: var(--text-white);
      border-radius: var(--radius-lg);
      font-size: 0.9rem;
      font-weight: 600;
      margin-bottom: var(--spacing-md);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .content-title-main {
      font-size: 2.5rem;
      font-weight: 800;
      margin-bottom: var(--spacing-md);
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      color: var(--text-white);
    }

    .content-description-main {
      font-size: 1.1rem;
      opacity: 0.9;
      margin-bottom: var(--spacing-lg);
      line-height: 1.6;
      color: var(--text-white);
    }

    .content-meta-info {
      display: flex;
      gap: var(--spacing-xl);
      flex-wrap: wrap;
    }

    .content-progress-section {
      display: flex;
      align-items: center;
      gap: var(--spacing-lg);
    }

    /* Content Body Styles */
    .content-body-section {
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-lg);
      padding: var(--spacing-xl);
      margin-bottom: var(--spacing-xl);
      box-shadow: var(--shadow-sm);
    }

    /* Content Actions */
    .content-actions {
      display: flex;
      justify-content: center;
      gap: var(--spacing-md);
      margin-top: var(--spacing-xl);
    }

    /* Auto Completion Section */
    .content-auto-completion-section {
      text-align: center;
      padding: var(--spacing-xl);
      background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(5, 150, 105, 0.05));
      border: 1px solid rgba(16, 185, 129, 0.2);
      border-radius: var(--radius-lg);
      margin: var(--spacing-xl) 0;
    }

    .auto-completion-status {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: var(--spacing-md);
      color: var(--success-color);
      font-weight: 600;
      font-size: 1.1rem;
    }

    .auto-completion-status i {
      font-size: 1.5rem;
    }

    /* Quiz/Homework Compact Styles */
    .quiz-details-compact,
    .homework-details-compact {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: var(--spacing-md);
      margin: var(--spacing-lg) 0;
    }

    .quiz-detail-item,
    .homework-detail-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: var(--spacing-xs);
      padding: var(--spacing-md);
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-md);
      text-align: center;
    }

    .quiz-detail-item i,
    .homework-detail-item i {
      color: var(--primary-color);
      font-size: 1.2rem;
    }

    .detail-label {
      font-size: 0.8rem;
      color: var(--text-muted);
      font-weight: 500;
    }

    .detail-value {
      font-size: 1rem;
      font-weight: 700;
      color: var(--text-primary);
    }

    .quiz-progress-compact,
    .homework-progress-compact {
      display: flex;
      justify-content: space-between;
      margin: var(--spacing-md) 0;
      padding: var(--spacing-md);
      background: var(--bg-secondary);
      border-radius: var(--radius-md);
    }

    .progress-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: var(--spacing-xs);
    }

    .progress-label {
      font-size: 0.8rem;
      color: var(--text-muted);
      font-weight: 500;
    }

    .progress-value {
      font-size: 1rem;
      font-weight: 700;
      color: var(--text-primary);
    }

    .quiz-completed-compact,
    .homework-completed-compact {
      text-align: center;
      padding: var(--spacing-lg);
      background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(5, 150, 105, 0.05));
      border: 1px solid rgba(16, 185, 129, 0.2);
      border-radius: var(--radius-lg);
      margin: var(--spacing-lg) 0;
    }

    .completion-badge-compact {
      display: inline-flex;
      align-items: center;
      gap: var(--spacing-sm);
      background: var(--gradient-success);
      color: var(--text-white);
      padding: var(--spacing-sm) var(--spacing-lg);
      border-radius: var(--radius-full);
      font-weight: 600;
      margin-bottom: var(--spacing-md);
    }

    .completion-details-compact {
      margin-bottom: var(--spacing-lg);
    }

    .completion-detail-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: var(--spacing-sm) 0;
      padding: var(--spacing-sm) 0;
      border-bottom: 1px solid var(--border-color);
    }

    .completion-detail-row:last-child {
      border-bottom: none;
    }

    .completion-actions-compact {
      display: flex;
      justify-content: center;
    }

    /* Content Type Containers */
    .video-content,
    .pdf-content,
    .quiz-content,
    .homework-content,
    .reading-content,
    .link-content,
    .assignment-content,
    .generic-content {
      padding: var(--spacing-lg);
    }

    .video-container,
    .pdf-container {
      border-radius: var(--radius-lg);
      overflow: hidden;
      box-shadow: var(--shadow-md);
    }

    .quiz-info,
    .homework-info,
    .link-info,
    .assignment-info {
      padding: var(--spacing-lg);
      background: var(--bg-secondary);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-color);
    }

    .quiz-info h3,
    .homework-info h3,
    .link-info h3,
    .assignment-info h3 {
      color: var(--text-primary);
      font-size: 1.5rem;
      font-weight: 700;
      margin-bottom: var(--spacing-md);
    }

    .quiz-info p,
    .homework-info p,
    .link-info p,
    .assignment-info p {
      color: var(--text-secondary);
      margin-bottom: var(--spacing-lg);
      line-height: 1.6;
    }

    .reading-content-text {
      max-height: 400px;
      overflow-y: auto;
      padding: var(--spacing-lg);
      background: var(--bg-secondary);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-color);
      line-height: 1.8;
    }

    .reading-progress-indicator,
    .pdf-progress-indicator {
      text-align: center;
      margin-top: var(--spacing-md);
      padding: var(--spacing-md);
      background: var(--bg-secondary);
      border-radius: var(--radius-md);
      border: 1px solid var(--border-color);
    }

    /* Placeholder Content */
    .placeholder-content {
      text-align: center;
      padding: var(--spacing-3xl);
      color: var(--text-muted);
    }

    .placeholder-content i {
      font-size: 3rem;
      margin-bottom: var(--spacing-lg);
      opacity: 0.5;
    }

    .placeholder-content p {
      font-size: 1.1rem;
      font-weight: 500;
    }

    /* Dark theme adjustments */
    .dark-theme .content-header-section {
      background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%);
    }

    .dark-theme .content-body-section {
      background: var(--dark-card-bg);
      border-color: var(--dark-border-color);
    }

    .dark-theme .quiz-detail-item,
    .dark-theme .homework-detail-item {
      background: var(--dark-bg-secondary);
      border-color: var(--dark-border-color);
    }

    .dark-theme .quiz-progress-compact,
    .dark-theme .homework-progress-compact {
      background: var(--dark-bg-secondary);
    }

    .dark-theme .completion-detail-row {
      border-color: var(--dark-border-color);
    }

    .dark-theme .quiz-info,
    .dark-theme .homework-info,
    .dark-theme .link-info,
    .dark-theme .assignment-info {
      background: var(--dark-bg-secondary);
      border-color: var(--dark-border-color);
    }

    .dark-theme .reading-content-text {
      background: var(--dark-bg-secondary);
      border-color: var(--dark-border-color);
    }

    .dark-theme .reading-progress-indicator,
    .dark-theme .pdf-progress-indicator {
      background: var(--dark-bg-secondary);
      border-color: var(--dark-border-color);
    }

    /* Success button */
    .btn-success {
      background: var(--gradient-success);
      color: var(--text-white);
      border: none;
    }

    .btn-success:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
    }

    /* Text utilities */
    .text-success {
      color: var(--success-color) !important;
    }

    .text-warning {
      color: var(--warning-color) !important;
    }

    .text-muted {
      color: var(--text-muted) !important;
    }

    /* Attempt status badges */
    .attempt-status {
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 999px;
      color: #fff;
      font-weight: 600;
    }

    .attempt-status.passed {
      background: #10b981;
    }

    .attempt-status.failed {
      background: #ef4444;
    }

    /* SweetAlert2 Custom Styles */
    .swal2-popup-custom {
      border-radius: 16px !important;
      font-family: 'Inter', sans-serif !important;
      border: 2px solid #dc2626 !important;
    }

    .swal2-title-custom {
      color: #1f2937 !important;
      font-weight: 700 !important;
      font-size: 1.5rem !important;
    }

    .swal2-content-custom {
      color: #6b7280 !important;
    }

    .swal2-confirm-custom {
      background: #dc2626 !important;
      border: none !important;
      border-radius: 8px !important;
      font-weight: 600 !important;
      padding: 12px 24px !important;
      transition: all 0.2s ease !important;
    }

    .swal2-confirm-custom:hover {
      background: #b91c1c !important;
      transform: translateY(-1px) !important;
      box-shadow: 0 4px 12px rgba(220, 38, 38, 0.3) !important;
    }

    .swal2-cancel-custom {
      background: #6b7280 !important;
      border: none !important;
      border-radius: 8px !important;
      font-weight: 600 !important;
      padding: 12px 24px !important;
      transition: all 0.2s ease !important;
    }

    .swal2-cancel-custom:hover {
      background: #4b5563 !important;
      transform: translateY(-1px) !important;
    }

    /* Dark theme support for SweetAlert2 */
    .dark-theme .swal2-popup-custom {
      background: #1f2937 !important;
      border-color: #dc2626 !important;
    }

    .dark-theme .swal2-title-custom {
      color: #f9fafb !important;
    }

    .dark-theme .swal2-content-custom {
      color: #d1d5db !important;
    }

    /* Notification Container - Top Right, Above Header */
    .notification-container-top {
      position: fixed;
      top: 80px;
      right: 20px;
      z-index: 1100;
      display: flex;
      flex-direction: column;
      gap: 12px;
      max-width: 400px;
      pointer-events: none;
    }

    @media (max-width: 768px) {
      .notification-container-top {
        top: 70px;
        right: 10px;
        max-width: calc(100% - 20px);
      }
    }

    /* Enhanced Notification Styles */
    .enhanced-notification {
      position: relative;
      background: white;
      border-radius: 12px;
      padding: 16px 20px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
      display: flex;
      align-items: center;
      gap: 16px;
      min-width: 300px;
      max-width: 400px;
      pointer-events: auto;
      transform: translateX(450px);
      opacity: 0;
      transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      border-left: 4px solid;
      animation: slideInRight 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards;
    }

    @keyframes slideInRight {
      from {
        transform: translateX(450px);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    .enhanced-notification.show {
      transform: translateX(0);
      opacity: 1;
    }

    .enhanced-notification.hide {
      animation: slideOutRight 0.3s ease-in forwards;
    }

    @keyframes slideOutRight {
      from {
        transform: translateX(0);
        opacity: 1;
      }
      to {
        transform: translateX(450px);
        opacity: 0;
      }
    }

    .enhanced-notification.success {
      border-left-color: #10b981;
      background: linear-gradient(135deg, #ffffff 0%, #f0fdf4 100%);
    }

    .enhanced-notification.info {
      border-left-color: #3b82f6;
      background: linear-gradient(135deg, #ffffff 0%, #eff6ff 100%);
    }

    .enhanced-notification.warning {
      border-left-color: #f59e0b;
      background: linear-gradient(135deg, #ffffff 0%, #fffbeb 100%);
    }

    .enhanced-notification.error {
      border-left-color: #ef4444;
      background: linear-gradient(135deg, #ffffff 0%, #fef2f2 100%);
    }

    .enhanced-notification-icon {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      flex-shrink: 0;
    }

    .enhanced-notification.success .enhanced-notification-icon {
      background: linear-gradient(135deg, #10b981, #059669);
      color: white;
    }

    .enhanced-notification.info .enhanced-notification-icon {
      background: linear-gradient(135deg, #3b82f6, #2563eb);
      color: white;
    }

    .enhanced-notification.warning .enhanced-notification-icon {
      background: linear-gradient(135deg, #f59e0b, #d97706);
      color: white;
    }

    .enhanced-notification.error .enhanced-notification-icon {
      background: linear-gradient(135deg, #ef4444, #dc2626);
      color: white;
    }

    .enhanced-notification-content {
      flex: 1;
      min-width: 0;
    }

    .enhanced-notification-title {
      font-weight: 600;
      font-size: 15px;
      color: #1f2937;
      margin: 0 0 4px 0;
      line-height: 1.3;
    }

    .enhanced-notification-message {
      font-size: 13px;
      color: #6b7280;
      margin: 0;
      line-height: 1.4;
    }

    .enhanced-notification-close {
      background: none;
      border: none;
      color: #9ca3af;
      font-size: 18px;
      cursor: pointer;
      padding: 4px;
      line-height: 1;
      transition: color 0.2s ease;
      flex-shrink: 0;
    }

    .enhanced-notification-close:hover {
      color: #6b7280;
    }

    /* Dark theme support for notifications */
    .dark-theme .enhanced-notification {
      background: #1f2937;
      border-color: #374151;
    }

    .dark-theme .enhanced-notification.success {
      background: linear-gradient(135deg, #1f2937 0%, #064e3b 100%);
    }

    .dark-theme .enhanced-notification.info {
      background: linear-gradient(135deg, #1f2937 0%, #1e3a8a 100%);
    }

    .dark-theme .enhanced-notification.warning {
      background: linear-gradient(135deg, #1f2937 0%, #78350f 100%);
    }

    .dark-theme .enhanced-notification.error {
      background: linear-gradient(135deg, #1f2937 0%, #7f1d1d 100%);
    }

    .dark-theme .enhanced-notification-title {
      color: #f9fafb;
    }

    .dark-theme .enhanced-notification-message {
      color: #d1d5db;
    }

    .dark-theme .enhanced-notification-close {
      color: #9ca3af;
    }

    .dark-theme .enhanced-notification-close:hover {
      color: #d1d5db;
    }
  </style>

  <!-- Meta Tags -->
  <meta name="description" content="<%= contentItem.title %> - Continue your learning journey">
  <meta name="theme-color" content="#dc2626">
</head>

<body class="<%= theme %>-theme">
  <!-- Student Layout -->
  <div class="student-layout">
    <!-- Include Sidebar -->
    <%- include('partials/student-sidebar', { currentPage: 'courses', student: student }) %>

    <!-- Main Content -->
    <main class="student-main">
      <!-- Include Header -->
      <%- include('partials/student-header', { title: 'Content', student: student, theme: theme, currentPage: 'content', backLink: `/student/course/${course._id}/content` }) %>

      <!-- Notification Container (Top Right, Above Header) -->
      <div id="notification-container" class="notification-container-top"></div>

      <!-- Content Details -->
      <div class="student-content">

        <!-- Content Header -->
        <div class="content-header-section">
          <div class="content-header-content">
            <div class="content-header-info">
              <div class="content-type-badge <%= contentItem.type %>">
                <i class="fas fa-<%= getContentIcon(contentItem.type) %>"></i>
                <span><%= contentItem.type.charAt(0).toUpperCase() + contentItem.type.slice(1) %></span>
              </div>

              <h1 class="content-title-main"><%= contentItem.title %></h1>

              <% if (contentItem.description) { %>
              <p class="content-description-main"><%= contentItem.description %></p>
              <% } %>

              <div class="content-meta-info">
                
                <div class="meta-item">
                  <i class="fas fa-target"></i>
                  <span><%= contentItem.completionCriteria.replace('_', ' ') %></span>
                </div>
              </div>
            </div>

            <div class="content-progress-section">
              <div class="progress-circle-large">
                <svg viewBox="0 0 120 120" class="progress-ring-large">
                  <circle class="circle-bg-large" cx="60" cy="60" r="50"></circle>
                  <circle class="circle-large" cx="60" cy="60" r="50" stroke-dasharray="<%= contentProgress.progressPercentage * 3.14 %>, 314"></circle>
                </svg>
                <div class="progress-text">
                  <span class="progress-percentage"><%= contentProgress.progressPercentage %>%</span>
                  <span class="progress-label">Complete</span>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Content Body -->
        <div class="content-body-section">
          <% if (contentItem.type === 'video') { %>
          <div class="video-content">
            <!-- Video Watch Limit Info -->
            <% if (watchLimitInfo && watchLimitInfo.hasLimit) { %>
            <div class="alert <%= watchLimitInfo.limitReached ? 'alert-danger' : 'alert-info' %>" style="margin-bottom: 1rem; border-radius: 8px;">
              <div style="display: flex; align-items: center; gap: 12px;">
                <i class="fas fa-eye" style="font-size: 1.5rem;"></i>
                <div style="flex: 1;">
                  <strong style="display: block; margin-bottom: 4px;">
                    <% if (watchLimitInfo.limitReached) { %>
                      Watch Limit Reached
                    <% } else { %>
                      Watch Limit Information
                    <% } %>
                  </strong>
                  <span>
                    You have watched this video <strong><%= watchLimitInfo.watchCount %></strong> out of <strong><%= watchLimitInfo.maxWatchCount %></strong> allowed times.
                    <% if (!watchLimitInfo.limitReached) { %>
                      <br>Remaining watches: <strong><%= watchLimitInfo.watchesLeft %></strong>
                    <% } else { %>
                      <br>You cannot watch this video again.
                    <% } %>
                  </span>
                </div>
              </div>
            </div>
            <% } %>

            <div class="video-container">
              <% if (watchLimitInfo && watchLimitInfo.limitReached) { %>
              <!-- Show blocked message if limit reached -->
              <div class="placeholder-content" style="background: linear-gradient(135deg, #ef4444, #dc2626); color: white;">
                <i class="fas fa-ban" style="font-size: 3rem; margin-bottom: 1rem;"></i>
                <h3 style="margin-bottom: 0.5rem;">Video Access Blocked</h3>
                <p style="margin-bottom: 0;">You have reached the maximum watch limit for this video.</p>
                <p style="font-size: 0.9rem; opacity: 0.9;">Watched <%= watchLimitInfo.watchCount %> / <%= watchLimitInfo.maxWatchCount %> times</p>
              </div>
              <% } else if (contentItem.content) { %>
                <% 
                  // Check if content contains YouTube iframe
                  const youtubeRegex = /(?:youtube\.com\/embed\/|youtu\.be\/|youtube\.com\/watch\?v=)([a-zA-Z0-9_-]{11})/;
                  const youtubeMatch = contentItem.content.match(youtubeRegex);
                  const isYouTube = youtubeMatch !== null;
                  const youtubeVideoId = isYouTube ? youtubeMatch[1] : null;
                  
                  // Get student info for watermark
                  const studentName = student.firstName && student.lastName 
                    ? `${student.firstName} ${student.lastName}` 
                    : student.name || 'Student';
                  const studentCode = student.studentCode || student.studentNumber || '';
                %>
                <% if (isYouTube && youtubeVideoId) { %>
                  <!-- YouTube Player Container with Dynamic Watermark -->
                  <div class="video-player-wrapper-with-watermark" id="youtube-video-wrapper">
                    <div id="youtube-player-container" style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; border-radius: 12px; background: #000; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);">
                      <div id="youtube-player" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></div>
                      <!-- Dynamic Moving Watermark -->
                      <div class="video-watermark video-watermark-moving" id="youtubeWatermark">
                        <span class="watermark-text"><%= studentName %></span>
                        <% if (studentCode) { %>
                        <span class="watermark-separator">|</span>
                        <span class="watermark-code"><%= studentCode %></span>
                        <% } %>
                      </div>
                      <!-- Real-time Watch Progress Indicator for YouTube -->
                      <div id="youtubeWatchProgress" style="position: absolute; top: 10px; right: 10px; background: rgba(0, 0, 0, 0.85); color: white; padding: 12px 16px; border-radius: 8px; font-size: 13px; font-weight: 600; z-index: 1000; box-shadow: 0 2px 8px rgba(0,0,0,0.3); display: none; backdrop-filter: blur(10px);">
                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
                          <i class="fas fa-eye" style="color: #10b981;"></i>
                          <span style="font-size: 14px;">Watch Progress</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 10px;">
                          <div style="flex: 1;">
                            <div style="font-size: 20px; color: #10b981; margin-bottom: 2px;" id="youtubeWatchProgressPercent">0%</div>
                            <div style="font-size: 11px; opacity: 0.8;" id="youtubeWatchProgressTime">0:00 / 0:00</div>
                          </div>
                          <div style="width: 50px; height: 50px; position: relative;">
                            <svg width="50" height="50" style="transform: rotate(-90deg);">
                              <circle cx="25" cy="25" r="20" fill="none" stroke="rgba(255,255,255,0.2)" stroke-width="3"></circle>
                              <circle id="youtubeWatchProgressCircle" cx="25" cy="25" r="20" fill="none" stroke="#10b981" stroke-width="3" stroke-dasharray="125.6" stroke-dashoffset="125.6" stroke-linecap="round"></circle>
                            </svg>
                            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 10px; font-weight: bold;" id="youtubeWatchProgressCircleText">0%</div>
                          </div>
                        </div>
                        <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.2); font-size: 11px; opacity: 0.9;">
                          <div style="display: flex; justify-content: space-between; margin-bottom: 3px;">
                            <span>Required:</span>
                            <span style="color: #fbbf24;">90%</span>
                          </div>
                          <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                            <span>Remaining:</span>
                            <span style="color: #ef4444;" id="youtubeWatchProgressRemaining">90%</span>
                          </div>
                          <div style="font-size: 10px; opacity: 0.7; margin-top: 4px;">
                            <i class="fas fa-info-circle"></i> Can seek up to: <span id="youtubeMaxSeekTime" style="color: #10b981;">0:00</span>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                  <script>
                    window.youtubeVideoId = '<%= youtubeVideoId %>';
                    window.studentWatermark = {
                      name: '<%= studentName %>',
                      code: '<%= studentCode %>'
                    };
                  </script>
                <% } else { %>
                  <!-- Regular video content (Bunny Stream, etc.) with Dynamic Watermark -->
                  <div class="video-player-wrapper-with-watermark" id="bunny-video-wrapper">
                    <div class="bunny-video-container-inner" id="bunny-video-container-inner">
                      <%- contentItem.content %>
                    </div>
                    <!-- Dynamic Moving Watermark - positioned on wrapper -->
                    <style>
                      @media (max-width: 768px) {
                        #bunnyWatermark, #youtubeWatermark {
                          position: relative !important;
                          top: auto !important;
                          left: auto !important;
                          right: auto !important;
                          bottom: auto !important;
                          transform: none !important;
                          animation: none !important;
                          display: flex !important;
                          justify-content: center !important;
                          align-items: center !important;
                          width: 100% !important;
                          height: 16px !important;
                          font-size: 6px !important;
                          padding: 2px 6px !important;
                          margin-top: 4px !important;
                          gap: 2px !important;
                          border-radius: 0 !important;
                          background: rgba(0,0,0,0.7) !important;
                          backdrop-filter: none !important;
                          box-shadow: none !important;
                        }
                        #bunnyWatermark span, #youtubeWatermark span {
                          font-size: 6px !important;
                          text-shadow: none !important;
                        }
                      }
                    </style>
                    <div class="video-watermark video-watermark-moving" id="bunnyWatermark">
                      <span class="watermark-text"><%= studentName %></span>
                      <% if (studentCode) { %>
                      <span class="watermark-separator">|</span>
                      <span class="watermark-code"><%= studentCode %></span>
                      <% } %>
                    </div>
                    <!-- Real-time Watch Progress Indicator -->
                    <div id="videoWatchProgress" style="position: absolute; top: 10px; right: 10px; background: rgba(0, 0, 0, 0.85); color: white; padding: 12px 16px; border-radius: 8px; font-size: 13px; font-weight: 600; z-index: 1000; box-shadow: 0 2px 8px rgba(0,0,0,0.3); display: none; backdrop-filter: blur(10px);">
                      <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
                        <i class="fas fa-eye" style="color: #10b981;"></i>
                        <span style="font-size: 14px;">Watch Progress</span>
                      </div>
                      <div style="display: flex; align-items: center; gap: 10px;">
                        <div style="flex: 1;">
                          <div style="font-size: 20px; color: #10b981; margin-bottom: 2px;" id="watchProgressPercent">0%</div>
                          <div style="font-size: 11px; opacity: 0.8;" id="watchProgressTime">0:00 / 0:00</div>
                        </div>
                        <div style="width: 50px; height: 50px; position: relative;">
                          <svg width="50" height="50" style="transform: rotate(-90deg);">
                            <circle cx="25" cy="25" r="20" fill="none" stroke="rgba(255,255,255,0.2)" stroke-width="3"></circle>
                            <circle id="watchProgressCircle" cx="25" cy="25" r="20" fill="none" stroke="#10b981" stroke-width="3" stroke-dasharray="125.6" stroke-dashoffset="125.6" stroke-linecap="round"></circle>
                          </svg>
                          <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 10px; font-weight: bold;" id="watchProgressCircleText">0%</div>
                        </div>
                      </div>
                      <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.2); font-size: 11px; opacity: 0.9;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 3px;">
                          <span>Required:</span>
                          <span style="color: #fbbf24;">90%</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                          <span>Remaining:</span>
                          <span style="color: #ef4444;" id="watchProgressRemaining">90%</span>
                        </div>
                        <div style="font-size: 10px; opacity: 0.7; margin-top: 4px;">
                          <i class="fas fa-info-circle"></i> Can seek up to: <span id="maxSeekTime" style="color: #10b981;">0:00</span>
                        </div>
                      </div>
                    </div>
                  </div>
                  <script>
                    window.studentWatermark = {
                      name: '<%= studentName %>',
                      code: '<%= studentCode %>'
                    };
                  </script>
                <% } %>
              <% } else { %>
              <div class="placeholder-content">
                <i class="fas fa-video"></i>
                <p>Video content will be available here</p>
              </div>
              <% } %>
            </div>
          </div>
          <% } else if (contentItem.type === 'pdf') { %>
          <div class="pdf-content">
            <div class="pdf-container">
              <% if (contentItem.content) { %>
              <iframe src="<%= contentItem.content %>" width="100%" height="600"></iframe>
              <% } else { %>
              <div class="placeholder-content">
                <i class="fas fa-file-pdf"></i>
                <p>PDF content will be available here</p>
              </div>
              <% } %>
            </div>
          </div>
          <% } else if (contentItem.type === 'quiz') { %>
          <div class="quiz-content">
            <div class="quiz-info">
              <h3>Quiz Information</h3>
              <p style="margin-bottom: 8px; opacity: 0.9;">Answer all questions to finish. Passing score applies to unlock results.</p>

              <!-- Compact Quiz Details Row -->
              <div class="quiz-details-compact">
                <div class="quiz-detail-item">
                  <i class="fas fa-list-ol"></i>
                  <span class="detail-label">Questions</span>
                  <span class="detail-value"><%= contentItem.selectedQuestions ? contentItem.selectedQuestions.length : 0 %></span>
                </div>
                <div class="quiz-detail-item">
                  <i class="fas fa-target"></i>
                  <span class="detail-label">Pass</span>
                  <span class="detail-value">
                    <% if (contentItem.quizSettings && contentItem.quizSettings.passingScore !== undefined) { %>
                    <%= contentItem.quizSettings.passingScore %>%
                    <% } else { %>
                    50%
                    <% } %>
                  </span>
                </div>
                <% if (contentItem.quizSettings && contentItem.quizSettings.maxAttempts) { %>
                <div class="quiz-detail-item">
                  <i class="fas fa-redo"></i>
                  <span class="detail-label">Attempts</span>
                  <span class="detail-value"><%= contentItem.quizSettings.maxAttempts %></span>
                </div>
                <% } %>
              </div>

              <!-- Progress Info -->
              <% if (contentProgress && contentProgress.attempts > 0) { %>
              <div class="quiz-progress-compact">
                <div class="progress-item">
                  <span class="progress-label">Attempts:</span>
                  <span class="progress-value"><%= contentProgress.attempts %></span>
                </div>
                <% if (contentProgress.bestScore !== undefined) { %>
                <div class="progress-item">
                  <span class="progress-label">Best Score:</span>
                  <span class="progress-value"><%= contentProgress.bestScore %>%</span>
                </div>
                <% } %>
              </div>
              <!-- Attempts Cards -->
              <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap:12px; margin-top:10px;">
                <% const attemptsList = (contentProgress.attemptsList || []); %>
                <% attemptsList.forEach(function(a, i){ %>
                <div style="border:1px solid var(--border-color); border-radius:10px; padding:12px; background:var(--card-bg);">
                  <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
                    <strong style="font-size:13px;">Attempt <%= i+1 %></strong>
                    <span class="attempt-status <%= a.passed ? 'passed' : 'failed' %>"><%= a.passed ? 'Passed' : 'Failed' %></span>
                  </div>
                  <div style="display:flex; justify-content:space-between; font-size:12px; opacity:.9;">
                    <span>Score</span>
                    <span><%= a.score %>%</span>
                  </div>
                  <div style="display:flex; justify-content:space-between; font-size:12px; opacity:.9;">
                    <span>Correct</span>
                    <span><%= a.correctAnswers %>/<%= a.totalQuestions %></span>
                  </div>
                  <div style="display:flex; justify-content:space-between; font-size:12px; opacity:.9;">
                    <span>Time</span>
                    <span><%= Math.round((a.timeSpent||0)/60) %>m</span>
                  </div>
                </div>
                <% }) %>
              </div>
              <% } %>

              <% const latest = (contentProgress.attemptsList||[])[(contentProgress.attemptsList||[]).length-1]; %>
              <% if (latest && latest.passed) { %>
              <div class="quiz-completed-compact">
                <div class="completion-badge-compact">
                  <i class="fas fa-check-circle"></i>
                  <span>Quiz Completed</span>
                </div>
                <div class="completion-details-compact">
                  <div class="completion-detail-row">
                    <span class="detail-label">Best Score:</span>
                    <span class="detail-value"><%= contentProgress.bestScore %>%</span>
                  </div>
                  <div class="completion-detail-row">
                    <span class="detail-label">Attempts:</span>
                    <span class="detail-value"><%= contentProgress.attempts %></span>
                  </div>
                  <div class="completion-detail-row">
                    <span class="detail-label">Completed:</span>
                    <span class="detail-value"><%= contentProgress.completedAt ? new Date(contentProgress.completedAt).toLocaleDateString() : 'Recently' %></span>
                  </div>
                </div>
                <div class="completion-actions-compact">
                  <a href="/student/content/<%= contentItem._id %>/results" class="btn btn-primary btn-sm">
                    <i class="fas fa-chart-line"></i>
                    View Results
                  </a>
                </div>
              </div>
              <% } else { %>
              <% const outOfAttempts = attemptPolicy && attemptPolicy.outOfAttempts; %>
              <button class="btn btn-primary btn-sm" style="padding:8px 14px; border-radius:8px; font-weight:600;" onclick="startQuiz('<%= contentItem._id %>', '<%= contentItem.type %>')" <%= outOfAttempts ? 'disabled' : '' %>>
                <i class="fas <%= outOfAttempts ? 'fa-lock' : 'fa-play' %>"></i>
                <%= outOfAttempts ? 'Out of attempts' : (timing && timing.remainingSeconds > 0 ? 'Resume Quiz' : 'Start Quiz') %>
              </button>
              <% if (attemptPolicy && attemptPolicy.maxAttempts) { %>
              <div style="margin-top:6px; font-size:12px; opacity:.8;">
                Attempts: <%= attemptPolicy.maxAttempts - (attemptPolicy.remainingAttempts||0) %>/<%= attemptPolicy.maxAttempts %>
              </div>
              <% } %>
              <% } %>
            </div>
          </div>
          <% } else if (contentItem.type === 'homework') { %>
          <div class="homework-content">
            <div class="homework-info">
              <h3>Homework Assignment</h3>
              <% 
                const homeworkPassingScore = contentItem.homeworkSettings && contentItem.homeworkSettings.passingScore !== undefined 
                  ? contentItem.homeworkSettings.passingScore 
                  : 0;
              %>
              <% if (homeworkPassingScore === 0) { %>
                <p>This is a homework assignment. Simply submit your work to complete it - no minimum score required.</p>
              <% } else { %>
                <p>This is a homework assignment. Complete the requirements and submit your work. You need to score at least <%= homeworkPassingScore %>% to pass.</p>
              <% } %>

              <!-- Compact Homework Details Row -->
              <div class="homework-details-compact">
                <div class="homework-detail-item">
                  <i class="fas fa-list-ol"></i>
                  <span class="detail-label">Questions</span>
                  <span class="detail-value"><%= contentItem.selectedQuestions ? contentItem.selectedQuestions.length : 0 %></span>
                </div>
                <div class="homework-detail-item">
                  <i class="fas fa-target"></i>
                  <span class="detail-label">Pass</span>
                  <span class="detail-value">
                    <% if (contentItem.homeworkSettings && contentItem.homeworkSettings.passingScore !== undefined) { %>
                    <%= contentItem.homeworkSettings.passingScore %>%
                    <% } else { %>
                    0%
                    <% } %>
                  </span>
                </div>
                <% if (contentItem.homeworkSettings && contentItem.homeworkSettings.maxAttempts) { %>
                <div class="homework-detail-item">
                  <i class="fas fa-redo"></i>
                  <span class="detail-label">Attempts</span>
                  <span class="detail-value"><%= contentItem.homeworkSettings.maxAttempts %></span>
                </div>
                <% } %>
              </div>

              <!-- Progress Info -->
              <% if (contentProgress && contentProgress.attempts > 0) { %>
              <div class="homework-progress-compact">
                <div class="progress-item">
                  <span class="progress-label">Attempts:</span>
                  <span class="progress-value"><%= contentProgress.attempts %></span>
                </div>
                <% if (contentProgress.bestScore !== undefined) { %>
                <div class="progress-item">
                  <span class="progress-label">Best Score:</span>
                  <span class="progress-value"><%= contentProgress.bestScore %>%</span>
                </div>
                <% } %>
                <div class="progress-item">
                  <span class="progress-label">Status:</span>
                  <span class="progress-value <%= contentProgress.completionStatus === 'completed' ? 'text-success' : 'text-warning' %>">
                    <%= contentProgress.completionStatus === 'completed' ? 'Completed' : 'In Progress' %>
                  </span>
                </div>
              </div>
              <% } %>

              <% if (contentProgress && contentProgress.completionStatus === 'completed') { %>
              <div class="homework-completed-compact">
                <div class="completion-badge-compact">
                  <i class="fas fa-check-circle"></i>
                  <span>Homework Completed</span>
                </div>
                <div class="completion-details-compact">
                  <div class="completion-detail-row">
                    <span class="detail-label">Best Score:</span>
                    <span class="detail-value"><%= contentProgress.bestScore %>%</span>
                  </div>
                  <div class="completion-detail-row">
                    <span class="detail-label">Attempts:</span>
                    <span class="detail-value"><%= contentProgress.attempts %></span>
                  </div>
                  <div class="completion-detail-row">
                    <span class="detail-label">Completed:</span>
                    <span class="detail-value"><%= contentProgress.completedAt ? new Date(contentProgress.completedAt).toLocaleDateString() : 'Recently' %></span>
                  </div>
                </div>
                <div class="completion-actions-compact">
                  <a href="/student/content/<%= contentItem._id %>/results" class="btn btn-primary btn-sm">
                    <i class="fas fa-chart-line"></i>
                    View Results
                  </a>
                </div>
              </div>
              <% } else { %>
              <% const outOfAttempts = attemptPolicy && attemptPolicy.outOfAttempts; %>
              <button class="btn btn-primary btn-lg" onclick="startQuiz('<%= contentItem._id %>', '<%= contentItem.type %>')" <%= outOfAttempts ? 'disabled' : '' %>>
                <i class="fas <%= outOfAttempts ? 'fa-lock' : 'fa-tasks' %>"></i>
                <%= outOfAttempts ? 'Out of attempts' : (timing && timing.remainingSeconds > 0 ? 'Resume Homework' : 'Start Homework') %>
              </button>
              <% if (attemptPolicy && attemptPolicy.maxAttempts) { %>
              <div style="margin-top:6px; font-size:12px; opacity:.8;">
                Attempts: <%= attemptPolicy.maxAttempts - (attemptPolicy.remainingAttempts||0) %>/<%= attemptPolicy.maxAttempts %>
              </div>
              <% } %>
              <% } %>
            </div>
          </div>
          <% } else if (contentItem.type === 'reading') { %>
          <div class="reading-content">
            <div class="reading-text">
              <% if (contentItem.content) { %>
              <div class="reading-content-text">
                <%= contentItem.content %>
              </div>
              <% } else { %>
              <div class="placeholder-content">
                <i class="fas fa-book-open"></i>
                <p>Reading content will be available here</p>
              </div>
              <% } %>
            </div>
          </div>
          <% } else if (contentItem.type === 'link') { %>
          <div class="link-content">
            <div class="link-info">
              <h3>External Link</h3>
              <p>This content contains an external link to additional resources.</p>
              <% if (contentItem.content) { %>
              <a href="<%= contentItem.content %>" target="_blank" class="btn btn-primary btn-lg">
                <i class="fas fa-external-link-alt"></i>
                Open Link
              </a>
              <% } else { %>
              <div class="placeholder-content">
                <i class="fas fa-link"></i>
                <p>Link content will be available here</p>
              </div>
              <% } %>
            </div>
          </div>
          <% } else if (contentItem.type === 'assignment') { %>
          <div class="assignment-content">
            <div class="assignment-info">
              <h3>Assignment</h3>
              <p>Download the assignment materials below.</p>
              <% if (contentItem.content) { %>
              <div style="display:flex; gap:10px; align-items:center; margin-top:8px;">
                <a href="<%= contentItem.content %>" target="_blank" class="btn btn-outline btn-sm">
                  <i class="fas fa-download"></i>
                  Download Assignment
                </a>
              </div>
              <% } else { %>
              <div class="placeholder-content">
                <i class="fas fa-file"></i>
                <p>Assignment will be available here</p>
              </div>
              <% } %>
            </div>
          </div>
          <% } %>

          <% if (contentItem.type === 'zoom') { %>
          <!-- Zoom Meeting Content - Simplified like other content types -->
          <% 
            const zoomMeeting = contentItem.zoomMeeting;
          %>

          <% if (zoomMeeting) { %>
          <div class="zoom-meeting-container">
            <!-- Meeting Info Header Card - Simplified for ended sessions -->
            <% if (zoomMeeting.status === 'ended') { %>
            <!-- Compact header for recordings -->
            <div class="meeting-info-card-compact" style="background: linear-gradient(135deg, var(--primary-color), #b91c1c); color: white; padding: 12px 16px; border-radius: 10px; display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 10px;">
              <div style="display: flex; align-items: center; gap: 10px;">
                <i class="fas fa-video" style="font-size: 1.1rem;"></i>
                <span style="font-weight: 600; font-size: 1rem;"><%= zoomMeeting.meetingName %></span>
              </div>
              <div style="display: flex; align-items: center; gap: 12px; font-size: 0.85rem; opacity: 0.95;">
                <% if (zoomMeeting.duration) { %>
                <span><i class="fas fa-clock me-1"></i><%= zoomMeeting.duration %> min</span>
                <% } %>
              </div>
            </div>
            <% } else { %>
            <!-- Full header for scheduled/active meetings -->
            <div class="meeting-info-card">
              <div class="meeting-status-badge status-<%= zoomMeeting.status %>">
                <i class="fas fa-<%= zoomMeeting.status === 'scheduled' ? 'clock' : zoomMeeting.status === 'active' ? 'video' : 'check-circle' %>"></i>
                <%= zoomMeeting.status.charAt(0).toUpperCase() + zoomMeeting.status.slice(1) %>
              </div>

              <h4 class="meeting-title">
                <i class="fas fa-video me-2"></i>
                <%= zoomMeeting.meetingName %>
              </h4>

              <p class="meeting-topic">
                <%= zoomMeeting.meetingTopic || contentItem.description || 'Live Zoom session' %>
              </p>

              <div class="meeting-meta">
                <div class="meta-item">
                  <i class="far fa-calendar"></i>
                  <span><%= new Date(zoomMeeting.scheduledStartTime).toLocaleDateString() %></span>
                </div>
                <div class="meta-item">
                  <i class="far fa-clock"></i>
                  <span><%= new Date(zoomMeeting.scheduledStartTime).toLocaleTimeString() %></span>
                </div>
                <div class="meta-item">
                  <i class="fas fa-hourglass-half"></i>
                  <span><%= zoomMeeting.duration %> minutes</span>
                </div>
              </div>
            </div>
            <% } %>

            <!-- Meeting Status Sections -->
            <% if (zoomMeeting.status === 'scheduled') { %>
            <!-- Meeting Locked (Not Started) -->
            <div class="meeting-locked-section">
              <div class="locked-icon">
                <i class="fas fa-lock"></i>
              </div>
              <h5>Meeting Not Started Yet</h5>
              <p>This live session is scheduled for:</p>
              <div class="scheduled-time">
                <%= new Date(zoomMeeting.scheduledStartTime).toLocaleString('en-US', {
                                    weekday: 'long',
                                    year: 'numeric',
                                    month: 'long',
                                    day: 'numeric',
                                    hour: '2-digit',
                                    minute: '2-digit'
                                  }) %>
              </div>
              <p class="mt-3 text-muted">
                The meeting will be unlocked when your instructor starts the session. You'll be able to join at that time.
              </p>
            </div>

            <% } else if (zoomMeeting.status === 'active') { %>
            <!-- Meeting Active (Can Join) -->
            <div class="meeting-active-section">
              <div class="active-pulse">
                <i class="fas fa-circle"></i>
              </div>
              <h5>Live Session in Progress</h5>
              <p>Join the live Zoom session now!</p>

              <div class="join-options mt-4">
                <!-- Join Meeting Button - Marks as completed and shows modal -->
                <% if (!contentProgress.isCompleted) { %>
                <button class="btn btn-primary btn-lg" onclick="joinZoomMeeting()">
                  <i class="fas fa-video me-2"></i>
                  Join Meeting
                </button>
                <p class="text-muted mt-2" style="font-size: 13px;">
                  <i class="fas fa-info-circle"></i> Click to join the meeting and mark content as completed.
                </p>
                <% } else { %>
                <button class="btn btn-outline-primary btn-lg" onclick="joinZoomMeeting()">
                  <i class="fas fa-video me-2"></i>
                  Join Meeting Again
                </button>
                <% } %>
              </div>

              <!-- Meeting Details -->
              <% if (zoomMeeting.password) { %>
              <div class="meeting-password mt-4">
                <strong>Meeting Password:</strong>
                <code><%= zoomMeeting.password %></code>
              </div>
              <% } %>
            </div>

            <% } else if (zoomMeeting.status === 'ended') { %>
            <!-- Meeting Ended -->
            <div class="meeting-compact-info">
              <div class="compact-info-left">
                <i class="fas fa-video"></i>
                <span>Session Recording</span>
              </div>
              <% if (contentProgress.isCompleted) { %>
              <div class="compact-info-right completed">
                <i class="fas fa-check-circle"></i>
                <span>Watched</span>
              </div>
              <% } %>
            </div>

            <% if (zoomMeeting.recordingUrl) { %>
            <div class="recording-player-section">


                <!-- Video Player Container - Supports both Bunny and YouTube with Watermark -->
                <div class="recording-player-wrapper">
                  <% 
                    // Check if recording URL is a YouTube video
                    const recordingYoutubeRegex = /(?:youtube\.com\/embed\/|youtu\.be\/|youtube\.com\/watch\?v=)([a-zA-Z0-9_-]{11})/;
                    const recordingYoutubeMatch = zoomMeeting.recordingUrl.match(recordingYoutubeRegex);
                    const isRecordingYouTube = recordingYoutubeMatch !== null;
                    const recordingYoutubeVideoId = isRecordingYouTube ? recordingYoutubeMatch[1] : null;
                    
                    // Get student info for watermark
                    const recordingStudentName = student.firstName && student.lastName 
                      ? `${student.firstName} ${student.lastName}` 
                      : student.name || 'Student';
                    const recordingStudentCode = student.studentCode || student.studentNumber || '';
                  %>
                  <div class="video-player-wrapper-with-watermark" id="recording-video-wrapper">
                    <% if (isRecordingYouTube && recordingYoutubeVideoId) { %>
                      <!-- YouTube Player Container with Watermark -->
                      <div class="video-player-container" style="position: relative; padding-top: 56.25%; border-radius: 12px; overflow: hidden; background: #000; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);">
                        <div id="recording-youtube-player" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></div>
                        <!-- Dynamic Moving Watermark -->
                        <div class="video-watermark video-watermark-moving" id="recordingYoutubeWatermark">
                          <span class="watermark-text"><%= recordingStudentName %></span>
                          <% if (recordingStudentCode) { %>
                          <span class="watermark-separator">|</span>
                          <span class="watermark-code"><%= recordingStudentCode %></span>
                          <% } %>
                        </div>
                      </div>
                      <script>
                        window.recordingYoutubeVideoId = '<%= recordingYoutubeVideoId %>';
                      </script>
                    <% } else { %>
                      <!-- Bunny/Regular Video Player Container with Watermark -->
                      <% 
                        // Check if recordingUrl is HTML embed code or a regular URL
                        const isEmbedCode = zoomMeeting.recordingUrl && (
                          zoomMeeting.recordingUrl.includes('<div') || 
                          zoomMeeting.recordingUrl.includes('<iframe') ||
                          zoomMeeting.recordingUrl.trim().startsWith('<')
                        );
                      %>
                      <div class="video-player-container recording-video-container" style="position: relative; padding-top: 56.25%; border-radius: 12px; overflow: hidden; background: #000; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);">
                        <% if (isEmbedCode) { %>
                          <!-- Render embed code directly (Bunny CDN embed) -->
                          <div class="bunny-embed-wrapper" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;">
                            <%- zoomMeeting.recordingUrl %>
                          </div>
                          <style>
                            /* Ensure Bunny embed iframe fills its container */
                            .bunny-embed-wrapper iframe,
                            .bunny-embed-wrapper > div,
                            .bunny-embed-wrapper > div > iframe {
                              position: absolute !important;
                              top: 0 !important;
                              left: 0 !important;
                              width: 100% !important;
                              height: 100% !important;
                              border: 0 !important;
                            }
                            .bunny-embed-wrapper > div {
                              position: absolute !important;
                              width: 100% !important;
                              height: 100% !important;
                            }
                          </style>
                        <% } else { %>
                          <!-- Regular URL - use iframe -->
                          <iframe id="recordingPlayer" 
                            src="<%= zoomMeeting.recordingUrl %>" 
                            style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: 0;" 
                            loading="lazy"
                            allow="accelerometer; gyroscope; autoplay; encrypted-media; picture-in-picture;" 
                            allowfullscreen="true">
                          </iframe>
                        <% } %>
                        <!-- Dynamic Moving Watermark -->
                        <style>
                          @media (max-width: 768px) {
                            #recordingBunnyWatermark, #recordingYoutubeWatermark {
                              position: relative !important;
                              top: auto !important;
                              left: auto !important;
                              right: auto !important;
                              bottom: auto !important;
                              transform: none !important;
                              animation: none !important;
                              display: flex !important;
                              justify-content: center !important;
                              align-items: center !important;
                              width: 100% !important;
                              height: 16px !important;
                              font-size: 6px !important;
                              padding: 2px 6px !important;
                              margin-top: 4px !important;
                              gap: 2px !important;
                              border-radius: 0 !important;
                              background: rgba(0,0,0,0.7) !important;
                              backdrop-filter: none !important;
                              box-shadow: none !important;
                            }
                            #recordingBunnyWatermark span, #recordingYoutubeWatermark span {
                              font-size: 6px !important;
                              text-shadow: none !important;
                            }
                          }
                        </style>
                        <div class="video-watermark video-watermark-moving" id="recordingBunnyWatermark">
                          <span class="watermark-text"><%= recordingStudentName %></span>
                          <% if (recordingStudentCode) { %>
                          <span class="watermark-separator">|</span>
                          <span class="watermark-code"><%= recordingStudentCode %></span>
                          <% } %>
                        </div>
                        <!-- Watch Progress Overlay for Non-Attendees (same as regular video) -->
                        <% if (!studentAttendedLiveMeeting && !contentProgress.isCompleted) { %>
                        <div id="recordingWatchProgressOverlay" style="position: absolute; top: 10px; right: 10px; background: rgba(0, 0, 0, 0.85); color: white; padding: 12px 16px; border-radius: 8px; font-size: 13px; font-weight: 600; z-index: 1000; box-shadow: 0 2px 8px rgba(0,0,0,0.3); backdrop-filter: blur(10px);">
                          <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
                            <i class="fas fa-eye" style="color: #10b981;"></i>
                            <span style="font-size: 14px;">Watch Progress</span>
                          </div>
                          <div style="display: flex; align-items: center; gap: 10px;">
                            <div style="flex: 1;">
                              <div style="font-size: 20px; color: #10b981; margin-bottom: 2px;" id="recWatchPercent">0%</div>
                              <div style="font-size: 11px; opacity: 0.8;" id="recWatchTime">0:00 / 0:00</div>
                            </div>
                            <div style="width: 50px; height: 50px; position: relative;">
                              <svg width="50" height="50" style="transform: rotate(-90deg);">
                                <circle cx="25" cy="25" r="20" fill="none" stroke="rgba(255,255,255,0.2)" stroke-width="3"></circle>
                                <circle id="recWatchCircle" cx="25" cy="25" r="20" fill="none" stroke="#10b981" stroke-width="3" stroke-dasharray="125.6" stroke-dashoffset="125.6" stroke-linecap="round"></circle>
                              </svg>
                              <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 10px; font-weight: bold;" id="recWatchCircleText">0%</div>
                            </div>
                          </div>
                          <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.2); font-size: 11px; opacity: 0.9;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 3px;">
                              <span>Required:</span>
                              <span style="color: #fbbf24;">90%</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                              <span>Remaining:</span>
                              <span style="color: #ef4444;" id="recWatchRemaining">90%</span>
                            </div>
                            <div style="font-size: 10px; opacity: 0.7; margin-top: 4px;">
                              <i class="fas fa-info-circle"></i> Can seek up to: <span id="recMaxSeekTime" style="color: #10b981;">0:00</span>
                            </div>
                          </div>
                        </div>
                        <% } %>
                      </div>
                    <% } %>
                  </div>
                </div>


                <!-- Recording watch status based on attendance -->
                <% if (studentAttendedLiveMeeting) { %>
                <!-- Student attended live meeting - free playback, already completed -->
                <div class="recording-attended-badge mt-3" style="background: linear-gradient(135deg, #10b981, #059669); color: white; padding: 12px 16px; border-radius: 8px; display: flex; align-items: center; gap: 10px;">
                  <i class="fas fa-user-check" style="font-size: 1.3rem;"></i>
                  <div>
                    <strong>You attended this live session</strong>
                    <p style="margin: 0; font-size: 0.9rem; opacity: 0.9;">You can watch the recording freely without restrictions.</p>
                  </div>
                </div>
                <% } else if (!contentProgress.isCompleted) { %>
                <!-- Student didn't attend and hasn't completed - needs to watch 90% -->
                <div class="recording-watch-requirement mt-3" style="background: linear-gradient(135deg, #fef3c7, #fde68a); border: 1px solid #f59e0b; padding: 12px 16px; border-radius: 8px;">
                  <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                    <i class="fas fa-info-circle" style="color: #f59e0b; font-size: 1.3rem;"></i>
                    <strong style="color: #92400e;">Watch Requirement</strong>
                  </div>
                  <p style="margin: 0; color: #78350f; font-size: 0.9rem;">
                    Since you didn't attend the live session, you need to watch at least <strong>90%</strong> of this recording to complete it. Progress will be tracked automatically.
                  </p>
                  <!-- Watch Progress Indicator for non-attendees -->
                  <div id="recordingWatchProgress" class="mt-3" style="background: rgba(0,0,0,0.05); padding: 12px; border-radius: 6px; display: none;">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                      <span style="color: #78350f; font-weight: 600;">Watch Progress</span>
                      <span id="recordingWatchPercent" style="color: #f59e0b; font-weight: 700;">0%</span>
                    </div>
                    <div style="background: rgba(0,0,0,0.1); border-radius: 4px; height: 8px; overflow: hidden;">
                      <div id="recordingWatchBar" style="background: linear-gradient(90deg, #f59e0b, #10b981); height: 100%; width: 0%; transition: width 0.3s ease;"></div>
                    </div>
                    <p style="margin: 8px 0 0; font-size: 0.8rem; color: #92400e;">
                      Required: <strong>90%</strong> | <span id="recordingWatchRemaining">90% remaining</span>
                    </p>
                  </div>
                </div>
                <% } else { %>
                <!-- Student completed watching the recording - show completion status -->
                <div class="recording-completed-badge mt-3" style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(5, 150, 105, 0.05)); border: 1px solid rgba(16, 185, 129, 0.3); padding: 12px 16px; border-radius: 8px; display: flex; align-items: center; gap: 10px;">
                  <i class="fas fa-check-circle" style="color: #10b981; font-size: 1.3rem;"></i>
                  <div>
                    <strong style="color: #065f46;">Recording Completed</strong>
                    <p style="margin: 0; font-size: 0.9rem; color: #047857;">You can watch the recording freely.</p>
                  </div>
                </div>
                <% } %>
              </div>
              <% } else { %>
              <!-- Waiting for recording message -->
              <div class="recording-waiting mt-4" style="text-align: center; padding: 2rem; background: linear-gradient(135deg, #fef3c7, #fde68a); border: 1px solid #f59e0b; border-radius: 8px;">
                <div style="font-size: 3rem; color: #f59e0b; margin-bottom: 1rem;">
                  <i class="fas fa-clock"></i>
                </div>
                <h6 style="color: #92400e; font-weight: 600; margin-bottom: 0.5rem;">
                  <i class="fas fa-hourglass-half me-2"></i>Waiting for Recording
                </h6>
                <p class="text-muted" style="margin-bottom: 0;">
                  The instructor is preparing the recording. Once it's uploaded, you'll be able to watch it here.
                </p>
                <p class="text-muted mt-2" style="font-size: 0.9rem;">
                  <i class="fas fa-info-circle"></i> Please check back later or contact your instructor if you have questions.
                </p>
              </div>
              <% } %>
<% } %>

          </div>
          <% } else { %>
          <div class="alert alert-warning">
            <i class="fas fa-exclamation-triangle me-2"></i>
            Zoom meeting data is not available.
          </div>
          <% } %>
          <% } %>
        </div>

        <!-- Auto-completion status (no manual buttons) -->
        <% if (contentProgress.isCompleted) { %>
        <div class="content-auto-completion-section">
          <div class="auto-completion-status">
            <i class="fas fa-check-circle text-success"></i>
            <span>Content Completed</span>
            <% if (contentProgress.completedAt) { %>
            <small class="text-muted">on <%= new Date(contentProgress.completedAt).toLocaleDateString() %></small>
            <% } %>
          </div>
        </div>
        <% } %>

        <!-- Navigation Section -->
        <div class="content-navigation-section">
          <div class="navigation-container">
            <!-- Previous Content -->
            <% if (navigation.previousContent) { %>
            <a href="/student/content/<%= navigation.previousContent._id %>" class="nav-button nav-previous">
              <div class="nav-icon">
                <i class="fas fa-chevron-left"></i>
              </div>
              <div class="nav-content">
                <div class="nav-label">Previous</div>
                <div class="nav-title"><%= navigation.previousContent.title %></div>
              </div>
            </a>
            <% } else { %>
            <div class="nav-button nav-previous disabled">
              <div class="nav-icon">
                <i class="fas fa-chevron-left"></i>
              </div>
              <div class="nav-content">
                <div class="nav-label">Previous</div>
                <div class="nav-title">No previous content</div>
              </div>
            </div>
            <% } %>

            <!-- Progress Indicator -->
            <div class="nav-progress">
              <div class="progress-info">
                <span class="current-position"><%= navigation.currentIndex + 1 %></span>
                <span class="separator">of</span>
                <span class="total-content"><%= navigation.totalContent %></span>
              </div>
              <div class="progress-bar">
                <% const progressPercent = Math.round(((navigation.currentIndex + 1) / navigation.totalContent) * 100); %>
                <div class="progress-fill" data-width="<%= progressPercent %>"></div>
              </div>
            </div>

            <!-- Next Content -->
            <% if (navigation.nextContent) { %>
            <% if (navigation.nextContentAccessible) { %>
            <a href="/student/content/<%= navigation.nextContent._id %>" class="nav-button nav-next">
              <div class="nav-content">
                <div class="nav-label">Next</div>
                <div class="nav-title"><%= navigation.nextContent.title %></div>
              </div>
              <div class="nav-icon">
                <i class="fas fa-chevron-right"></i>
              </div>
            </a>
            <% } else { %>
            <div class="nav-button nav-next disabled">
              <div class="nav-content">
                <div class="nav-label">Next</div>
                <div class="nav-title"><%= navigation.nextContent.title %></div>
                <div class="nav-subtitle">Complete current content to unlock</div>
              </div>
              <div class="nav-icon">
                <i class="fas fa-lock"></i>
              </div>
            </div>
            <% } %>
            <% } else { %>
            <div class="nav-button nav-next disabled">
              <div class="nav-content">
                <div class="nav-label">Next</div>
                <div class="nav-title">No more content</div>
              </div>
              <div class="nav-icon">
                <i class="fas fa-flag-checkered"></i>
              </div>
            </div>
            <% } %>
          </div>
        </div>
      </div>
    </main>
  </div>

  <!-- PlayerJS Library -->
  <script src="https://assets.mediadelivery.net/playerjs/playerjs-latest.min.js"></script>

  <!-- YouTube IFrame Player API -->
  <script src="https://www.youtube.com/iframe_api"></script>

  <!-- SweetAlert2 Library -->
  <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>

  <!-- JavaScript -->
  <script>
    // Auto-complete content based on type and interaction
    function autoCompleteContent() {
      updateContentProgressSmooth('completed', 100);
    }

    // Update content progress - simplified function (kept for video tracking)
    function updateContentProgress(status, percentage) {
      const progressData = {
        completionStatus: status,
        progressPercentage: percentage,
        lastAccessed: new Date(),
        completedAt: status === 'completed' ? new Date() : null
      };

      fetch('/student/content/progress/update', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            courseId: '<%= course._id %>',
            topicId: '<%= topic._id %>',
            contentId: '<%= contentItem._id %>',
            contentType: '<%= contentItem.type %>',
            progressData: progressData
          })
        })
        .then(response => response.json())
        .then(data => {
          if (data.success) {
            // Show success message and reload
            showMessage('Progress updated successfully!', 'success');
            setTimeout(() => location.reload(), 1000);
          } else {
            showMessage('Error updating progress: ' + data.message, 'error');
          }
        })
        .catch(error => {
          // Error - silently handle
          showMessage('Error updating progress', 'error');
        });
    }

    // Helper function to disable all completion buttons
    function disableCompletionButtons() {
      // Find all completion-related buttons
      const buttons = document.querySelectorAll(
        'button[onclick*="acknowledgeAndComplete"], ' +
        'button[onclick*="joinZoomMeeting"], ' +
        '.btn-success, .btn-primary'
      );
      
      buttons.forEach(btn => {
        if (!btn.disabled && (btn.textContent.includes('Complete') || 
            btn.textContent.includes('Join') ||
            btn.textContent.includes('Acknowledge'))) {
          btn.dataset.originalText = btn.innerHTML;
          btn.disabled = true;
          btn.style.opacity = '0.6';
          btn.style.cursor = 'not-allowed';
          // Add loading spinner
          if (!btn.innerHTML.includes('fa-spinner')) {
            btn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Processing...';
          }
        }
      });
    }

    // Helper function to re-enable all completion buttons
    function enableCompletionButtons() {
      const buttons = document.querySelectorAll(
        'button[onclick*="acknowledgeAndComplete"], ' +
        'button[onclick*="joinZoomMeeting"], ' +
        '.btn-success, .btn-primary'
      );
      
      buttons.forEach(btn => {
        if (btn.dataset.originalText) {
          btn.innerHTML = btn.dataset.originalText;
          delete btn.dataset.originalText;
        }
        btn.disabled = false;
        btn.style.opacity = '1';
        btn.style.cursor = 'pointer';
      });
    }

    // Update content progress with watch data (for video tracking)
    function updateContentProgressWithWatchData(status, percentage, watchData) {
      // Disable all completion buttons immediately
      disableCompletionButtons();

      const progressData = {
        completionStatus: status,
        progressPercentage: percentage,
        lastAccessed: new Date(),
        completedAt: status === 'completed' ? new Date() : null,
        // Include watch tracking data for backend validation
        watchData: watchData
      };

      fetch('/student/content/progress/update', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            courseId: '<%= course._id %>',
            topicId: '<%= topic._id %>',
            contentId: '<%= contentItem._id %>',
            contentType: '<%= contentItem.type %>',
            progressData: progressData
          })
        })
        .then(response => response.json())
        .then(data => {
          if (data.success) {
            // Update UI elements smoothly without reload
            updateUIAfterCompletion();

            // For video content, update watch count display dynamically
            if ('<%= contentItem.type %>' === 'video' && data.watchCount !== undefined) {
              currentWatchCount = data.watchCount;
              currentMaxWatchCount = data.maxWatchCount;
              
              // Update watch limit info display if it exists
              const watchLimitAlert = document.querySelector('.alert');
              if (watchLimitAlert && data.maxWatchCount) {
                const watchesLeft = data.maxWatchCount - data.watchCount;
                if (watchesLeft <= 0) {
                  watchLimitAlert.className = 'alert alert-danger';
                  watchLimitAlert.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 12px;">
                      <i class="fas fa-eye" style="font-size: 1.5rem;"></i>
                      <div style="flex: 1;">
                        <strong style="display: block; margin-bottom: 4px;">Watch Limit Reached</strong>
                        <span>You have watched this video <strong>${data.watchCount}</strong> out of <strong>${data.maxWatchCount}</strong> allowed times.<br>You cannot watch this video again.</span>
                      </div>
                    </div>
                  `;
                  
                  // Reload page to show blocked state
                  setTimeout(() => {
                    location.reload();
                  }, 2000);
                } else {
                  const watchCountText = watchLimitAlert.querySelector('span');
                  if (watchCountText) {
                    watchCountText.innerHTML = `You have watched this video <strong>${data.watchCount}</strong> out of <strong>${data.maxWatchCount}</strong> allowed times.<br>Remaining watches: <strong>${watchesLeft}</strong>`;
                  }
                }
              }
            }

            showEnhancedNotification(
              'Content completed successfully! ',
              'success',
              'Progress Updated'
            );
          } else {
            // Handle error - especially watch limit errors
            if (data.limitReached) {
              showEnhancedNotification(
                data.message || 'Watch limit reached',
                'error',
                'Cannot Complete'
              );
              
              // Reload page to show blocked state
              setTimeout(() => {
                location.reload();
              }, 2000);
            } else if (data.message && data.message.includes('90%')) {
              // Backend validation failed - student didn't really watch 90%
              showEnhancedNotification(
                'You must watch at least 90% of the video to complete it. Skipping is not allowed.',
                'warning',
                'Insufficient Watch Time'
              );
            } else {
              showEnhancedNotification(
                data.message || 'Error updating progress',
                'error',
                'Update Failed'
              );
            }
            
            // Re-enable buttons on error
            enableCompletionButtons();
          }
        })
        .catch(error => {
          showEnhancedNotification(
            'Network error. Please check your connection.',
            'error',
            'Connection Error'
          );
          enableCompletionButtons();
        });
    }
    
    // Smooth update content progress - no page reload (for non-video content)
    function updateContentProgressSmooth(status, percentage) {
      // Disable all completion buttons immediately
      disableCompletionButtons();

      const progressData = {
        completionStatus: status,
        progressPercentage: percentage,
        lastAccessed: new Date(),
        completedAt: status === 'completed' ? new Date() : null
      };

      fetch('/student/content/progress/update', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            courseId: '<%= course._id %>',
            topicId: '<%= topic._id %>',
            contentId: '<%= contentItem._id %>',
            contentType: '<%= contentItem.type %>',
            progressData: progressData
          })
        })
        .then(response => response.json())
        .then(data => {
          if (data.success) {
            // Update UI elements smoothly without reload
            updateUIAfterCompletion();

            // For video content, update watch count display dynamically
            if ('<%= contentItem.type %>' === 'video' && data.contentProgress) {
              // Use watch limit info from response if available, otherwise use initial values
              let watchLimitInfo = data.watchLimitInfo;
              if (!watchLimitInfo) {
                const updatedWatchCount = data.contentProgress.watchCount || 0;
                const maxWatchCount = '<%= watchLimitInfo && watchLimitInfo.maxWatchCount ? watchLimitInfo.maxWatchCount : "null" %>';
                const hasLimit = maxWatchCount !== 'null' && maxWatchCount !== null && maxWatchCount !== '-1';
                watchLimitInfo = {
                  watchCount: updatedWatchCount,
                  maxWatchCount: hasLimit ? parseInt(maxWatchCount) : null,
                  hasLimit: hasLimit,
                  watchesLeft: hasLimit ? Math.max(0, parseInt(maxWatchCount) - updatedWatchCount) : null,
                  limitReached: hasLimit && updatedWatchCount >= parseInt(maxWatchCount),
                };
              }
              
              // Update watch count display
              if (watchLimitInfo.hasLimit) {
                // Update global variables first
                currentWatchCount = watchLimitInfo.watchCount;
                currentMaxWatchCount = watchLimitInfo.maxWatchCount;
                
                // Update UI display
                updateWatchCountDisplay(watchLimitInfo.watchCount, watchLimitInfo.maxWatchCount, true);
                
                // Show watch count message
                const remaining = watchLimitInfo.watchesLeft;
                let message = ` Video completed! You have watched this video <strong>${watchLimitInfo.watchCount}</strong> out of <strong>${watchLimitInfo.maxWatchCount}</strong> times.`;
                if (remaining > 0) {
                  message += ` <strong>Remaining: ${remaining} watch${remaining > 1 ? 'es' : ''}.</strong>`;
                } else {
                  message += ` <strong>No watches remaining.</strong>`;
                }
                showSmoothSuccessMessage(message);
              } else {
                showSmoothSuccessMessage(' Great! You\'ve watched enough of the video. Content marked as completed!');
              }
            } else {
              showSmoothSuccessMessage(' Great! You\'ve watched enough of the video. Content marked as completed!');
            }
            // Buttons stay disabled since content is completed
          } else {
            // Re-enable buttons on error
            enableCompletionButtons();
            showMessage('Error updating progress: ' + data.message, 'error');
          }
        })
        .catch(error => {
          // Error - silently handle
          // Re-enable buttons on error
          enableCompletionButtons();
          showMessage('Error updating progress', 'error');
        });
    }

    // Show message function - Enhanced with notification container
    function showMessage(message, type) {
      showEnhancedNotification(message, type === 'success' ? 'success' : 'error', 'Notification');
    }

    // Show smooth success message with animation - Enhanced
    function showSmoothSuccessMessage(message) {
      showEnhancedNotification(message, 'success', 'Content Completed!');
    }

    // Global variables to track watch count (will be updated dynamically)
    let currentWatchCount = <%= watchLimitInfo ? watchLimitInfo.watchCount : 0 %>;
    let currentMaxWatchCount = <%= watchLimitInfo && watchLimitInfo.maxWatchCount ? watchLimitInfo.maxWatchCount : 'null' %>;

    // Update watch count display dynamically
    function updateWatchCountDisplay(watchCount, maxWatchCount, hasLimit) {
      if (!hasLimit) return;
      
      // Update global variables
      currentWatchCount = parseInt(watchCount);
      currentMaxWatchCount = parseInt(maxWatchCount);
      
      const watchLimitAlert = document.querySelector('.alert.alert-info, .alert.alert-danger');
      if (watchLimitAlert) {
        const maxCount = parseInt(maxWatchCount);
        const currentCount = parseInt(watchCount);
        const remaining = maxCount - currentCount;
        const limitReached = currentCount >= maxCount;
        
        // Update alert class
        watchLimitAlert.className = limitReached ? 'alert alert-danger' : 'alert alert-info';
        
        // Update content
        const strongElement = watchLimitAlert.querySelector('strong');
        const spanElement = watchLimitAlert.querySelector('span');
        
        if (strongElement) {
          strongElement.textContent = limitReached ? 'Watch Limit Reached' : 'Watch Limit Information';
        }
        
        if (spanElement) {
          spanElement.innerHTML = `
            You have watched this video <strong>${currentCount}</strong> out of <strong>${maxCount}</strong> allowed times.
            ${!limitReached ? `<br>Remaining watches: <strong>${remaining}</strong>` : '<br>You cannot watch this video again.'}
          `;
        }
      }
    }

    // Update UI elements after completion
    function updateUIAfterCompletion() {
      // Update progress circle
      const progressCircle = document.querySelector('.circle-large');
      const progressPercentage = document.querySelector('.progress-percentage');
      const progressLabel = document.querySelector('.progress-label');

      if (progressCircle) {
        progressCircle.style.strokeDasharray = '314, 314'; // 100% complete
        progressCircle.style.transition = 'stroke-dasharray 0.8s ease-in-out';
      }

      if (progressPercentage) {
        progressPercentage.textContent = '100%';
        progressPercentage.style.transition = 'all 0.5s ease-in-out';
      }

      if (progressLabel) {
        progressLabel.textContent = 'Complete';
      }

      // Update content actions section
      const contentActions = document.querySelector('.content-actions');
      if (contentActions) {
        contentActions.innerHTML = `
                    <div class="completion-status">
                        <i class="fas fa-check-circle text-success"></i>
                        <span>Content Completed</span>
                        <small class="text-muted">just now</small>
                    </div>
                `;
        contentActions.style.transition = 'all 0.5s ease-in-out';
      }

      // Update navigation section - enable next content button
      try {
        const nextNavButton = document.querySelector('.nav-button.nav-next');
        if (nextNavButton && nextNavButton.classList && nextNavButton.classList.contains('disabled')) {
          // Get the next content ID from the current page data
          const nextContentId = '<%= navigation.nextContent ? navigation.nextContent._id : "" %>';

          if (nextContentId) {
            // Create a new anchor element to replace the disabled div
            const newLink = document.createElement('a');
            newLink.href = '/student/content/' + nextContentId;
            newLink.className = 'nav-button nav-next enabled';
            newLink.style.transition = 'all 0.3s ease-in-out';

            // Copy the content from the disabled button
            newLink.innerHTML = nextNavButton.innerHTML;

            // Update the icon from lock to chevron-right
            const navIcon = newLink.querySelector('.nav-icon i');
            if (navIcon) {
              navIcon.className = 'fas fa-chevron-right';
            }

            // Remove the subtitle about completing current content
            const navSubtitle = newLink.querySelector('.nav-subtitle');
            if (navSubtitle) {
              navSubtitle.remove();
            }

            // Replace the disabled div with the new link
            if (nextNavButton.parentNode) {
              nextNavButton.parentNode.replaceChild(newLink, nextNavButton);
            }

            // Remove the enabled animation class after animation completes
            setTimeout(() => {
              if (newLink.classList) {
                newLink.classList.remove('enabled');
              }
            }, 600);
          }
        }
      } catch (navError) {
        // Could not update navigation - silently handle
        // Don't fail the completion update if navigation update fails
      }
    }

    // Start Quiz/Homework with SweetAlert2 confirmation
    function startQuiz(contentId, contentType) {
      // Disable all quiz start buttons immediately to prevent multiple clicks
      const quizButtons = document.querySelectorAll('button[onclick*="startQuiz"]');
      quizButtons.forEach(btn => {
        if (!btn.disabled) {
          btn.dataset.originalText = btn.innerHTML;
          btn.disabled = true;
          btn.style.opacity = '0.6';
          btn.style.cursor = 'not-allowed';
        }
      });

      const quizType = contentType === 'quiz' ? 'Quiz' : 'Homework';

      Swal.fire({
        title: `Start ${quizType}?`,
        html: `
          <div style="text-align: left; margin: 20px 0;">
            <p style="margin-bottom: 15px; color: #6b7280; font-size: 16px;">
              Are you sure you want to start this ${quizType.toLowerCase()}?
            </p>
            <div style="background: #fef3c7; border: 1px solid #f59e0b; border-radius: 8px; padding: 12px; margin: 15px 0;">
              <div style="display: flex; align-items: center; gap: 8px;">
                <i class="fas fa-exclamation-triangle" style="color: #f59e0b; font-size: 18px;"></i>
                <strong style="color: #92400e;">Important:</strong>
              </div>
              <p style="margin: 8px 0 0 0; color: #92400e; font-size: 14px;">
                Once you start, the timer will begin (if applicable) and you'll need to complete all questions.
              </p>
            </div>
          </div>
        `,
        icon: 'question',
        showCancelButton: true,
        confirmButtonColor: '#dc2626',
        cancelButtonColor: '#6b7280',
        confirmButtonText: `<i class="fas fa-play"></i> Start ${quizType}`,
        cancelButtonText: '<i class="fas fa-times"></i> Cancel',
        reverseButtons: true,
        focusCancel: false,
        allowOutsideClick: true,
        allowEscapeKey: true,
        showCloseButton: true,
        customClass: {
          popup: 'swal2-popup-custom',
          title: 'swal2-title-custom',
          content: 'swal2-content-custom',
          confirmButton: 'swal2-confirm-custom',
          cancelButton: 'swal2-cancel-custom'
        }
      }).then((result) => {
        if (result.isConfirmed) {
          confirmStartQuiz(contentId, quizType);
        } else {
          // User cancelled - re-enable buttons
          const quizButtons = document.querySelectorAll('button[onclick*="startQuiz"]');
          quizButtons.forEach(btn => {
            if (btn.dataset.originalText) {
              btn.innerHTML = btn.dataset.originalText;
              delete btn.dataset.originalText;
            }
            btn.disabled = false;
            btn.style.opacity = '1';
            btn.style.cursor = 'pointer';
          });
        }
      });
    }

    function confirmStartQuiz(contentId, quizType) {
      const isQuiz = quizType.toLowerCase() === 'quiz';
      const icon = isQuiz ? 'fa-question-circle' : 'fa-tasks';
      showEnhancedNotification(
        `Opening ${quizType.toLowerCase()}... Get ready!`,
        'info',
        `${quizType} Starting`
      );
      setTimeout(() => {
        window.location.href = '/student/content/' + contentId + '/take';
      }, 1000);
    }

    // Toast notification function - Enhanced
    function showToast(message, type = 'success') {
      const title = type === 'success' ? 'Success' : 'Error';
      showEnhancedNotification(message, type, title);
    }

    // Enhanced notification function - Unified notification system
    function showEnhancedNotification(message, type = 'success', title = 'Notification', customDuration = null) {
      const container = document.getElementById('notification-container');
      if (!container) {
        // Notification container not found - silently handle
        return;
      }

      // Determine icon based on type
      let iconClass = 'fa-check-circle';
      if (type === 'error') iconClass = 'fa-exclamation-circle';
      else if (type === 'warning') iconClass = 'fa-exclamation-triangle';
      else if (type === 'info') iconClass = 'fa-info-circle';

      // Create notification element with proper line breaks
      const formattedMessage = message.replace(/\n/g, '<br>');
      
      const notification = document.createElement('div');
      notification.className = `enhanced-notification ${type}`;
      notification.innerHTML = `
        <div class="enhanced-notification-icon">
          <i class="fas ${iconClass}"></i>
        </div>
        <div class="enhanced-notification-content">
          <div class="enhanced-notification-title">${title}</div>
          <div class="enhanced-notification-message">${formattedMessage}</div>
        </div>
        <button class="enhanced-notification-close" aria-label="Close">
          <i class="fas fa-times"></i>
        </button>
      `;

      // Add close button event listener
      const closeBtn = notification.querySelector('.enhanced-notification-close');
      closeBtn.addEventListener('click', () => {
        notification.classList.add('hide');
        setTimeout(() => {
          if (notification.parentNode) {
            notification.remove();
          }
        }, 300);
      });

      // Add to container
      container.appendChild(notification);

      // Trigger animation
      setTimeout(() => {
        notification.classList.add('show');
      }, 10);

      // Auto remove after specified duration or default
      const duration = customDuration || (type === 'success' && title === 'Success' ? 3000 : 5000);
      setTimeout(() => {
        notification.classList.add('hide');
        setTimeout(() => {
          if (notification.parentNode) {
            notification.remove();
          }
        }, 300);
      }, duration);
    }


    // Auto-completion handlers
    let readingCompleted = false;
    let pdfCompleted = false;

    function handleReadingScroll(element) {
      if (readingCompleted) return;

      const scrollTop = element.scrollTop;
      const scrollHeight = element.scrollHeight;
      const clientHeight = element.clientHeight;
      const scrollPercentage = (scrollTop + clientHeight) / scrollHeight * 100;

      // Auto-complete when user scrolls 80% of the content
      if (scrollPercentage >= 80) {
        readingCompleted = true;
        updateContentProgressSmooth('completed', 100);
      }
    }

    function handlePDFLoad(iframe) {
      if (pdfCompleted) return;

      // Auto-complete PDF after 30 seconds of viewing
      setTimeout(() => {
        if (!pdfCompleted) {
          pdfCompleted = true;
          updateContentProgressSmooth('completed', 100);
        }
      }, 30000);
    }

    // Initialize progress bar width and check for URL parameters
    document.addEventListener('DOMContentLoaded', function() {
      const progressFill = document.querySelector('.progress-fill[data-width]');
      if (progressFill) {
        const width = progressFill.getAttribute('data-width');
        progressFill.style.width = width + '%';
      }

      // Check URL parameters for notifications
      const urlParams = new URLSearchParams(window.location.search);
      
      // Show notification if content was just completed
      if (urlParams.get('completed') === 'true') {
        showEnhancedNotification(
          'Great job! Your progress has been saved.',
          'success',
          'Content Completed!'
        );
        // Clean URL
        window.history.replaceState({}, document.title, window.location.pathname);
      }

      // Show notification if quiz/HW was just started
      if (urlParams.get('quizStarted') === 'true') {
        const contentType = urlParams.get('type') || 'quiz';
        const typeName = contentType === 'quiz' ? 'Quiz' : 'Homework';
        showEnhancedNotification(
          `${typeName} is now open. Good luck!`,
          'info',
          `${typeName} Started`
        );
        // Clean URL
        window.history.replaceState({}, document.title, window.location.pathname);
      }
    });

    // ==================== WATERMARK INITIALIZATION ====================
    function initializeVideoWatermark() {
      console.log(' Initializing video watermarks...');
      
      // List of watermark configurations
      const configs = [
        { wrapperId: 'bunny-video-wrapper', watermarkId: 'bunnyWatermark' },
        { wrapperId: 'youtube-video-wrapper', watermarkId: 'youtubeWatermark' },
        { wrapperId: 'recording-video-wrapper', watermarkId: 'recordingYoutubeWatermark' },
        { wrapperId: 'recording-video-wrapper', watermarkId: 'recordingBunnyWatermark' }
      ];

      configs.forEach(config => {
        const wrapper = document.getElementById(config.wrapperId);
        const watermark = document.getElementById(config.watermarkId);
        
        if (wrapper && watermark) {
          console.log(' Found:', config.watermarkId);
          
          // For Bunny videos, move watermark to video container
          if (config.watermarkId === 'bunnyWatermark') {
            const videoContainer = wrapper.querySelector('div[style*="padding-top"]');
            if (videoContainer) {
              videoContainer.style.position = 'relative';
              if (watermark.parentElement !== videoContainer) {
                videoContainer.appendChild(watermark);
              }
            }
          }
          
          // Setup fullscreen handling
          setupFullscreenWatermark(wrapper, watermark);
        }
      });
      
      console.log(' Watermark initialization complete');
    }


    // Setup fullscreen watermark handling - IMPROVED APPROACH
    // SIMPLE FULLSCREEN WATERMARK - REBUILT FROM SCRATCH
    function setupFullscreenWatermark(wrapper, watermark) {
      if (!wrapper || !watermark) return;

      // Store watermark info
      const watermarkText = watermark.textContent || watermark.innerText;
      const watermarkId = watermark.id;
      
      console.log(' Initializing watermark for:', watermarkId, '- Text:', watermarkText);

      // Create persistent fullscreen watermark element (hidden by default)
      const fsWatermark = document.createElement('div');
      fsWatermark.id = watermarkId + '-fs';
      fsWatermark.className = 'video-watermark video-watermark-moving';
      fsWatermark.innerHTML = watermark.innerHTML;
      fsWatermark.style.cssText = `
        position: fixed;
        top: 8%;
        left: 8%;
        z-index: 2147483647;
        display: none;
        align-items: center;
        gap: 6px;
        background: rgba(0, 0, 0, 0.75);
        color: #ffffff;
        padding: 10px 20px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 500;
        border: 1px solid rgba(255, 255, 255, 0.2);
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
        opacity: 0.85;
        pointer-events: none;
        user-select: none;
        -webkit-user-select: none;
        animation: watermarkMove 25s linear infinite;
        -webkit-animation: watermarkMove 25s linear infinite;
      `;
      document.body.appendChild(fsWatermark);
      console.log(' Fullscreen watermark element created');

      // Fullscreen change handler
      function onFullscreenChange() {
        const isFullscreen = !!(document.fullscreenElement || 
                               document.webkitFullscreenElement || 
                               document.mozFullScreenElement || 
                               document.msFullscreenElement);
        
        console.log(' Fullscreen state:', isFullscreen);
        
        if (isFullscreen) {
          // Hide original, show fullscreen watermark
          watermark.style.display = 'none';
          fsWatermark.style.display = 'inline-flex';
          console.log(' Fullscreen watermark shown');
        } else {
          // Show original, hide fullscreen watermark
          watermark.style.display = 'inline-flex';
          fsWatermark.style.display = 'none';
          console.log(' Normal watermark shown');
        }
      }

      // Add event listeners
      ['fullscreenchange', 'webkitfullscreenchange', 'mozfullscreenchange', 'MSFullscreenChange'].forEach(event => {
        document.addEventListener(event, onFullscreenChange);
      });

      // Ensure iframe can go fullscreen
      const iframe = wrapper.querySelector('iframe');
      if (iframe) {
        iframe.setAttribute('allowfullscreen', '');
        iframe.setAttribute('webkitallowfullscreen', '');
        iframe.setAttribute('mozallowfullscreen', '');
      }

      // Monitor and ensure watermark stays visible in fullscreen
      setInterval(() => {
        const isFullscreen = !!(document.fullscreenElement || 
                               document.webkitFullscreenElement || 
                               document.mozFullScreenElement || 
                               document.msFullscreenElement);
        
        if (isFullscreen && fsWatermark.style.display === 'none') {
          fsWatermark.style.display = 'inline-flex';
          console.log(' Restored fullscreen watermark');
        }
      }, 1000);

      console.log(' Setup complete for:', watermarkId);
    }

    // Helper function to request fullscreen on wrapper (keep for custom button)

    // Watermark protection - simplified
    function protectWatermark() {
      const watermarkIds = [
        'bunnyWatermark',
        'youtubeWatermark',
        'recordingYoutubeWatermark',
        'recordingBunnyWatermark'
      ];

      setInterval(() => {
        const isFullscreen = !!(document.fullscreenElement || 
                               document.webkitFullscreenElement || 
                               document.mozFullScreenElement || 
                               document.msFullscreenElement);
        
        watermarkIds.forEach(id => {
          const watermark = document.getElementById(id);
          const fsWatermark = document.getElementById(id + '-fs');
          
          if (watermark && fsWatermark) {
            if (isFullscreen) {
              // Ensure fullscreen watermark is visible
              if (fsWatermark.style.display !== 'inline-flex') {
                fsWatermark.style.display = 'inline-flex';
                console.log(' Restored fullscreen watermark:', id);
              }
              if (watermark.style.display !== 'none') {
                watermark.style.display = 'none';
              }
            } else {
              // Ensure normal watermark is visible
              if (watermark.style.display !== 'inline-flex') {
                watermark.style.display = 'inline-flex';
                console.log(' Restored normal watermark:', id);
              }
              if (fsWatermark.style.display !== 'none') {
                fsWatermark.style.display = 'none';
              }
            }
          }
        });
      }, 1000); // Check every second
    }

    // Initialize watermarks when DOM is ready
    document.addEventListener('DOMContentLoaded', function() {
      initializeVideoWatermark();
      
      // Start watermark protection after initialization
      setTimeout(protectWatermark, 2000);
      
      // Prevent context menu on video wrappers and watermarks
      const videoWrappers = [
        'bunny-video-wrapper',
        'youtube-video-wrapper',
        'recording-video-wrapper'
      ];
      
      videoWrappers.forEach(wrapperId => {
        const wrapper = document.getElementById(wrapperId);
        if (wrapper) {
          wrapper.addEventListener('contextmenu', function(e) {
            e.preventDefault();
            return false;
          });
          
          // Also prevent on iframe
          const iframe = wrapper.querySelector('iframe');
          if (iframe) {
            iframe.addEventListener('contextmenu', function(e) {
              e.preventDefault();
              return false;
            });
          }
        }
      });
      
      // Prevent context menu on watermarks
      const watermarkIds = [
        'bunnyWatermark',
        'youtubeWatermark',
        'recordingYoutubeWatermark',
        'recordingBunnyWatermark'
      ];
      
      watermarkIds.forEach(id => {
        const watermark = document.getElementById(id);
        if (watermark) {
          watermark.addEventListener('contextmenu', function(e) {
            e.preventDefault();
            return false;
          });
        }
      });
    });

    // Re-initialize after dynamic content loads
    setTimeout(initializeVideoWatermark, 1000);

    // PlayerJS Video Tracking
    document.addEventListener('DOMContentLoaded', function() {
      // Check if this is a video content that needs tracking
      const isVideoContent = '<%= contentItem.type %>' === 'video';
      const hasVideoContent = '<%= contentItem.content ? "true" : "false" %>' === 'true';
      const isAlreadyCompleted = '<%= contentProgress.isCompleted ? "true" : "false" %>' === 'true';
      
      // Video watch limit info - use global variables that can be updated
      const watchLimitReached = <%= watchLimitInfo && watchLimitInfo.limitReached ? 'true' : 'false' %>;
      const hasWatchLimit = <%= watchLimitInfo && watchLimitInfo.hasLimit ? 'true' : 'false' %>;
      // Use global variables for watch count (will be updated dynamically)
      // watchCount and maxWatchCount are defined globally above

      // Initialize player for videos - even if already completed (to track watch count)
      // Only skip if watch limit is reached
      if (isVideoContent && hasVideoContent && !watchLimitReached) {
        let player = null;
        let videoDuration = 0;
        let playerReady = false;
        let autoCompleted = false;
        
        // ==================== ANTI-SKIP TRACKING SYSTEM ====================
        // Track which segments of the video have been actually watched
        let watchedSegments = []; // Array of {start, end} objects
        let lastTrackedTime = 0;
        let isPlaying = false;
        const REQUIRED_WATCH_PERCENTAGE = 90; // Must watch 90% of video
        const SEGMENT_TOLERANCE = 3; // Allow 3 second jumps without considering it a skip (increased for mobile)
        const MAX_SEGMENT_LENGTH = 10; // Allow segments up to 10 seconds (increased for mobile compatibility)
        const MAX_UPDATE_GAP = 5000; // Allow 5 second gaps between updates (increased for mobile)
        let skipAlertShown = false; // Track if we've shown the skip alert
        let progressIndicatorVisible = false;
        let maxWatchedTime = 0; // Track the furthest point watched
        let isSeeking = false; // Track if currently seeking to prevent loops
        let lastSkipAlertTime = 0; // Prevent alert spam
        let wasPlayingBeforeSeek = false; // Track if was playing before seek
        let lastUpdateTime = Date.now(); // Track last update timestamp
        
        // LocalStorage key for this specific video
        const videoStorageKey = 'video_progress_<%= contentItem._id %>';
        
        // Load saved progress from localStorage
        function loadSavedProgress() {
          try {
            const saved = localStorage.getItem(videoStorageKey);
            if (saved) {
              const data = JSON.parse(saved);
              console.log(' Loading saved progress:', data);
              
              watchedSegments = data.segments || [];
              maxWatchedTime = data.maxWatchedTime || 0;
              
              return data.lastPosition || 0;
            }
          } catch (e) {
            console.error('Error loading saved progress:', e);
          }
          return 0;
        }
        
        // Save progress to localStorage
        function saveProgressToStorage() {
          try {
            const data = {
              segments: watchedSegments,
              maxWatchedTime: maxWatchedTime,
              lastPosition: lastTrackedTime,
              timestamp: Date.now()
            };
            localStorage.setItem(videoStorageKey, JSON.stringify(data));
          } catch (e) {
            console.error('Error saving progress:', e);
          }
        }
        
        // Clear saved progress (called on completion)
        function clearSavedProgress() {
          try {
            localStorage.removeItem(videoStorageKey);
            console.log(' Cleared saved progress for this video');
          } catch (e) {
            console.error('Error clearing progress:', e);
          }
        }
        
        // Function to add a watched segment (prevents counting same time twice)
        function addWatchedSegment(start, end) {
          if (end <= start) return;
          
          // Don't allow segments beyond video duration
          if (videoDuration > 0) {
            start = Math.max(0, Math.min(start, videoDuration));
            end = Math.max(0, Math.min(end, videoDuration));
          }
          
          // CRITICAL: Only update maxWatchedTime if this is continuous playback
          // Check BOTH start and end against maxWatchedTime
          const startDiff = start - maxWatchedTime;
          const segmentLength = end - start;
          
          console.log(' addWatchedSegment:', {
            start: start.toFixed(2),
            end: end.toFixed(2),
            currentMax: maxWatchedTime.toFixed(2),
            startDiff: startDiff.toFixed(2),
            segmentLength: segmentLength.toFixed(2),
            tolerance: SEGMENT_TOLERANCE
          });
          
          // REJECT if segment length is too large (indicates a jump, not playback)
          // Increased threshold for mobile compatibility where timeupdate events can be irregular
          if (segmentLength > MAX_SEGMENT_LENGTH) {
            console.log(' SEGMENT TOO LARGE: Rejected (length:', segmentLength.toFixed(2), 's, max:', MAX_SEGMENT_LENGTH, 's)');
            return; // Don't add this segment at all!
          }
          
          if (maxWatchedTime === 0 || (startDiff >= -SEGMENT_TOLERANCE && startDiff <= SEGMENT_TOLERANCE)) {
            // Continuous from current max, or first segment - OK to update
            const oldMax = maxWatchedTime;
            maxWatchedTime = Math.max(maxWatchedTime, end);
            console.log(' Continuous playback: maxWatchedTime', oldMax.toFixed(2), '', maxWatchedTime.toFixed(2));
          } else if (start <= maxWatchedTime && end <= maxWatchedTime + SEGMENT_TOLERANCE) {
            // Re-watching earlier content within bounds
            if (end > maxWatchedTime) {
              const oldMax = maxWatchedTime;
              maxWatchedTime = end;
              console.log(' Re-watch extended: maxWatchedTime', oldMax.toFixed(2), '', maxWatchedTime.toFixed(2));
            } else {
              console.log(' Re-watch (no extension): maxWatchedTime stays', maxWatchedTime.toFixed(2));
            }
          } else {
            console.log(' GAP DETECTED: Segment rejected (startDiff:', startDiff.toFixed(2), 's)');
            return; // Don't add this segment!
          }
          
          // Merge with existing segments
          watchedSegments.push({start: start, end: end});
          watchedSegments = mergeSegments(watchedSegments);
        }
        
        // Check if a time position has been watched
        function isTimeWatched(time) {
          for (const segment of watchedSegments) {
            if (time >= segment.start && time <= segment.end) {
              return true;
            }
          }
          return false;
        }
        
        // Get the furthest continuous watched time from start
        function getMaxAllowedSeekTime() {
          // Validate maxWatchedTime against actual segments
          // Find the actual furthest point that's continuously watched from start
          let continuousMax = 0;
          
          if (watchedSegments.length === 0) {
            return 0;
          }
          
          // Sort segments
          const sorted = [...watchedSegments].sort((a, b) => a.start - b.start);
          
          // Find continuous progress from 0
          for (const segment of sorted) {
            if (segment.start <= continuousMax + SEGMENT_TOLERANCE) {
              continuousMax = Math.max(continuousMax, segment.end);
            } else {
              // Gap found, stop here
              break;
            }
          }
          
          // Use the minimum of calculated continuous max and stored max
          // This prevents maxWatchedTime from being incorrectly inflated
          const validMax = Math.min(continuousMax, maxWatchedTime);
          
          // Update maxWatchedTime to the valid value
          if (validMax < maxWatchedTime) {
            console.log(' Correcting maxWatchedTime from', maxWatchedTime.toFixed(2), 'to', validMax.toFixed(2));
            maxWatchedTime = validMax;
          }
          
          return maxWatchedTime;
        }
        
        // Merge overlapping segments (prevents double counting)
        function mergeSegments(segments) {
          if (segments.length === 0) return [];
          
          // Sort by start time
          segments.sort((a, b) => a.start - b.start);
          
          const merged = [segments[0]];
          
          for (let i = 1; i < segments.length; i++) {
            const current = segments[i];
            const last = merged[merged.length - 1];
            
            // If segments overlap or are adjacent, merge them
            // This prevents counting the same time period twice
            if (current.start <= last.end + 0.5) {
              // Only extend if current segment goes beyond last
              last.end = Math.max(last.end, current.end);
            } else {
              merged.push(current);
            }
          }
          
          return merged;
        }
        
        // Calculate total watched time (in seconds) - capped at video duration
        function getTotalWatchedTime() {
          let total = 0;
          for (const segment of watchedSegments) {
            total += (segment.end - segment.start);
          }
          // Cap at video duration to prevent over 100%
          if (videoDuration > 0) {
            total = Math.min(total, videoDuration);
          }
          return total;
        }
        
        // Calculate watch percentage (capped at 100%)
        function getWatchPercentage() {
          if (videoDuration <= 0) return 0;
          const percentage = (getTotalWatchedTime() / videoDuration) * 100;
          return Math.min(percentage, 100); // Cap at 100%
        }
        
        // Format seconds to MM:SS
        function formatTime(seconds) {
          const mins = Math.floor(seconds / 60);
          const secs = Math.floor(seconds % 60);
          return `${mins}:${secs.toString().padStart(2, '0')}`;
        }
        
        // Update progress indicator UI
        function updateProgressIndicator() {
          const progressDiv = document.getElementById('videoWatchProgress');
          if (!progressDiv) return;
          
          // Show indicator when video starts playing
          if (!progressIndicatorVisible && isPlaying) {
            progressDiv.style.display = 'block';
            progressIndicatorVisible = true;
          }
          
          const watchPercentage = getWatchPercentage();
          const totalWatched = getTotalWatchedTime();
          const remaining = Math.max(0, REQUIRED_WATCH_PERCENTAGE - watchPercentage);
          
          // Update percentage text
          const percentElem = document.getElementById('watchProgressPercent');
          if (percentElem) {
            percentElem.textContent = watchPercentage.toFixed(1) + '%';
            // Change color based on progress
            if (watchPercentage >= REQUIRED_WATCH_PERCENTAGE) {
              percentElem.style.color = '#10b981'; // Green
            } else if (watchPercentage >= 60) {
              percentElem.style.color = '#fbbf24'; // Yellow
            } else {
              percentElem.style.color = '#ef4444'; // Red
            }
          }
          
          // Update time text
          const timeElem = document.getElementById('watchProgressTime');
          if (timeElem) {
            timeElem.textContent = `${formatTime(totalWatched)} / ${formatTime(videoDuration)}`;
          }
          
          // Update circular progress
          const circleElem = document.getElementById('watchProgressCircle');
          if (circleElem) {
            const circumference = 125.6; // 2 * PI * 20
            const offset = circumference - (watchPercentage / 100 * circumference);
            circleElem.style.strokeDashoffset = offset;
            
            // Change circle color
            if (watchPercentage >= REQUIRED_WATCH_PERCENTAGE) {
              circleElem.style.stroke = '#10b981';
            } else if (watchPercentage >= 60) {
              circleElem.style.stroke = '#fbbf24';
            } else {
              circleElem.style.stroke = '#ef4444';
            }
          }
          
          // Update circle text
          const circleTextElem = document.getElementById('watchProgressCircleText');
          if (circleTextElem) {
            circleTextElem.textContent = Math.floor(watchPercentage) + '%';
          }
          
          // Update remaining percentage
          const remainingElem = document.getElementById('watchProgressRemaining');
          if (remainingElem) {
            if (remaining <= 0) {
              remainingElem.textContent = ' Done';
              remainingElem.style.color = '#10b981';
            } else {
              remainingElem.textContent = remaining.toFixed(1) + '%';
            }
          }
          
          // Update max seek time
          const maxSeekElem = document.getElementById('maxSeekTime');
          if (maxSeekElem) {
            const maxTime = Math.max(maxWatchedTime, 0);
            maxSeekElem.textContent = formatTime(maxTime);
            // Change color based on progress
            if (maxTime >= videoDuration * 0.9) {
              maxSeekElem.style.color = '#10b981'; // Green
            } else if (maxTime >= videoDuration * 0.5) {
              maxSeekElem.style.color = '#fbbf24'; // Yellow
            } else {
              maxSeekElem.style.color = '#ef4444'; // Red
            }
          }
        }
        
        // Show skip alert (with debounce to prevent spam)
        function showSkipAlert(targetTime, maxAllowed) {
          const now = Date.now();
          // Only show alert once every 3 seconds
          if (now - lastSkipAlertTime < 3000) {
            return;
          }
          lastSkipAlertTime = now;
          
          const formatTime = (seconds) => {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
          };
          
          showEnhancedNotification(
            ` Cannot Skip to Unwatched Content!\n\nYou tried to jump to ${formatTime(targetTime)}, but you've only watched up to ${formatTime(maxAllowed)}.\n\n You can seek within watched segments\n You cannot skip to unwatched parts\n\nWatch the video continuously to unlock more content.`,
            'error',
            'Skip Prevented',
            5000
          );
        }
        
        // Check if video completion criteria is met
        function checkVideoCompletion() {
          const watchPercentage = getWatchPercentage();
          const totalWatched = getTotalWatchedTime();
          
          // Debug logging
          console.log(` Video Progress Check:`, {
            watchPercentage: watchPercentage.toFixed(2) + '%',
            totalWatched: totalWatched.toFixed(2) + 's',
            videoDuration: videoDuration.toFixed(2) + 's',
            required: REQUIRED_WATCH_PERCENTAGE + '%',
            autoCompleted: autoCompleted
          });

          if (watchPercentage >= REQUIRED_WATCH_PERCENTAGE && !autoCompleted) {
            autoCompleted = true;
            
            console.log(' Video completion triggered! Sending to backend...');
            
            // Clear saved progress since video is completed
            clearSavedProgress();

            // Show success notification
            showEnhancedNotification(
              ` Congratulations!\n\nYou've watched ${watchPercentage.toFixed(1)}% of the video.\n\nMarking as completed...`,
              'success',
              'Video Completed!',
              4000
            );

            // Show watch limit warning if this is the last allowed watch
            if (hasWatchLimit && currentMaxWatchCount !== null && currentWatchCount + 1 >= currentMaxWatchCount) {
              setTimeout(() => {
                showEnhancedNotification(
                  `This was your final allowed watch of this video (${currentWatchCount + 1}/${currentMaxWatchCount}). You won't be able to watch it again.`,
                  'warning',
                  'Final Watch Warning'
                );
              }, 2000);
            }

            // Send watched segments data to backend for validation
            updateContentProgressWithWatchData('completed', 100, {
              watchedSegments: watchedSegments,
              totalWatchedTime: totalWatched,
              videoDuration: videoDuration,
              watchPercentage: watchPercentage
            });
          }
        }

        // Check if playerjs is loaded
        function checkPlayerJS() {
          if (typeof playerjs === 'undefined') {
            setTimeout(checkPlayerJS, 100);
            return;
          }
          initPlayer();
        }

        // Initialize player
        function initPlayer() {
          try {
            // Look for any iframe in the video container
            const videoContainer = document.querySelector('.video-container');
            const iframe = videoContainer ? videoContainer.querySelector('iframe') : null;

            if (!iframe) {
              return;
            }

            // Add an ID to the iframe if it doesn't have one
            if (!iframe.id) {
              iframe.id = 'bunny-video-' + Date.now();
            }

            player = new playerjs.Player(iframe.id);

            player.on("ready", () => {
              playerReady = true;

              // Get duration once
              player.getDuration((dur) => {
                videoDuration = dur;
                
                // Load saved progress
                const savedPosition = loadSavedProgress();
                
                if (savedPosition > 0 && savedPosition < dur) {
                  // Restore to saved position
                  console.log(' Restoring to saved position:', savedPosition.toFixed(2));
                  lastTrackedTime = savedPosition;
                  
                  // Show notification
                  showEnhancedNotification(
                    `Resuming from ${formatTime(savedPosition)}`,
                    'info',
                    'Progress Restored',
                    3000
                  );
                  
                  // Set player to saved position
                  try {
                    player.setCurrentTime(savedPosition);
                  } catch (e) {
                    console.error('Error setting saved position:', e);
                  }
                } else {
                  lastTrackedTime = 0;
                }
              });
            });
            
            // Listen for seeking event (before seek completes)
            player.on("seeking", () => {
              console.log(' Seeking started');
              wasPlayingBeforeSeek = isPlaying;
              isSeeking = true; // Mark as seeking immediately
              
              player.getCurrentTime((currentTime) => {
                const maxAllowed = getMaxAllowedSeekTime();
                
                if (currentTime > maxAllowed + SEGMENT_TOLERANCE) {
                  console.log(' Seeking blocked:', currentTime.toFixed(2), '', maxAllowed.toFixed(2));
                  
                  player.setCurrentTime(maxAllowed);
                  lastTrackedTime = maxAllowed;
                }
              });
            });
            
            // Listen for seeked event (after seek completes)
            player.on("seeked", () => {
              console.log(' Seeked completed');
              
              player.getCurrentTime((currentTime) => {
                const maxAllowed = getMaxAllowedSeekTime();
                
                if (currentTime > maxAllowed + SEGMENT_TOLERANCE) {
                  console.log(' Seeked blocked:', currentTime.toFixed(2), '', maxAllowed.toFixed(2));
                  showSkipAlert(currentTime, maxAllowed);
                  
                  player.setCurrentTime(maxAllowed);
                  lastTrackedTime = maxAllowed;
                } else {
                  // Valid seek position, update tracking
                  lastTrackedTime = currentTime;
                }
                
                // Clear seeking flag after a delay
                setTimeout(() => {
                  isSeeking = false;
                  console.log(' Seeking flag cleared');
                }, 1000); // Longer delay to ensure timeupdate doesn't count seek as playback
              });
            });

            // Track play/pause state
            player.on("play", () => {
              isPlaying = true;
              player.getCurrentTime((time) => {
                // Check if current position is beyond max watched
                const maxAllowed = getMaxAllowedSeekTime();
                if (time > maxAllowed + SEGMENT_TOLERANCE) {
                  // Force back to max watched position
                  try {
                    player.setCurrentTime(maxAllowed);
                    lastTrackedTime = maxAllowed;
                  } catch (e) {
                    lastTrackedTime = time;
                  }
                } else {
                  lastTrackedTime = time;
                }
              });
            });
            
            player.on("pause", () => {
              isPlaying = false;
              // Save the segment that was just watched
              if (lastTrackedTime >= 0) {
                player.getCurrentTime((currentTime) => {
                  if (currentTime > lastTrackedTime) {
                    addWatchedSegment(lastTrackedTime, currentTime);
                  }
                });
              }
            });

            // Event listeners for time updates
            player.on("timeupdate", (data) => {
              const currentSeconds = data.seconds;
              const totalDuration = data.duration || videoDuration;
              const now = Date.now();
              const timeSinceLastUpdate = now - lastUpdateTime;
              
              // Skip processing if we're currently seeking
              if (isSeeking) {
                console.log(' Skipping timeupdate (seeking in progress)');
                return;
              }
              
              // Detect if user skipped forward
              const timeDiff = currentSeconds - lastTrackedTime;
              
              if (timeDiff > SEGMENT_TOLERANCE) {
                // User jumped forward - check if it's to an unwatched area
                const maxAllowed = getMaxAllowedSeekTime();
                
                console.log(' Forward jump detected:', {
                  from: lastTrackedTime.toFixed(2),
                  to: currentSeconds.toFixed(2),
                  diff: timeDiff.toFixed(2),
                  maxAllowed: maxAllowed.toFixed(2)
                });
                
                if (currentSeconds > maxAllowed + SEGMENT_TOLERANCE) {
                  // Trying to skip to unwatched content - PREVENT IT!
                  isSeeking = true; // Set flag to prevent loop
                  
                  showSkipAlert(currentSeconds, maxAllowed);
                  
                  // FORCE player back to max watched position
                  try {
                    player.setCurrentTime(maxAllowed);
                    lastTrackedTime = maxAllowed;
                  } catch (e) {
                    // If setCurrentTime fails, go back to last position
                    try {
                      player.setCurrentTime(lastTrackedTime);
                    } catch (e2) {
                      lastTrackedTime = currentSeconds;
                    }
                  }
                  
                  updateProgressIndicator();
                  
                  // Clear seeking flag after a short delay
                  setTimeout(() => {
                    isSeeking = false;
                  }, 500);
                  
                  return;
                } else {
                  // Seeking within watched content - allowed but DON'T count as playback
                  console.log(' Seek within watched area (no segment added)');
                  lastTrackedTime = currentSeconds;
                  updateProgressIndicator();
                }
              } else if (timeDiff < -SEGMENT_TOLERANCE) {
                // User went backwards - always allowed
                console.log(' Backward seek (no segment added)');
                lastTrackedTime = currentSeconds;
                updateProgressIndicator();
              } else if (timeDiff >= 0 && timeDiff <= SEGMENT_TOLERANCE && isPlaying && timeSinceLastUpdate < MAX_UPDATE_GAP) {
                // Normal playback - more lenient for mobile compatibility:
                // 1. Small time difference (not a jump)
                // 2. Video is playing
                // 3. Less than MAX_UPDATE_GAP since last update (allows for mobile's irregular updates)
                
                console.log(' Normal playback - adding segment:', lastTrackedTime.toFixed(2), '', currentSeconds.toFixed(2));
                addWatchedSegment(lastTrackedTime, currentSeconds);
                lastTrackedTime = currentSeconds;
                lastUpdateTime = now;
                
                // Update progress indicator
                updateProgressIndicator();
                
                // Check if completion criteria is met
                checkVideoCompletion();
              } else if (timeDiff >= 0 && timeDiff <= MAX_SEGMENT_LENGTH && isPlaying) {
                // MOBILE FALLBACK: Allow larger time gaps if video is playing
                // This handles cases where mobile browsers fire timeupdate less frequently
                console.log(' Mobile-friendly playback - adding segment:', lastTrackedTime.toFixed(2), '', currentSeconds.toFixed(2));
                addWatchedSegment(lastTrackedTime, currentSeconds);
                lastTrackedTime = currentSeconds;
                lastUpdateTime = now;
                
                // Update progress indicator
                updateProgressIndicator();
                
                // Check if completion criteria is met
                checkVideoCompletion();
              } else {
                // Any other case - just update position without adding segment
                console.log(' Other case (no segment added):', {
                  timeDiff: timeDiff.toFixed(2),
                  isPlaying: isPlaying,
                  timeSinceLastUpdate: timeSinceLastUpdate
                });
                lastTrackedTime = currentSeconds;
                lastUpdateTime = now;
              }
            });

            player.on("ended", () => {
              isPlaying = false;
              console.log(' Video ended event fired');
              
              // Add final segment - ensure we capture the end
              if (lastTrackedTime >= 0 && videoDuration > 0) {
                addWatchedSegment(lastTrackedTime, videoDuration);
                // Also update maxWatchedTime to video duration
                maxWatchedTime = Math.max(maxWatchedTime, videoDuration);
              }
              
              // Check completion one final time
              if (!autoCompleted) {
                const watchPercentage = getWatchPercentage();
                console.log(' Final watch percentage:', watchPercentage.toFixed(2) + '%');
                
                // If we're close to 90% (within 5%), consider it complete
                // This handles edge cases where the last few seconds weren't tracked
                if (watchPercentage >= REQUIRED_WATCH_PERCENTAGE - 5) {
                  console.log(' Close enough to 90% - marking as complete');
                  autoCompleted = true;
                  clearSavedProgress();
                  
                  showEnhancedNotification(
                    ` Congratulations!\n\nYou've watched ${watchPercentage.toFixed(1)}% of the video.\n\nMarking as completed...`,
                    'success',
                    'Video Completed!',
                    4000
                  );
                  
                  updateContentProgressWithWatchData('completed', 100, {
                    watchedSegments: watchedSegments,
                    totalWatchedTime: getTotalWatchedTime(),
                    videoDuration: videoDuration,
                    watchPercentage: watchPercentage
                  });
                } else {
                  checkVideoCompletion();
                }
              }
            });

            player.on("error", () => {
              // Player error - silently handle
            });

          } catch (error) {
            // Error initializing player - silently handle
          }
        }

        // Aggressive periodic enforcement - runs even when paused
        setInterval(() => {
          if (!player || !playerReady) return;
          
          try {
            player.getCurrentTime((currentTime) => {
              const maxAllowed = getMaxAllowedSeekTime();
              
              // If ahead of max watched, force back immediately
              if (currentTime > maxAllowed + SEGMENT_TOLERANCE) {
                console.log(' Periodic enforcement: Returning from', currentTime.toFixed(2), 'to', maxAllowed.toFixed(2));
                
                if (!isSeeking) {
                  isSeeking = true;
                  player.setCurrentTime(maxAllowed);
                  lastTrackedTime = maxAllowed;
                  
                  setTimeout(() => {
                    isSeeking = false;
                  }, 300);
                }
              }
            });
          } catch (e) {
            // Silently handle
          }
        }, 500); // Check every 500ms (more frequent)
        
        // Save progress periodically (every 5 seconds)
        setInterval(() => {
          if (playerReady && maxWatchedTime > 0) {
            saveProgressToStorage();
          }
        }, 5000);
        
        // Wait a bit for the content to be rendered, then start checking for PlayerJS
        setTimeout(() => {
          checkPlayerJS();
        }, 500);
      }
    });

    // ==================== YOUTUBE VIDEO TRACKING ====================
    // Initialize YouTube Player API for YouTube videos
    let youtubePlayer = null;
    let youtubeVideoDuration = 0;
    let youtubeAutoCompleted = false;
    let youtubeProgressInterval = null;
    
    // ==================== YOUTUBE ANTI-SKIP TRACKING ====================
    let youtubeWatchedSegments = [];
    let youtubeLastTrackedTime = 0;
    let youtubeIsPlaying = false;
    const YOUTUBE_REQUIRED_WATCH_PERCENTAGE = 90;
    const YOUTUBE_SEGMENT_TOLERANCE = 3; // Increased for mobile compatibility
    const YOUTUBE_MAX_SEGMENT_LENGTH = 10; // Allow segments up to 10 seconds for mobile
    const YOUTUBE_MAX_UPDATE_GAP = 5000; // Allow 5 second gaps between updates for mobile
    let youtubeSkipAlertShown = false;
    let youtubeProgressIndicatorVisible = false;
    let youtubeMaxWatchedTime = 0;
    let youtubeIsSeeking = false;
    let youtubeLastSkipAlertTime = 0;
    let youtubeLastUpdateTime = Date.now();
    
    // LocalStorage for YouTube videos
    const youtubeStorageKey = 'video_progress_<%= contentItem._id %>';
    
    function loadYouTubeSavedProgress() {
      try {
        const saved = localStorage.getItem(youtubeStorageKey);
        if (saved) {
          const data = JSON.parse(saved);
          console.log(' Loading YouTube saved progress:', data);
          
          youtubeWatchedSegments = data.segments || [];
          youtubeMaxWatchedTime = data.maxWatchedTime || 0;
          
          return data.lastPosition || 0;
        }
      } catch (e) {
        console.error('Error loading YouTube saved progress:', e);
      }
      return 0;
    }
    
    function saveYouTubeProgressToStorage() {
      try {
        const data = {
          segments: youtubeWatchedSegments,
          maxWatchedTime: youtubeMaxWatchedTime,
          lastPosition: youtubeLastTrackedTime,
          timestamp: Date.now()
        };
        localStorage.setItem(youtubeStorageKey, JSON.stringify(data));
      } catch (e) {
        console.error('Error saving YouTube progress:', e);
      }
    }
    
    function clearYouTubeSavedProgress() {
      try {
        localStorage.removeItem(youtubeStorageKey);
        console.log(' Cleared YouTube saved progress');
      } catch (e) {
        console.error('Error clearing YouTube progress:', e);
      }
    }
    
    function addYouTubeWatchedSegment(start, end) {
      if (end <= start) return;
      
      // Cap at video duration
      if (youtubeVideoDuration > 0) {
        start = Math.max(0, Math.min(start, youtubeVideoDuration));
        end = Math.max(0, Math.min(end, youtubeVideoDuration));
      }
      
      const segmentLength = end - start;
      const startDiff = start - youtubeMaxWatchedTime;
      
      console.log(' YouTube addWatchedSegment:', {
        start: start.toFixed(2),
        end: end.toFixed(2),
        currentMax: youtubeMaxWatchedTime.toFixed(2),
        startDiff: startDiff.toFixed(2),
        segmentLength: segmentLength.toFixed(2)
      });
      
      // REJECT if segment length is too large (increased for mobile compatibility)
      if (segmentLength > YOUTUBE_MAX_SEGMENT_LENGTH) {
        console.log(' YOUTUBE SEGMENT TOO LARGE: Rejected (length:', segmentLength.toFixed(2), 's, max:', YOUTUBE_MAX_SEGMENT_LENGTH, 's)');
        return;
      }
      
      if (youtubeMaxWatchedTime === 0 || (startDiff >= -YOUTUBE_SEGMENT_TOLERANCE && startDiff <= YOUTUBE_SEGMENT_TOLERANCE)) {
        // Continuous from current max
        const oldMax = youtubeMaxWatchedTime;
        youtubeMaxWatchedTime = Math.max(youtubeMaxWatchedTime, end);
        console.log(' YouTube continuous: maxWatchedTime', oldMax.toFixed(2), '', youtubeMaxWatchedTime.toFixed(2));
      } else if (start <= youtubeMaxWatchedTime && end <= youtubeMaxWatchedTime + YOUTUBE_SEGMENT_TOLERANCE) {
        // Re-watching earlier content
        if (end > youtubeMaxWatchedTime) {
          const oldMax = youtubeMaxWatchedTime;
          youtubeMaxWatchedTime = end;
          console.log(' YouTube re-watch extended:', oldMax.toFixed(2), '', youtubeMaxWatchedTime.toFixed(2));
        } else {
          console.log(' YouTube re-watch (no extension)');
        }
      } else {
        console.log(' YOUTUBE GAP DETECTED: Segment rejected (startDiff:', startDiff.toFixed(2), 's)');
        return;
      }
      
      youtubeWatchedSegments.push({start: start, end: end});
      youtubeWatchedSegments = mergeYouTubeSegments(youtubeWatchedSegments);
    }
    
    function getYouTubeMaxAllowedSeekTime() {
      // Validate against actual segments
      let continuousMax = 0;
      
      if (youtubeWatchedSegments.length === 0) {
        return 0;
      }
      
      const sorted = [...youtubeWatchedSegments].sort((a, b) => a.start - b.start);
      
      for (const segment of sorted) {
        if (segment.start <= continuousMax + YOUTUBE_SEGMENT_TOLERANCE) {
          continuousMax = Math.max(continuousMax, segment.end);
        } else {
          break;
        }
      }
      
      const validMax = Math.min(continuousMax, youtubeMaxWatchedTime);
      
      if (validMax < youtubeMaxWatchedTime) {
        console.log(' YouTube: Correcting maxWatchedTime from', youtubeMaxWatchedTime.toFixed(2), 'to', validMax.toFixed(2));
        youtubeMaxWatchedTime = validMax;
      }
      
      return youtubeMaxWatchedTime;
    }
    
    function mergeYouTubeSegments(segments) {
      if (segments.length === 0) return [];
      segments.sort((a, b) => a.start - b.start);
      const merged = [segments[0]];
      
      for (let i = 1; i < segments.length; i++) {
        const current = segments[i];
        const last = merged[merged.length - 1];
        // Prevent double counting
        if (current.start <= last.end + 0.5) {
          last.end = Math.max(last.end, current.end);
        } else {
          merged.push(current);
        }
      }
      return merged;
    }
    
    function getYouTubeTotalWatchedTime() {
      let total = 0;
      for (const segment of youtubeWatchedSegments) {
        total += (segment.end - segment.start);
      }
      // Cap at video duration
      if (youtubeVideoDuration > 0) {
        total = Math.min(total, youtubeVideoDuration);
      }
      return total;
    }
    
    function getYouTubeWatchPercentage() {
      if (youtubeVideoDuration <= 0) return 0;
      const percentage = (getYouTubeTotalWatchedTime() / youtubeVideoDuration) * 100;
      return Math.min(percentage, 100); // Cap at 100%
    }
    
    // Update YouTube progress indicator
    function updateYouTubeProgressIndicator() {
      const progressDiv = document.getElementById('youtubeWatchProgress');
      if (!progressDiv) return;
      
      // Show indicator when video starts playing
      if (!youtubeProgressIndicatorVisible && youtubeIsPlaying) {
        progressDiv.style.display = 'block';
        youtubeProgressIndicatorVisible = true;
      }
      
      const watchPercentage = getYouTubeWatchPercentage();
      const totalWatched = getYouTubeTotalWatchedTime();
      const remaining = Math.max(0, YOUTUBE_REQUIRED_WATCH_PERCENTAGE - watchPercentage);
      
      // Format time helper
      const formatTime = (seconds) => {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs.toString().padStart(2, '0')}`;
      };
      
      // Update percentage text
      const percentElem = document.getElementById('youtubeWatchProgressPercent');
      if (percentElem) {
        percentElem.textContent = watchPercentage.toFixed(1) + '%';
        if (watchPercentage >= YOUTUBE_REQUIRED_WATCH_PERCENTAGE) {
          percentElem.style.color = '#10b981';
        } else if (watchPercentage >= 60) {
          percentElem.style.color = '#fbbf24';
        } else {
          percentElem.style.color = '#ef4444';
        }
      }
      
      // Update time text
      const timeElem = document.getElementById('youtubeWatchProgressTime');
      if (timeElem) {
        timeElem.textContent = `${formatTime(totalWatched)} / ${formatTime(youtubeVideoDuration)}`;
      }
      
      // Update circular progress
      const circleElem = document.getElementById('youtubeWatchProgressCircle');
      if (circleElem) {
        const circumference = 125.6;
        const offset = circumference - (watchPercentage / 100 * circumference);
        circleElem.style.strokeDashoffset = offset;
        
        if (watchPercentage >= YOUTUBE_REQUIRED_WATCH_PERCENTAGE) {
          circleElem.style.stroke = '#10b981';
        } else if (watchPercentage >= 60) {
          circleElem.style.stroke = '#fbbf24';
        } else {
          circleElem.style.stroke = '#ef4444';
        }
      }
      
      // Update circle text
      const circleTextElem = document.getElementById('youtubeWatchProgressCircleText');
      if (circleTextElem) {
        circleTextElem.textContent = Math.floor(watchPercentage) + '%';
      }
      
      // Update remaining
      const remainingElem = document.getElementById('youtubeWatchProgressRemaining');
      if (remainingElem) {
        if (remaining <= 0) {
          remainingElem.textContent = ' Done';
          remainingElem.style.color = '#10b981';
        } else {
          remainingElem.textContent = remaining.toFixed(1) + '%';
        }
      }
      
      // Update max seek time
      const maxSeekElem = document.getElementById('youtubeMaxSeekTime');
      if (maxSeekElem) {
        const maxTime = Math.max(youtubeMaxWatchedTime, 0);
        maxSeekElem.textContent = formatTime(maxTime);
        // Change color based on progress
        if (maxTime >= youtubeVideoDuration * 0.9) {
          maxSeekElem.style.color = '#10b981';
        } else if (maxTime >= youtubeVideoDuration * 0.5) {
          maxSeekElem.style.color = '#fbbf24';
        } else {
          maxSeekElem.style.color = '#ef4444';
        }
      }
    }
    
    // Show YouTube skip alert (with debounce)
    function showYouTubeSkipAlert(targetTime, maxAllowed) {
      const now = Date.now();
      if (now - youtubeLastSkipAlertTime < 3000) {
        return;
      }
      youtubeLastSkipAlertTime = now;
      
      const formatTime = (seconds) => {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs.toString().padStart(2, '0')}`;
      };
      
      showEnhancedNotification(
        ` Cannot Skip to Unwatched Content!\n\nYou tried to jump to ${formatTime(targetTime)}, but you've only watched up to ${formatTime(maxAllowed)}.\n\n You can seek within watched segments\n You cannot skip to unwatched parts\n\nWatch the video continuously to unlock more content.`,
        'error',
        'Skip Prevented',
        5000
      );
    }
    
    function checkYouTubeVideoCompletion() {
      const watchPercentage = getYouTubeWatchPercentage();
      const totalWatched = getYouTubeTotalWatchedTime();
      
      // Debug logging
      console.log(` YouTube Progress Check:`, {
        watchPercentage: watchPercentage.toFixed(2) + '%',
        totalWatched: totalWatched.toFixed(2) + 's',
        videoDuration: youtubeVideoDuration.toFixed(2) + 's',
        required: YOUTUBE_REQUIRED_WATCH_PERCENTAGE + '%',
        autoCompleted: youtubeAutoCompleted
      });

      if (watchPercentage >= YOUTUBE_REQUIRED_WATCH_PERCENTAGE && !youtubeAutoCompleted) {
        youtubeAutoCompleted = true;

        if (youtubeProgressInterval) {
          clearInterval(youtubeProgressInterval);
        }
        
        console.log(' YouTube video completion triggered! Sending to backend...');
        
        // Clear saved progress since video is completed
        clearYouTubeSavedProgress();

        // Show success notification
        showEnhancedNotification(
          ` Congratulations!\n\nYou've watched ${watchPercentage.toFixed(1)}% of the video.\n\nMarking as completed...`,
          'success',
          'Video Completed!',
          4000
        );

        const hasWatchLimit = <%= watchLimitInfo && watchLimitInfo.hasLimit ? 'true' : 'false' %>;
        const currentWatchCount = <%= watchLimitInfo ? watchLimitInfo.watchCount : 0 %>;
        const currentMaxWatchCount = <%= watchLimitInfo && watchLimitInfo.maxWatchCount ? watchLimitInfo.maxWatchCount : 'null' %>;

        if (hasWatchLimit && currentMaxWatchCount !== null && currentWatchCount + 1 >= currentMaxWatchCount) {
          setTimeout(() => {
            showEnhancedNotification(
              `This was your final allowed watch of this video (${currentWatchCount + 1}/${currentMaxWatchCount}). You won't be able to watch it again.`,
              'warning',
              'Final Watch Warning'
            );
          }, 2000);
        }

        updateContentProgressWithWatchData('completed', 100, {
          watchedSegments: youtubeWatchedSegments,
          totalWatchedTime: totalWatched,
          videoDuration: youtubeVideoDuration,
          watchPercentage: watchPercentage
        });
      }
    }

    // YouTube API callback - must be global
    function onYouTubeIframeAPIReady() {
      initializeYouTubePlayer();
      
      // Also initialize recording YouTube player if needed
      if (window.recordingYoutubeVideoId && typeof window.initializeRecordingYouTubePlayer === 'function') {
        // Wait a bit for DOM to be ready
        setTimeout(() => {
          const isAlreadyCompleted = '<%= contentProgress.isCompleted ? "true" : "false" %>' === 'true';
          window.initializeRecordingYouTubePlayer(isAlreadyCompleted);
        }, 500);
      }
    }

    function initializeYouTubePlayer() {
      const isVideoContent = '<%= contentItem.type %>' === 'video';
      const hasVideoContent = '<%= contentItem.content ? "true" : "false" %>' === 'true';
      const watchLimitReached = <%= watchLimitInfo && watchLimitInfo.limitReached ? 'true' : 'false' %>;
      const isAlreadyCompleted = '<%= contentProgress.isCompleted ? "true" : "false" %>' === 'true';
      
      // Check if this is a YouTube video and API is loaded
      if (isVideoContent && hasVideoContent && !watchLimitReached && window.youtubeVideoId && typeof YT !== 'undefined') {
        youtubeAutoCompleted = isAlreadyCompleted;
        
        // Check if player container exists
          const playerContainer = document.getElementById('youtube-player');
          if (!playerContainer) {
            return;
          }
        
        // Initialize YouTube player
        try {
          youtubePlayer = new YT.Player('youtube-player', {
            height: '100%',
            width: '100%',
            videoId: window.youtubeVideoId,
            playerVars: {
              'playsinline': 1,
              'rel': 0,
              'modestbranding': 1,
              'enablejsapi': 1
            },
            events: {
              'onReady': onYouTubePlayerReady,
              'onStateChange': onYouTubeStateChange
            }
          });
        } catch (error) {
          // Error initializing YouTube player - silently handle
        }
      }
    }

    // Fallback: Check if YouTube API is loaded when DOM is ready
    document.addEventListener('DOMContentLoaded', function() {
      // If YouTube API is already loaded, initialize immediately
      if (typeof YT !== 'undefined' && YT.Player && window.youtubeVideoId) {
        setTimeout(initializeYouTubePlayer, 500);
      }
    });

    function onYouTubePlayerReady(event) {
      youtubeVideoDuration = event.target.getDuration();
      
      // Load saved progress
      const savedPosition = loadYouTubeSavedProgress();
      
      if (savedPosition > 0 && savedPosition < youtubeVideoDuration) {
        // Restore to saved position
        console.log(' Restoring YouTube to saved position:', savedPosition.toFixed(2));
        youtubeLastTrackedTime = savedPosition;
        
        showEnhancedNotification(
          `Resuming from ${Math.floor(savedPosition / 60)}:${Math.floor(savedPosition % 60).toString().padStart(2, '0')}`,
          'info',
          'Progress Restored',
          3000
        );
        
        try {
          youtubePlayer.seekTo(savedPosition, true);
        } catch (e) {
          console.error('Error setting YouTube saved position:', e);
        }
      } else {
        youtubeLastTrackedTime = 0;
      }
      
      // Start tracking progress every second
      youtubeProgressInterval = setInterval(() => {
        trackYouTubeProgress();
        
        // Periodic enforcement - ensure player never gets ahead
        if (youtubePlayer && youtubeIsPlaying && !youtubeAutoCompleted) {
          try {
            const currentTime = youtubePlayer.getCurrentTime();
            const maxAllowed = getYouTubeMaxAllowedSeekTime();
            
            if (currentTime > maxAllowed + YOUTUBE_SEGMENT_TOLERANCE) {
              console.log(' YouTube position enforcement: Returning from', currentTime.toFixed(2), 'to', maxAllowed.toFixed(2));
              youtubePlayer.seekTo(maxAllowed, true);
              youtubeLastTrackedTime = maxAllowed;
            }
          } catch (e) {
            // Silently handle
          }
        }
      }, 1000);
      
      // Save YouTube progress periodically
      setInterval(() => {
        if (youtubeMaxWatchedTime > 0) {
          saveYouTubeProgressToStorage();
        }
      }, 5000);
    }

    function onYouTubeStateChange(event) {
      if (event.data === YT.PlayerState.PLAYING) {
        youtubeIsPlaying = true;
        const currentTime = youtubePlayer.getCurrentTime();
        const maxAllowed = getYouTubeMaxAllowedSeekTime();
        
        // Check if position is beyond max watched
        if (currentTime > maxAllowed + YOUTUBE_SEGMENT_TOLERANCE) {
          // Force back to max watched position
          try {
            youtubePlayer.seekTo(maxAllowed, true);
            youtubeLastTrackedTime = maxAllowed;
          } catch (e) {
            youtubeLastTrackedTime = currentTime;
          }
        } else {
          youtubeLastTrackedTime = currentTime;
        }
      } else if (event.data === YT.PlayerState.PAUSED) {
        youtubeIsPlaying = false;
        const currentTime = youtubePlayer.getCurrentTime();
        if (currentTime > youtubeLastTrackedTime) {
          addYouTubeWatchedSegment(youtubeLastTrackedTime, currentTime);
        }
      } else if (event.data === YT.PlayerState.ENDED) {
        youtubeIsPlaying = false;
        console.log(' YouTube video ended event fired');
        
        // Add final segment - ensure we capture the end
        if (youtubeLastTrackedTime >= 0 && youtubeVideoDuration > 0) {
          addYouTubeWatchedSegment(youtubeLastTrackedTime, youtubeVideoDuration);
          // Also update maxWatchedTime to video duration
          youtubeMaxWatchedTime = Math.max(youtubeMaxWatchedTime, youtubeVideoDuration);
        }
        
        if (!youtubeAutoCompleted) {
          const watchPercentage = getYouTubeWatchPercentage();
          console.log(' Final YouTube watch percentage:', watchPercentage.toFixed(2) + '%');
          
          // If we're close to 90% (within 5%), consider it complete
          // This handles edge cases where the last few seconds weren't tracked
          if (watchPercentage >= YOUTUBE_REQUIRED_WATCH_PERCENTAGE - 5) {
            console.log(' YouTube: Close enough to 90% - marking as complete');
            youtubeAutoCompleted = true;
            clearYouTubeSavedProgress();
            
            showEnhancedNotification(
              ` Congratulations!\n\nYou've watched ${watchPercentage.toFixed(1)}% of the video.\n\nMarking as completed...`,
              'success',
              'Video Completed!',
              4000
            );
            
            updateContentProgressWithWatchData('completed', 100, {
              watchedSegments: youtubeWatchedSegments,
              totalWatchedTime: getYouTubeTotalWatchedTime(),
              videoDuration: youtubeVideoDuration,
              watchPercentage: watchPercentage
            });
          } else {
            checkYouTubeVideoCompletion();
          }
        }
      }
    }

    function trackYouTubeProgress() {
      if (!youtubePlayer || youtubeAutoCompleted || youtubeIsSeeking) return;
      
      try {
        const currentTime = youtubePlayer.getCurrentTime();
        const timeDiff = currentTime - youtubeLastTrackedTime;
        const now = Date.now();
        const timeSinceLastUpdate = now - youtubeLastUpdateTime;
        
        // Detect if user skipped forward
        if (timeDiff > YOUTUBE_SEGMENT_TOLERANCE) {
          // User jumped forward - check if it's to an unwatched area
          const maxAllowed = getYouTubeMaxAllowedSeekTime();
          
          if (currentTime > maxAllowed + YOUTUBE_SEGMENT_TOLERANCE) {
            // Trying to skip to unwatched content - PREVENT IT!
            youtubeIsSeeking = true;
            
            showYouTubeSkipAlert(currentTime, maxAllowed);
            
            // FORCE player back to max watched position
            try {
              youtubePlayer.seekTo(maxAllowed, true);
              youtubeLastTrackedTime = maxAllowed;
            } catch (e) {
              // If seekTo fails, go back to last position
              try {
                youtubePlayer.seekTo(youtubeLastTrackedTime, true);
              } catch (e2) {
                youtubeLastTrackedTime = currentTime;
              }
            }
            
            updateYouTubeProgressIndicator();
            
            setTimeout(() => {
              youtubeIsSeeking = false;
            }, 500);
            
            return;
          } else {
            // Seeking within watched content - allowed
            // DON'T update maxWatchedTime here
            youtubeLastTrackedTime = currentTime;
            updateYouTubeProgressIndicator();
          }
        } else if (timeDiff < -YOUTUBE_SEGMENT_TOLERANCE) {
          // User went backwards - always allowed
          // Just update tracking position (don't count twice)
          youtubeLastTrackedTime = currentTime;
          updateYouTubeProgressIndicator();
        } else if (timeDiff >= 0 && timeDiff <= YOUTUBE_SEGMENT_TOLERANCE && youtubeIsPlaying && timeSinceLastUpdate < YOUTUBE_MAX_UPDATE_GAP) {
          // Normal playback - ONLY update maxWatchedTime during actual playback
          addYouTubeWatchedSegment(youtubeLastTrackedTime, currentTime);
          youtubeLastTrackedTime = currentTime;
          youtubeLastUpdateTime = now;
          
          // Update progress indicator
          updateYouTubeProgressIndicator();
          
          // Check if completion criteria is met
          checkYouTubeVideoCompletion();
        } else if (timeDiff >= 0 && timeDiff <= YOUTUBE_MAX_SEGMENT_LENGTH && youtubeIsPlaying) {
          // MOBILE FALLBACK: Allow larger time gaps if video is playing
          // This handles cases where mobile browsers fire progress updates less frequently
          console.log(' YouTube mobile-friendly playback - adding segment:', youtubeLastTrackedTime.toFixed(2), '', currentTime.toFixed(2));
          addYouTubeWatchedSegment(youtubeLastTrackedTime, currentTime);
          youtubeLastTrackedTime = currentTime;
          youtubeLastUpdateTime = now;
          
          // Update progress indicator
          updateYouTubeProgressIndicator();
          
          // Check if completion criteria is met
          checkYouTubeVideoCompletion();
        }
      } catch (error) {
        // Error tracking YouTube progress - silently handle
      }
    }

    // ==================== ZOOM RECORDING PLAYER TRACKING ====================
    // Initialize player for Zoom recording (supports both YouTube and Bunny/PlayerJS)
    let recordingYouTubePlayer = null;
    let recordingYouTubeDuration = 0;
    let recordingYouTubeAutoCompleted = false;
    let recordingYouTubeProgressInterval = null;

    // Make function globally accessible for YouTube API callback
    window.initializeRecordingYouTubePlayer = function(isAlreadyCompleted) {
      recordingYouTubeAutoCompleted = isAlreadyCompleted;

      function initRecordingYouTube() {
        if (typeof YT === 'undefined' || !YT.Player) {
          setTimeout(initRecordingYouTube, 100);
          return;
        }

        try {
          const playerContainer = document.getElementById('recording-youtube-player');
          if (!playerContainer) {
            return;
          }

          recordingYouTubePlayer = new YT.Player('recording-youtube-player', {
            height: '100%',
            width: '100%',
            videoId: window.recordingYoutubeVideoId,
            playerVars: {
              'playsinline': 1,
              'rel': 0,
              'modestbranding': 1,
              'enablejsapi': 1
            },
            events: {
              'onReady': onRecordingYouTubeReady,
              'onStateChange': onRecordingYouTubeStateChange
            }
          });
        } catch (error) {
          // Error initializing recording YouTube player - silently handle
        }
      }

      function onRecordingYouTubeReady(event) {
        recordingYouTubeDuration = event.target.getDuration();
        
        // Start tracking progress every second
        recordingYouTubeProgressInterval = setInterval(() => {
          trackRecordingYouTubeProgress();
        }, 1000);
      }

      function onRecordingYouTubeStateChange(event) {
        if (event.data === YT.PlayerState.ENDED) {
          if (!recordingYouTubeAutoCompleted) {
            recordingYouTubeAutoCompleted = true;
            if (recordingYouTubeProgressInterval) {
              clearInterval(recordingYouTubeProgressInterval);
            }
            
            const progressContainer = document.querySelector('.recording-progress-container');
            if (progressContainer) {
              progressContainer.innerHTML = `
                <div class="recording-auto-complete-message">
                  <i class="fas fa-check-circle"></i>
                  <span>Recording complete - Saving progress...</span>
                </div>
              `;
            }
            
            updateContentProgressSmooth('completed', 100);
      }
        }
      }

      function trackRecordingYouTubeProgress() {
        if (!recordingYouTubePlayer || recordingYouTubeAutoCompleted) return;
        
        try {
          const playerState = recordingYouTubePlayer.getPlayerState();
          
          // Only track when playing
          if (playerState === YT.PlayerState.PLAYING) {
            const currentTime = recordingYouTubePlayer.getCurrentTime();
            const totalDuration = recordingYouTubeDuration;
            const progressPercentage = totalDuration > 0 ? (currentTime / totalDuration) * 100 : 0;

            // Update progress bar UI
            const progressFill = document.getElementById('recordingProgressFill');
            const progressText = document.getElementById('recordingProgressText');
            if (progressFill) progressFill.style.width = progressPercentage + '%';
            if (progressText) progressText.textContent = Math.round(progressPercentage) + '%';

            // Auto-complete when reaching 90% or last 10 seconds
            if (totalDuration > 0) {
              const shouldComplete = progressPercentage >= 90 || currentTime >= totalDuration - 10;
              
              if (shouldComplete && !recordingYouTubeAutoCompleted) {
                recordingYouTubeAutoCompleted = true;
                if (recordingYouTubeProgressInterval) {
                  clearInterval(recordingYouTubeProgressInterval);
                }
                
                const progressContainer = document.querySelector('.recording-progress-container');
                if (progressContainer) {
                  progressContainer.innerHTML = `
                    <div class="recording-auto-complete-message">
                      <i class="fas fa-check-circle"></i>
                      <span>Recording watched - Marking as complete...</span>
                    </div>
                  `;
                }
                
                updateContentProgressSmooth('completed', 100);
              }
            }
          }
        } catch (error) {
          // Error tracking recording YouTube progress - silently handle
        }
      }

      // Start initialization
      if (typeof YT !== 'undefined' && YT.Player) {
        initRecordingYouTube();
      } else {
        // Wait for YouTube API to load
        setTimeout(initRecordingYouTube, 500);
      }
    };

    document.addEventListener('DOMContentLoaded', function() {
      const isZoomContent = '<%= contentItem.type %>' === 'zoom';
      const hasRecording = '<%= contentItem.zoomMeeting && contentItem.zoomMeeting.recordingUrl ? "true" : "false" %>' === 'true';
      const meetingEnded = '<%= contentItem.zoomMeeting && contentItem.zoomMeeting.status === "ended" ? "true" : "false" %>' === 'true';
      const isAlreadyCompleted = '<%= contentProgress.isCompleted ? "true" : "false" %>' === 'true';

      // Recording completion is now handled by the "I Have Watched" button
      // Automatic progress tracking is disabled for a simpler, more professional workflow
      // Students click the button after watching the recording to mark it as complete
    });

    function initializeRecordingPlayerJS(isAlreadyCompleted) {
      let recordingPlayer = null;
      let recordingDuration = 0;
      let recordingPlayerReady = false;
      let recordingAutoCompleted = isAlreadyCompleted;

      function checkRecordingPlayerJS() {
        if (typeof playerjs === 'undefined') {
          setTimeout(checkRecordingPlayerJS, 100);
          return;
        }
        initRecordingPlayer();
      }

      function initRecordingPlayer() {
        try {
          // Try to find iframe by ID first (for regular URL)
          let iframe = document.getElementById('recordingPlayer');
          
          // If not found, look for iframe inside the video container (for embed code)
          if (!iframe) {
            const videoContainer = document.querySelector('.video-player-container');
            if (videoContainer) {
              iframe = videoContainer.querySelector('iframe');
            }
          }
          
          if (!iframe) {
            console.log(' Recording iframe not found');
            return;
          }

          // Add ID to iframe if it doesn't have one (for PlayerJS)
          if (!iframe.id) {
            iframe.id = 'recordingPlayer-' + Date.now();
          }

          recordingPlayer = new playerjs.Player(iframe.id);

          recordingPlayer.on("ready", () => {
            recordingPlayerReady = true;

            recordingPlayer.getDuration((duration) => {
              recordingDuration = duration;
            });
          });

          // Track progress
          recordingPlayer.on("timeupdate", (data) => {
            const currentSeconds = data.seconds;
            const totalDuration = data.duration || recordingDuration;
            const progressPercentage = totalDuration > 0 ? (currentSeconds / totalDuration) * 100 : 0;

            // Update progress bar UI
            const progressFill = document.getElementById('recordingProgressFill');
            const progressText = document.getElementById('recordingProgressText');
            if (progressFill) progressFill.style.width = progressPercentage + '%';
            if (progressText) progressText.textContent = Math.round(progressPercentage) + '%';

            // Auto-complete when reaching 90% or last 10 seconds
            if (totalDuration > 0 && !recordingAutoCompleted) {
              const shouldComplete = progressPercentage >= 90 || currentSeconds >= totalDuration - 10;
              
              if (shouldComplete) {
                recordingAutoCompleted = true;
                
                // Hide progress bar and show completion
                const progressContainer = document.querySelector('.recording-progress-container');
                if (progressContainer) {
                  progressContainer.innerHTML = `
                    <div class="recording-auto-complete-message">
                      <i class="fas fa-check-circle"></i>
                      <span>Recording watched - Marking as complete...</span>
                    </div>
                  `;
                }
                
                updateContentProgressSmooth('completed', 100);
              }
            }
          });

          recordingPlayer.on("ended", () => {
            if (!recordingAutoCompleted) {
              recordingAutoCompleted = true;
              
              const progressContainer = document.querySelector('.recording-progress-container');
              if (progressContainer) {
                progressContainer.innerHTML = `
                  <div class="recording-auto-complete-message">
                    <i class="fas fa-check-circle"></i>
                    <span>Recording complete - Saving progress...</span>
                  </div>
                `;
              }
              
              updateContentProgressSmooth('completed', 100);
            }
          });

          recordingPlayer.on("error", () => {
            // Recording player error - silently handle
          });

        } catch (error) {
          // Error initializing recording player - silently handle
        }
      }

      // Start checking for PlayerJS
      setTimeout(() => {
        checkRecordingPlayerJS();
      }, 500);
    }

    // Acknowledgment helpers (download/link/read)
    function acknowledgeAndComplete(event) {
      // Disable button immediately to prevent multiple clicks
      const button = (event && event.target) || document.querySelector('button[onclick*="acknowledgeAndComplete"]');
      if (button && !button.disabled) {
        button.disabled = true;
        button.style.opacity = '0.6';
        button.style.cursor = 'not-allowed';
        const originalText = button.innerHTML;
        button.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Processing...';
        button.dataset.originalText = originalText;
      }
      
      updateContentProgressSmooth('completed', 100);
    }

    function handleDownloadAcknowledge(event) {
      try {
        // allow the download to start, and mark as completed shortly after
        setTimeout(() => acknowledgeAndComplete(), 800);
      } catch (e) {
        // fallback
        acknowledgeAndComplete();
      }
    }

    function handleLinkVisitAcknowledge(event) {
      // Open link in new tab, then mark as completed
      setTimeout(() => acknowledgeAndComplete(), 1000);
    }

    // Mark recording as watched - simple completion for Zoom recordings
    function markRecordingAsWatched(event) {
      // Disable button immediately to prevent multiple clicks
      const button = (event && event.target) || document.querySelector('.recording-mark-watched-btn');
      if (button && !button.disabled) {
        button.disabled = true;
        button.style.opacity = '0.6';
        button.style.cursor = 'not-allowed';
        const originalText = button.innerHTML;
        button.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Marking as completed...';
        button.dataset.originalText = originalText;
      }
      
      // Mark as completed
      updateContentProgressSmooth('completed', 100);
    }

    // ==================== RECORDING WATCH TRACKING FOR NON-ATTENDEES ====================
    // Anti-skip protection with segment tracking (same as regular video)
    
    const isZoomContent = '<%= contentItem.type %>' === 'zoom';
    const studentAttendedLive = <%= typeof studentAttendedLiveMeeting !== 'undefined' ? studentAttendedLiveMeeting : false %>;
    const isRecordingComplete = <%= contentProgress.isCompleted ? 'true' : 'false' %>;
    const needsRecordingWatchTracking = isZoomContent && !studentAttendedLive && !isRecordingComplete;
    
    // Recording anti-skip tracking state
    let recWatchedSegments = [];
    let recMaxWatchedTime = 0;
    let recVideoDuration = 0;
    let recIsPlaying = false;
    let recLastTime = 0;
    let recHasAutoCompleted = false;
    let recPlayer = null;
    const REC_REQUIRED_PERCENTAGE = 90;
    const REC_MAX_SEGMENT_LENGTH = 10; // Allow segments up to 10 seconds (increased for mobile)
    const REC_SEGMENT_TOLERANCE = 3; // Allow 3 second jumps (increased for mobile)
    
    // Generate unique localStorage key for this recording
    const recStorageKey = 'recProgress_<%= contentItem._id %>';
    
    // Save recording progress to localStorage
    function saveRecordingProgress() {
      if (!needsRecordingWatchTracking) return;
      const data = {
        segments: recWatchedSegments,
        maxWatchedTime: recMaxWatchedTime,
        duration: recVideoDuration,
        savedAt: Date.now()
      };
      try {
        localStorage.setItem(recStorageKey, JSON.stringify(data));
        console.log(' Saved recording progress to localStorage');
      } catch (e) {
        console.warn('Could not save recording progress:', e);
      }
    }
    
    // Restore recording progress from localStorage
    function restoreRecordingProgress() {
      try {
        const saved = localStorage.getItem(recStorageKey);
        if (saved) {
          const data = JSON.parse(saved);
          // Only restore if saved within 30 days
          if (data.savedAt && Date.now() - data.savedAt < 30 * 24 * 60 * 60 * 1000) {
            recWatchedSegments = data.segments || [];
            recMaxWatchedTime = data.maxWatchedTime || 0;
            if (data.duration) recVideoDuration = data.duration;
            console.log(' Restored recording progress from localStorage:', Math.round(recMaxWatchedTime) + 's watched');
            
            // Show restored alert if there's meaningful progress
            if (recMaxWatchedTime > 10) {
              showRecordingRestoredAlert(recMaxWatchedTime);
            }
            return true;
          }
        }
      } catch (e) {
        console.warn('Could not restore recording progress:', e);
      }
      return false;
    }
    
    // Show alert when recording progress is restored
    function showRecordingRestoredAlert(secondsWatched) {
      const mins = Math.floor(secondsWatched / 60);
      const secs = Math.floor(secondsWatched % 60);
      const timeStr = mins > 0 ? `${mins}:${secs.toString().padStart(2, '0')}` : `${secs}s`;
      
      const alert = document.createElement('div');
      alert.id = 'recRestoredAlert';
      alert.innerHTML = `
        <div style="
          position: fixed;
          top: 10px;
          right: 20px;
          z-index: 99999;
          background: linear-gradient(135deg, #3b82f6, #1d4ed8);
          color: white;
          padding: 14px 20px;
          border-radius: 10px;
          box-shadow: 0 6px 20px rgba(59, 130, 246, 0.4);
          display: flex;
          align-items: center;
          gap: 12px;
          animation: slideInRight 0.4s ease-out;
          max-width: 300px;
          font-size: 0.9rem;
        ">
          <i class="fas fa-history" style="font-size: 1.2rem;"></i>
          <div>
            <strong style="display: block; margin-bottom: 2px;">Progress Restored</strong>
            <span style="opacity: 0.9;">Resuming from ${timeStr}</span>
          </div>
          <button onclick="this.parentElement.remove()" style="
            position: absolute;
            top: 6px;
            right: 8px;
            background: transparent;
            border: none;
            color: rgba(255,255,255,0.6);
            cursor: pointer;
            font-size: 12px;
          "><i class="fas fa-times"></i></button>
        </div>
      `;
      document.body.appendChild(alert);
      
      // Auto-remove after 5 seconds
      setTimeout(() => {
        if (alert.parentElement) {
          alert.style.transition = 'opacity 0.3s ease-out';
          alert.style.opacity = '0';
          setTimeout(() => alert.remove(), 300);
        }
      }, 5000);
    }
    
    // Initialize recording watch tracking for non-attendees
    if (needsRecordingWatchTracking) {
      document.addEventListener('DOMContentLoaded', function() {
        restoreRecordingProgress();
        setTimeout(initRecordingAntiSkipTracking, 1000);
        // Save progress every 5 seconds
        setInterval(saveRecordingProgress, 5000);
      });
      // Save on page unload
      window.addEventListener('beforeunload', saveRecordingProgress);
    }
    
    function initRecordingAntiSkipTracking() {
      // Find the recording iframe
      const recordingContainer = document.querySelector('.recording-video-container');
      if (!recordingContainer) return;
      
      const iframe = recordingContainer.querySelector('iframe');
      if (!iframe) {
        // Try to find iframe in bunny-embed-wrapper
        const bunnyWrapper = recordingContainer.querySelector('.bunny-embed-wrapper');
        if (bunnyWrapper) {
          const bunnyIframe = bunnyWrapper.querySelector('iframe');
          if (bunnyIframe) {
            setupRecordingPlayer(bunnyIframe);
          }
        }
        return;
      }
      
      setupRecordingPlayer(iframe);
    }
    
    function setupRecordingPlayer(iframe) {
      console.log(' Initializing recording anti-skip tracking for non-attendee');
      
      try {
        if (typeof playerjs !== 'undefined') {
          recPlayer = new playerjs.Player(iframe);
          
          recPlayer.on('ready', function() {
            recPlayer.getDuration(function(duration) {
              recVideoDuration = duration;
              console.log(' Recording duration:', recVideoDuration);
              
              // Seek to restored position if available
              if (recMaxWatchedTime > 10) {
                console.log(' Seeking to restored position:', recMaxWatchedTime);
                recPlayer.setCurrentTime(recMaxWatchedTime);
              }
            });
          });
          
          recPlayer.on('play', function() {
            recIsPlaying = true;
          });
          
          recPlayer.on('pause', function() {
            recIsPlaying = false;
          });
          
          recPlayer.on('timeupdate', function(data) {
            if (recHasAutoCompleted) return;
            
            const currentTime = data.seconds;
            const timeDiff = currentTime - recLastTime;
            
            // ANTI-SKIP: Check if user tried to skip ahead (with increased tolerance for mobile)
            if (currentTime > recMaxWatchedTime + REC_SEGMENT_TOLERANCE) {
              // User tried to skip ahead - seek back to max watched position
              console.log(' Anti-skip: Preventing skip from', currentTime, 'to', recMaxWatchedTime);
              recPlayer.setCurrentTime(recMaxWatchedTime);
              return;
            }
            
            // Update max watched time
            if (currentTime > recMaxWatchedTime) {
              recMaxWatchedTime = currentTime;
            }
            
            // Track watched segment - more lenient for mobile compatibility
            // Allow segments up to REC_MAX_SEGMENT_LENGTH seconds (handles irregular timeupdate on mobile)
            if (recIsPlaying && currentTime > recLastTime && timeDiff > 0 && timeDiff <= REC_MAX_SEGMENT_LENGTH) {
              // Add to watched segments
              const segmentStart = recLastTime;
              const segmentEnd = currentTime;
              console.log(' Adding recording segment:', segmentStart.toFixed(2), '', segmentEnd.toFixed(2));
              addRecordingWatchedSegment(segmentStart, segmentEnd);
            }
            
            recLastTime = currentTime;
            
            // Calculate actual watched percentage from segments
            if (recVideoDuration > 0) {
              const totalWatchedTime = calculateRecordingWatchedTime();
              const watchedPercentage = Math.min(100, (totalWatchedTime / recVideoDuration) * 100);
              
              // Update progress overlay UI
              updateRecordingProgressUI(watchedPercentage, currentTime);
              
              // Auto-complete if watched enough
              if (watchedPercentage >= REC_REQUIRED_PERCENTAGE && !recHasAutoCompleted) {
                recHasAutoCompleted = true;
                console.log(' Recording watch requirement met! Auto-completing...');
                autoCompleteRecording();
              }
            }
          });
          
          recPlayer.on('ended', function() {
            console.log(' Recording ended event fired');
            recIsPlaying = false;
            
            // Add final segment to capture the end
            if (recLastTime >= 0 && recVideoDuration > 0) {
              addRecordingWatchedSegment(recLastTime, recVideoDuration);
              recMaxWatchedTime = Math.max(recMaxWatchedTime, recVideoDuration);
            }
            
            if (recVideoDuration > 0 && !recHasAutoCompleted) {
              const totalWatchedTime = calculateRecordingWatchedTime();
              const watchedPercentage = (totalWatchedTime / recVideoDuration) * 100;
              console.log(' Final recording watch percentage:', watchedPercentage.toFixed(2) + '%');
              
              // If we're close to 90% (within 10%), consider it complete
              // This handles edge cases where the last few seconds weren't tracked
              if (watchedPercentage >= REC_REQUIRED_PERCENTAGE - 10) {
                console.log(' Close enough to 90% - marking recording as complete');
                recHasAutoCompleted = true;
                autoCompleteRecording();
              }
            }
          });
        }
      } catch (e) {
        console.log('PlayerJS not available for recording:', e);
      }
    }
    
    function addRecordingWatchedSegment(start, end) {
      if (end <= start) return;
      
      // Add segment and merge overlapping
      recWatchedSegments.push({ start, end });
      recWatchedSegments.sort((a, b) => a.start - b.start);
      
      // Merge overlapping segments
      const merged = [];
      for (const seg of recWatchedSegments) {
        if (merged.length === 0) {
          merged.push({ ...seg });
        } else {
          const last = merged[merged.length - 1];
          if (seg.start <= last.end + 0.5) {
            last.end = Math.max(last.end, seg.end);
          } else {
            merged.push({ ...seg });
          }
        }
      }
      recWatchedSegments = merged;
    }
    
    function calculateRecordingWatchedTime() {
      let total = 0;
      for (const seg of recWatchedSegments) {
        total += (seg.end - seg.start);
      }
      return total;
    }
    
    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    }
    
    function updateRecordingProgressUI(percentage, currentTime) {
      // Update overlay elements
      const percentEl = document.getElementById('recWatchPercent');
      const timeEl = document.getElementById('recWatchTime');
      const circleEl = document.getElementById('recWatchCircle');
      const circleTextEl = document.getElementById('recWatchCircleText');
      const remainingEl = document.getElementById('recWatchRemaining');
      const maxSeekEl = document.getElementById('recMaxSeekTime');
      
      if (percentEl) percentEl.textContent = Math.round(percentage) + '%';
      if (timeEl) timeEl.textContent = `${formatTime(calculateRecordingWatchedTime())} / ${formatTime(recVideoDuration)}`;
      
      // Update circular progress
      if (circleEl) {
        const circumference = 125.6;
        const offset = circumference - (percentage / 100) * circumference;
        circleEl.style.strokeDashoffset = offset;
      }
      if (circleTextEl) circleTextEl.textContent = Math.round(percentage) + '%';
      
      // Update remaining percentage
      if (remainingEl) {
        const remaining = Math.max(0, REC_REQUIRED_PERCENTAGE - percentage);
        if (remaining > 0) {
          remainingEl.textContent = Math.round(remaining) + '%';
          remainingEl.style.color = '#ef4444';
        } else {
          remainingEl.textContent = 'Complete!';
          remainingEl.style.color = '#10b981';
        }
      }
      
      // Update max seek time indicator
      if (maxSeekEl) {
        maxSeekEl.textContent = formatTime(recMaxWatchedTime);
      }
      
      // Also update the non-overlay progress section
      const progressSection = document.getElementById('recordingWatchProgress');
      if (progressSection) {
        const barEl = document.getElementById('recordingWatchBar');
        const pctEl = document.getElementById('recordingWatchPercent');
        if (barEl) barEl.style.width = percentage + '%';
        if (pctEl) pctEl.textContent = Math.round(percentage) + '%';
      }
    }
    
    function autoCompleteRecording() {
      console.log(' Auto-completing recording for non-attendee');
      
      // Hide the overlay
      const overlay = document.getElementById('recordingWatchProgressOverlay');
      if (overlay) overlay.style.display = 'none';
      
      // Show side notification in top-left corner
      showRecordingCompletionNotification();
      
      // Update UI to show completing
      const requirementDiv = document.querySelector('.recording-watch-requirement');
      if (requirementDiv) {
        requirementDiv.innerHTML = `
          <div style="display: flex; align-items: center; gap: 10px; background: linear-gradient(135deg, #10b981, #059669); color: white; padding: 12px 16px; border-radius: 8px;">
            <i class="fas fa-check-circle" style="font-size: 1.3rem;"></i>
            <div>
              <strong>Watch Requirement Complete!</strong>
              <p style="margin: 0; font-size: 0.9rem; opacity: 0.9;">Saving your progress...</p>
            </div>
          </div>
        `;
      }
      
      // Clear localStorage since complete
      try {
        localStorage.removeItem(recStorageKey);
        console.log(' Cleared recording progress from localStorage');
      } catch (e) {}
      
      // Call the completion function
      updateContentProgressSmooth('completed', 100);
    }
    
    // Show side notification for recording completion
    function showRecordingCompletionNotification() {
      // Remove any existing notification
      const existing = document.getElementById('recCompletionNotification');
      if (existing) existing.remove();
      
      const notification = document.createElement('div');
      notification.id = 'recCompletionNotification';
      notification.innerHTML = `
        <div style="
          position: fixed;
          top: 20px;
          left: 20px;
          z-index: 10000;
          background: linear-gradient(135deg, #10b981, #059669);
          color: white;
          padding: 16px 24px;
          border-radius: 12px;
          box-shadow: 0 8px 25px rgba(16, 185, 129, 0.4);
          display: flex;
          align-items: center;
          gap: 12px;
          animation: slideInLeft 0.5s ease-out;
          max-width: 320px;
        ">
          <div style="
            width: 44px;
            height: 44px;
            background: rgba(255,255,255,0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
          ">
            <i class="fas fa-check-circle"></i>
          </div>
          <div>
            <strong style="display: block; font-size: 1rem; margin-bottom: 2px;">Recording Complete!</strong>
            <span style="font-size: 0.85rem; opacity: 0.9;">You've watched 90% of this recording.</span>
          </div>
          <button onclick="this.parentElement.remove()" style="
            position: absolute;
            top: 8px;
            right: 8px;
            background: transparent;
            border: none;
            color: rgba(255,255,255,0.7);
            cursor: pointer;
            font-size: 14px;
          "><i class="fas fa-times"></i></button>
        </div>
      `;
      document.body.appendChild(notification);
      
      // Add CSS animation
      if (!document.getElementById('recNotificationStyles')) {
        const style = document.createElement('style');
        style.id = 'recNotificationStyles';
        style.textContent = `
          @keyframes slideInLeft {
            from {
              opacity: 0;
              transform: translateX(-100%);
            }
            to {
              opacity: 1;
              transform: translateX(0);
            }
          }
        `;
        document.head.appendChild(style);
      }
      
      // Auto-remove after 6 seconds
      setTimeout(() => {
        if (notification.parentElement) {
          notification.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out';
          notification.style.opacity = '0';
          notification.style.transform = 'translateX(-20px)';
          setTimeout(() => notification.remove(), 300);
        }
      }, 6000);
    }


    // ==================== ZOOM MEETING FUNCTIONS ====================

    // Join Zoom Meeting - Works exactly like acknowledgeAndComplete for other content
    async function joinZoomMeeting() {
      try {
        const meetingId = '<%= contentItem.zoomMeeting ? contentItem.zoomMeeting._id : "" %>';

        if (!meetingId) {
          alert('Meeting ID not found');
          return;
        }

        // Show loading state - disable all join buttons
        const joinButtons = document.querySelectorAll('button[onclick*="joinZoomMeeting"], .btn-primary, .btn-outline-primary');
        joinButtons.forEach(btn => {
          if (!btn.disabled && (btn.textContent.includes('Join') || btn.onclick)) {
            btn.dataset.originalText = btn.innerHTML;
            btn.disabled = true;
            btn.style.opacity = '0.6';
            btn.style.cursor = 'not-allowed';
            btn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Joining...';
          }
        });

        // Get join URL and open meeting
        // Content will be automatically marked as completed when joining (handled in backend)
        try {
          const response = await fetch(`/zoom/student/zoom/${meetingId}/join`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
          });

          const data = await response.json();

          if (data.success) {
            // Record that the student attempted to join
            recordMeetingJoinAttempt(meetingId);

            // Content is automatically marked as completed in backend when joining
            // Update UI to reflect completion
            updateUIAfterCompletion();

            // Show modal with meeting details instead of popup (browsers may block popups)
            // Modal stays open until user closes it manually
            showMeetingInfoModal(data.meeting, data.student);

            // Show success notification
            showEnhancedNotification(
              'Meeting joined! Content marked as completed.',
              'success',
              'Success'
            );
          } else {
            // Re-enable buttons on error
            const joinButtons = document.querySelectorAll('button[onclick*="joinZoomMeeting"], .btn-primary, .btn-outline-primary');
            joinButtons.forEach(btn => {
              if (btn.dataset.originalText) {
                btn.innerHTML = btn.dataset.originalText;
                delete btn.dataset.originalText;
              }
              btn.disabled = false;
              btn.style.opacity = '1';
              btn.style.cursor = 'pointer';
            });
            alert('Could not get meeting details. Content is already marked as completed. Please refresh the page.');
          }
        } catch (joinError) {
          // Re-enable buttons on error
          const joinButtons = document.querySelectorAll('button[onclick*="joinZoomMeeting"], .btn-primary, .btn-outline-primary');
          joinButtons.forEach(btn => {
            if (btn.dataset.originalText) {
              btn.innerHTML = btn.dataset.originalText;
              delete btn.dataset.originalText;
            }
            btn.disabled = false;
            btn.style.opacity = '1';
            btn.style.cursor = 'pointer';
          });
          alert('Could not get meeting details. Content is already marked as completed. Please refresh the page to see updated navigation.');
        }

      } catch (error) {
        // Re-enable buttons on error
        const joinButtons = document.querySelectorAll('button[onclick*="joinZoomMeeting"], .btn-primary, .btn-outline-primary');
        joinButtons.forEach(btn => {
          if (btn.dataset.originalText) {
            btn.innerHTML = btn.dataset.originalText;
            delete btn.dataset.originalText;
          }
          btn.disabled = false;
          btn.style.opacity = '1';
          btn.style.cursor = 'pointer';
        });
        alert('Failed to join meeting. Please try again.');
      }
    }

    // Record meeting join attempt for analytics
    async function recordMeetingJoinAttempt(meetingId) {
      try {
        await fetch(`/zoom/student/zoom/${meetingId}/join-attempt`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
        });
      } catch (error) {
        // Could not record join attempt - silently handle
      }
    }
    // Update meeting status in UI
    function updateMeetingStatus(status) {
      const statusElement = document.querySelector('.meeting-status');
      if (statusElement) {
        switch (status) {
          case 'joining':
            statusElement.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Joining meeting...';
            statusElement.className = 'meeting-status text-info';
            break;
          case 'joined':
            statusElement.innerHTML = '<i class="fas fa-video"></i> In meeting';
            statusElement.className = 'meeting-status text-success';
            break;
          default:
            statusElement.innerHTML = '<i class="fas fa-clock"></i> Ready to join';
            statusElement.className = 'meeting-status text-muted';
        }
      }
    }

    // Show meeting info modal (without Bootstrap dependency)
    function showMeetingInfoModal(meeting, student) {
      const modalHtml = `
        <div class="modal-overlay" id="meetingInfoModal" onclick="closeMeetingModal()" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); z-index: 10000; display: flex; align-items: center; justify-content: center; animation: fadeIn 0.3s ease;">
          <div class="modal-content" onclick="event.stopPropagation()" style="background: white; border-radius: 15px; max-width: 600px; width: 90%; max-height: 90vh; overflow-y: auto; box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3); animation: slideUp 0.3s ease;">
            <div class="modal-header" style="padding: 20px; border-bottom: 2px solid #dc2626; display: flex; justify-content: space-between; align-items: center; background: linear-gradient(135deg, #dc2626, #b91c1c); border-radius: 15px 15px 0 0;">
              <h5 class="modal-title" style="margin: 0; color: white; font-weight: 700; font-size: 20px;">
                <i class="fas fa-video me-2"></i>
                Zoom Meeting Details
              </h5>
              <button type="button" class="btn-close" onclick="closeMeetingModal()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: white; padding: 5px 10px;">
                <i class="fas fa-times"></i>
              </button>
            </div>
            <div class="modal-body" style="padding: 30px;">
              <div style="text-align: center; margin-bottom: 30px;">
                <div style="font-size: 64px; color: #dc2626; margin-bottom: 15px;">
                  <i class="fas fa-video"></i>
                </div>
                <h4 style="color: #dc2626; margin-bottom: 8px; font-weight: 700; font-size: 24px;">${meeting.meetingName}</h4>
                <p style="color: #666; margin: 0; font-size: 16px;">${meeting.meetingTopic || 'Live Zoom Session'}</p>
              </div>

              <div style="background: linear-gradient(135deg, #e3f2fd, #bbdefb); padding: 20px; border-radius: 10px; border-left: 4px solid #2196f3; margin-bottom: 25px;">
                <div style="display: flex; align-items: start; gap: 12px;">
                  <i class="fas fa-info-circle" style="color: #2196f3; font-size: 22px; margin-top: 2px;"></i>
                  <div>
                    <strong style="color: #1976d2; display: block; margin-bottom: 8px; font-size: 15px;">Ready to Join:</strong>
                    <p style="margin: 0; color: #555; font-size: 14px; line-height: 1.7;">
                      Click the "Join Meeting" button below to join the live session. The meeting will open in a new window.
                    </p>
                  </div>
                </div>
              </div>

              <div style="text-align: center; color: #666; font-size: 14px; padding: 15px; background: #f8f9fa; border-radius: 8px; margin-bottom: 20px;">
                <i class="fas fa-user" style="margin-right: 8px;"></i>
                Joining as: <strong style="color: #333;">${student.name}</strong>
              </div>
            </div>
            <div class="modal-footer" style="padding: 25px; border-top: 2px solid #dc2626; display: flex; justify-content: center; gap: 15px; background: #f8f9fa;">
              <button type="button" class="btn btn-secondary" onclick="closeMeetingModal()" style="padding: 12px 25px; border-radius: 8px; border: 1px solid #ccc; background: white; cursor: pointer; color: #666; font-weight: 500;">
                Cancel
              </button>
              <a href="${meeting.joinUrl}" target="_blank" class="btn btn-primary" style="padding: 15px 40px; border-radius: 8px; background: linear-gradient(135deg, #dc2626, #b91c1c); color: white; text-decoration: none; font-weight: 700; display: inline-flex; align-items: center; gap: 10px; box-shadow: 0 4px 20px rgba(220, 38, 38, 0.4); font-size: 16px; transition: transform 0.2s;">
                <i class="fas fa-video" style="font-size: 18px;"></i>
                Join Meeting
              </a>
            </div>
          </div>
        </div>
      `;

      // Remove existing modal if any
      const existingModal = document.getElementById('meetingInfoModal');
      if (existingModal) {
        existingModal.remove();
      }

      // Add new modal
      document.body.insertAdjacentHTML('beforeend', modalHtml);

      // Show modal with animation
      const modal = document.getElementById('meetingInfoModal');
      modal.style.display = 'flex';
      setTimeout(() => {
        modal.classList.add('show');
      }, 10);
    }

    // Close meeting modal
    function closeMeetingModal() {
      const modal = document.getElementById('meetingInfoModal');
      if (modal) {
        modal.style.opacity = '0';
        setTimeout(() => {
          modal.remove();
          // Reload page after closing modal to show updated navigation (next content unlocked)
          location.reload();
        }, 300);
      }
    }

    // Copy to clipboard helper
    function copyToClipboard(text) {
      navigator.clipboard.writeText(text).then(() => {
        // Show temporary success message on button
        const btn = event.target.closest('button');
        if (btn) {
          const originalHtml = btn.innerHTML;
          btn.innerHTML = '<i class="fas fa-check"></i> Copied!';
          btn.style.background = '#10b981';
          btn.style.color = 'white';
          btn.style.borderColor = '#10b981';
          setTimeout(() => {
            btn.innerHTML = originalHtml;
            btn.style.background = '';
            btn.style.color = '';
            btn.style.borderColor = '';
          }, 2000);
        }
      }).catch(() => {
        alert('Could not copy to clipboard. Please copy manually.');
      });
    }
  </script>

  <!-- Zoom Meeting Styles -->
  <style>
    /* Enhanced Zoom Meeting Container */
    .zoom-meeting-container {
      background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
      border: 2px solid #dc2626;
      border-radius: 20px;
      box-shadow: 0 10px 30px rgba(220, 38, 38, 0.1);
      overflow: hidden;
      margin-bottom: 30px;
    }

    .meeting-info-card {
      background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
      color: white;
      padding: 30px;
      border-radius: 0;
      margin-bottom: 0;
      position: relative;
    }

    .meeting-info-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, #ffffff, #dc2626, #ffffff);
      opacity: 0.8;
    }

    .meeting-status-badge {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 10px 20px;
      border-radius: 25px;
      font-weight: 600;
      margin-bottom: 15px;
      background: rgba(255, 255, 255, 0.95);
      color: #dc2626;
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    }

    .status-scheduled {
      background: rgba(255, 255, 255, 0.95);
      color: #dc2626;
    }

    .status-active {
      background: rgba(255, 255, 255, 0.95);
      color: #dc2626;
      animation: statusPulse 2s infinite;
    }

    .status-ended {
      background: rgba(255, 255, 255, 0.95);
      color: #6b7280;
    }

    @keyframes statusPulse {

      0%,
      100% {
        box-shadow: 0 2px 8px rgba(220, 38, 38, 0.3);
      }

      50% {
        box-shadow: 0 4px 15px rgba(220, 38, 38, 0.6);
      }
    }

    .meeting-title {
      font-size: 28px;
      font-weight: 700;
      margin: 15px 0;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .meeting-topic {
      font-size: 16px;
      opacity: 0.95;
      margin: 10px 0;
      font-weight: 500;
    }

    .meeting-meta {
      display: flex;
      gap: 15px;
      margin-top: 25px;
      flex-wrap: wrap;
    }

    .meta-item {
      display: flex;
      align-items: center;
      gap: 8px;
      background: rgba(255, 255, 255, 0.15);
      padding: 10px 16px;
      border-radius: 12px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      font-weight: 500;
    }

    .meta-item i {
      color: rgba(255, 255, 255, 0.9);
    }

    /* Meeting Status Sections */
    .meeting-locked-section,
    .meeting-active-section,
    .meeting-ended-section {
      text-align: center;
      padding: 40px 30px;
      background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
      border-radius: 0;
      position: relative;
    }

    .meeting-locked-section::before,
    .meeting-active-section::before,
    .meeting-ended-section::before {
      content: '';
      position: absolute;
      top: 0;
      left: 20px;
      right: 20px;
      height: 1px;
      background: linear-gradient(90deg, transparent, #dc2626, transparent);
    }

    .locked-icon,
    .active-pulse,
    .ended-icon {
      font-size: 64px;
      margin-bottom: 20px;
    }

    .locked-icon {
      color: #dc2626;
    }

    .active-pulse {
      color: #dc2626;
      animation: pulse 2s infinite;
    }

    .ended-icon {
      color: #6b7280;
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: 1;
        transform: scale(1);
      }

      50% {
        opacity: 0.8;
        transform: scale(1.05);
      }
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }

    @keyframes slideUp {
      from {
        transform: translateY(50px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }

    .scheduled-time,
    .ended-time {
      font-size: 20px;
      font-weight: 600;
      color: #dc2626;
      margin: 20px 0;
      padding: 20px;
      background: #ffffff;
      border: 2px solid #dc2626;
      border-radius: 15px;
      box-shadow: 0 4px 15px rgba(220, 38, 38, 0.1);
      position: relative;
    }

    .scheduled-time::before,
    .ended-time::before {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      background: linear-gradient(45deg, #dc2626, #b91c1c, #dc2626);
      border-radius: 15px;
      z-index: -1;
    }

    /* Enhanced Join Button */
    .join-options {
      display: flex;
      justify-content: center;
      gap: 15px;
      flex-wrap: wrap;
      margin-top: 30px;
    }

    .join-options .btn {
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      border-radius: 25px;
      padding: 15px 30px;
      font-size: 16px;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .join-options .btn-primary {
      background: linear-gradient(135deg, #dc2626, #b91c1c);
      border: none;
      color: white;
      box-shadow: 0 4px 15px rgba(220, 38, 38, 0.3);
    }

    .join-options .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(220, 38, 38, 0.4);
      background: linear-gradient(135deg, #b91c1c, #991b1b);
    }

    .join-options .btn-primary::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.5s ease;
    }

    .join-options .btn-primary:hover::before {
      left: 100%;
    }

    .meeting-status {
      margin-top: 20px;
      padding: 15px;
      border-radius: 12px;
      background: #ffffff;
      border: 2px solid #dc2626;
      text-align: center;
      font-weight: 600;
      color: #dc2626;
    }

    .meeting-password {
      padding: 20px;
      background: #ffffff;
      border: 2px solid #dc2626;
      border-radius: 15px;
      text-align: center;
      margin-top: 20px;
      box-shadow: 0 4px 15px rgba(220, 38, 38, 0.1);
    }

    .meeting-password strong {
      color: #dc2626;
      font-weight: 700;
    }

    .meeting-password code {
      font-size: 18px;
      font-weight: 600;
      color: #dc2626;
      background: #f8f9fa;
      padding: 8px 20px;
      border-radius: 8px;
      margin-left: 10px;
      border: 1px solid #dc2626;
    }

    #meetingSDKElement {
      width: 100%;
      min-height: 600px;
      border-radius: 0;
      overflow: hidden;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .recording-available {
      padding: 24px;
      background: linear-gradient(135deg, #ffffff 0%, #fef2f2 100%);
      border: 2px solid #dc2626;
      border-radius: 16px;
      margin-top: 20px;
    }

    .recording-available h6 {
      color: #dc2626;
      font-weight: 700;
      margin-bottom: 15px;
    }

    .recording-available .btn-success {
      background: linear-gradient(135deg, #dc2626, #b91c1c);
      border: none;
      color: white;
      padding: 12px 25px;
      border-radius: 20px;
      font-weight: 600;
      transition: all 0.3s ease;
    }

    .recording-available .btn-success:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(220, 38, 38, 0.3);
    }

    /* Alert Styling */
    .alert-warning {
      background: #ffffff;
      border: 2px solid #dc2626;
      color: #dc2626;
      border-radius: 15px;
      padding: 20px;
      font-weight: 500;
    }

    .alert-warning i {
      color: #dc2626;
    }

    /* Dark theme adjustments */
    .dark-theme .zoom-meeting-container {
      background: linear-gradient(135deg, #1f2937 0%, #111827 100%);
      border-color: #dc2626;
    }

    .dark-theme .meeting-locked-section,
    .dark-theme .meeting-active-section,
    .dark-theme .meeting-ended-section {
      background: linear-gradient(135deg, #1f2937 0%, #111827 100%);
      color: #e5e7eb;
    }

    .dark-theme .scheduled-time,
    .dark-theme .ended-time {
      background: #1f2937;
      color: #dc2626;
      border-color: #dc2626;
    }

    .dark-theme .meeting-status {
      background: #1f2937;
      border-color: #dc2626;
      color: #dc2626;
    }

    .dark-theme .meeting-password {
      background: #1f2937;
      border-color: #dc2626;
    }

    .dark-theme .meeting-password strong {
      color: #dc2626;
    }

    .dark-theme .meeting-password code {
      background: #111827;
      color: #dc2626;
      border-color: #dc2626;
    }

    .dark-theme .recording-available {
      background: #1f2937;
      border-color: #dc2626;
    }

    .dark-theme .alert-warning {
      background: #1f2937;
      border-color: #dc2626;
      color: #dc2626;
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      .meeting-meta {
        flex-direction: column;
        gap: 10px;
      }

      .meta-item {
        justify-content: center;
      }

      .join-options {
        flex-direction: column;
      }

      .join-options .btn {
        width: 100%;
        margin-bottom: 10px;
      }

      .meeting-title {
        font-size: 24px;
      }

      .locked-icon,
      .active-pulse,
      .ended-icon {
        font-size: 48px;
      }
    }

    /* ==================== RECORDING PLAYER STYLES ==================== */
    .recording-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
      flex-wrap: wrap;
      gap: 12px;
    }

    .recording-badge {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: linear-gradient(135deg, #dc2626, #b91c1c);
      color: white;
      padding: 8px 16px;
      border-radius: 20px;
      font-weight: 600;
      font-size: 14px;
    }

    .recording-badge i {
      font-size: 16px;
    }

    .recording-progress-hint {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      color: #6b7280;
      font-size: 13px;
      background: #f3f4f6;
      padding: 6px 12px;
      border-radius: 15px;
    }

    .recording-completed-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: linear-gradient(135deg, #10b981, #059669);
      color: white;
      padding: 8px 16px;
      border-radius: 20px;
      font-weight: 600;
      font-size: 14px;
    }

    .recording-progress-container {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
      padding: 12px 16px;
      background: linear-gradient(135deg, #fef2f2, #fee2e2);
      border: 1px solid #fecaca;
      border-radius: 12px;
    }

    .recording-progress-bar {
      flex: 1;
      height: 8px;
      background: #e5e7eb;
      border-radius: 10px;
      overflow: hidden;
    }

    .recording-progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #dc2626, #f87171);
      border-radius: 10px;
      transition: width 0.3s ease;
    }

    .recording-progress-text {
      font-weight: 700;
      color: #dc2626;
      min-width: 45px;
      text-align: right;
      font-size: 14px;
    }

    .recording-player-wrapper {
      margin-bottom: 16px;
    }

    .recording-auto-complete-message {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      padding: 16px;
      background: linear-gradient(135deg, #dcfce7, #bbf7d0);
      border: 1px solid #86efac;
      border-radius: 12px;
      color: #166534;
      font-weight: 600;
      animation: pulse-success 2s infinite;
    }

    .recording-auto-complete-message i {
      font-size: 20px;
      color: #10b981;
    }

    @keyframes pulse-success {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.8; }
    }

    .recording-info {
      padding: 12px 16px;
      background: #f9fafb;
      border-radius: 10px;
      border: 1px solid #e5e7eb;
    }

    .recording-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
    }

    .recording-meta-item {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      color: #4b5563;
      font-size: 14px;
    }

    .recording-meta-item i {
      color: #dc2626;
    }

    /* Dark theme recording styles */
    .dark-theme .recording-progress-hint {
      background: #374151;
      color: #9ca3af;
    }

    .dark-theme .recording-progress-container {
      background: linear-gradient(135deg, #1f2937, #111827);
      border-color: #374151;
    }

    .dark-theme .recording-progress-bar {
      background: #374151;
    }

    .dark-theme .recording-info {
      background: #1f2937;
      border-color: #374151;
    }

    .dark-theme .recording-meta-item {
      color: #9ca3af;
    }

    .dark-theme .recording-auto-complete-message {
      background: linear-gradient(135deg, #064e3b, #065f46);
      border-color: #10b981;
      color: #a7f3d0;
    }

    /* Mark as Watched Button Section */
    .recording-mark-watched-section {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      padding: 20px;
      background: linear-gradient(135deg, #f0fdf4, #dcfce7);
      border: 1px solid #86efac;
      border-radius: 12px;
    }

    .recording-mark-watched-btn {
      padding: 14px 32px;
      font-size: 16px;
      font-weight: 600;
      border-radius: 50px;
      background: linear-gradient(135deg, #10b981, #059669);
      border: none;
      color: white;
      box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
      transition: all 0.3s ease;
    }

    .recording-mark-watched-btn:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4);
      background: linear-gradient(135deg, #059669, #047857);
    }

    .recording-mark-watched-btn:active:not(:disabled) {
      transform: translateY(0);
    }

    .recording-mark-watched-btn:disabled {
      background: #9ca3af;
      cursor: not-allowed;
      box-shadow: none;
    }

    .recording-mark-watched-hint {
      font-size: 13px;
      color: #059669;
      margin: 0;
      text-align: center;
    }

    .recording-mark-watched-hint i {
      color: #10b981;
    }

    /* Dark theme mark as watched styles */
    .dark-theme .recording-mark-watched-section {
      background: linear-gradient(135deg, #064e3b, #065f46);
      border-color: #10b981;
    }

    .dark-theme .recording-mark-watched-hint {
      color: #a7f3d0;
    }

    .dark-theme .recording-mark-watched-hint i {
      color: #6ee7b7;
    }

    /* ==================== VIDEO WATERMARK STYLES ==================== */
    .video-player-wrapper-with-watermark {
      position: relative;
      width: 100%;
    }

    .bunny-video-container-inner {
      position: relative;
      width: 100%;
    }

    .video-watermark {
      position: absolute;
      z-index: 1000;
      pointer-events: none;
      user-select: none;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 8px 16px;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(4px);
      border-radius: 8px;
      color: white;
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .video-watermark .watermark-text {
      color: #ffffff;
      font-weight: 600;
    }

    .video-watermark .watermark-separator {
      color: rgba(255, 255, 255, 0.6);
      margin: 0 4px;
    }

    .video-watermark .watermark-code {
      color: #fbbf24;
      font-weight: 700;
      font-family: 'Courier New', monospace;
    }

    /* Dynamic moving animation - moves around the video area */
    .video-watermark-moving {
      animation: watermarkMove 25s linear infinite;
    }

    @keyframes watermarkMove {
      0% {
        top: 8%;
        left: 8%;
        transform: translate(0, 0);
      }
      20% {
        top: 8%;
        left: 75%;
        transform: translate(-100%, 0);
      }
      40% {
        top: 75%;
        left: 75%;
        transform: translate(-100%, -100%);
      }
      60% {
        top: 75%;
        left: 8%;
        transform: translate(0, -100%);
      }
      80% {
        top: 40%;
        left: 40%;
        transform: translate(-50%, -50%);
      }
      100% {
        top: 8%;
        left: 8%;
        transform: translate(0, 0);
      }
    }

    /* MOBILE WATERMARK - VERY SMALL */
    @media (max-width: 768px) {
      .video-watermark,
      .video-watermark-moving,
      #recordingBunnyWatermark,
      #recordingYoutubeWatermark,
      #bunnyWatermark,
      #youtubeWatermark {
        font-size: 7px !important;
        padding: 3px 6px !important;
        gap: 3px !important;
        border-radius: 3px !important;
        background: rgba(0, 0, 0, 0.6) !important;
        backdrop-filter: none !important;
        box-shadow: none !important;
      }
      
      .video-watermark span,
      .video-watermark .watermark-text,
      .video-watermark .watermark-code,
      .video-watermark .watermark-separator {
        font-size: 7px !important;
      }
    }
    
    @media (max-width: 480px) {
      .video-watermark,
      .video-watermark-moving,
      #recordingBunnyWatermark,
      #recordingYoutubeWatermark,
      #bunnyWatermark,
      #youtubeWatermark {
        font-size: 6px !important;
        padding: 2px 4px !important;
        gap: 2px !important;
        border-radius: 2px !important;
      }
      
      .video-watermark span,
      .video-watermark .watermark-text,
      .video-watermark .watermark-code,
      .video-watermark .watermark-separator {
        font-size: 6px !important;
      }
    }

    /* Fullscreen watermark styles - injected dynamically */
    :fullscreen .video-watermark,
    :-webkit-full-screen .video-watermark,
    :-moz-full-screen .video-watermark,
    :-ms-fullscreen .video-watermark {
      position: fixed !important;
      z-index: 2147483647 !important;
      display: inline-flex !important;
      animation: watermarkMove 25s linear infinite !important;
    }

    /* Make wrapper fullscreen-able */
    .video-player-wrapper-with-watermark {
      position: relative;
    }

    /* Fullscreen iframe - let it behave naturally */
    iframe:fullscreen,
    iframe:-webkit-full-screen,
    iframe:-moz-full-screen,
    iframe:-ms-fullscreen {
      width: 100% !important;
      height: 100% !important;
      max-width: 100% !important;
      max-height: 100% !important;
    }

    /* Video player container fullscreen support */
    .video-player-container {
      position: relative;
      width: 100%;
    }

    .video-player-container:fullscreen,
    .video-player-container:-webkit-full-screen,
    .video-player-container:-moz-full-screen,
    .video-player-container:-ms-fullscreen {
      width: 100vw !important;
      height: 100vh !important;
      padding-top: 0 !important;
      background: #000;
    }

    .video-player-container:fullscreen iframe,
    .video-player-container:-webkit-full-screen iframe,
    .video-player-container:-moz-full-screen iframe,
    .video-player-container:-ms-fullscreen iframe,
    .video-player-container:fullscreen > div,
    .video-player-container:-webkit-full-screen > div,
    .video-player-container:-moz-full-screen > div,
    .video-player-container:-ms-fullscreen > div {
      position: absolute !important;
      top: 0 !important;
      left: 0 !important;
      width: 100vw !important;
      height: 100vh !important;
      max-width: 100vw !important;
      max-height: 100vh !important;
    }

    /* Mobile-specific video container fixes */
    @media (max-width: 768px) {
      .video-player-container {
        -webkit-overflow-scrolling: touch;
      }

      .video-player-container iframe,
      .video-player-container > div {
        max-width: 100%;
        max-height: 100%;
      }
    }

    /* Custom fullscreen button styles */
    .custom-fullscreen-btn {
      opacity: 0.8;
      transition: opacity 0.3s ease, transform 0.3s ease, background 0.3s ease;
    }

    .custom-fullscreen-btn:hover {
      opacity: 1;
    }

    .custom-fullscreen-btn:active {
      transform: scale(0.95) !important;
    }

    /* Show fullscreen button on video hover */
    .video-player-wrapper-with-watermark:hover .custom-fullscreen-btn {
      opacity: 1;
    }

    /* Dark theme watermark */
    .dark-theme .video-watermark {
      background: rgba(0, 0, 0, 0.85);
      border-color: rgba(255, 255, 255, 0.3);
    }

    /* Custom Modal Styles - Updated with Red Theme */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .modal-overlay.show {
      opacity: 1;
    }

    .modal-content {
      background: white;
      border: 2px solid #dc2626;
      border-radius: 15px;
      max-width: 500px;
      width: 90%;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 10px 30px rgba(220, 38, 38, 0.2);
      transform: scale(0.9);
      transition: transform 0.3s ease;
    }

    .modal-overlay.show .modal-content {
      transform: scale(1);
    }

    .modal-header {
      padding: 20px 20px 10px;
      border-bottom: 2px solid #dc2626;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: linear-gradient(135deg, #dc2626, #b91c1c);
      color: white;
      border-radius: 13px 13px 0 0;
    }

    .modal-title {
      margin: 0;
      font-size: 1.25rem;
      font-weight: 700;
      color: white;
    }

    .btn-close {
      background: rgba(255, 255, 255, 0.2);
      border: none;
      font-size: 1.2rem;
      color: white;
      cursor: pointer;
      padding: 8px;
      border-radius: 50%;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .btn-close:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    .modal-body {
      padding: 20px;
      background: white;
    }

    .modal-footer {
      padding: 10px 20px 20px;
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      background: white;
      border-radius: 0 0 13px 13px;
    }

    .alert {
      padding: 15px;
      border-radius: 10px;
      background-color: #ffffff;
      border: 2px solid #dc2626;
      color: #dc2626;
      font-weight: 500;
    }

    .alert i {
      margin-right: 8px;
      color: #dc2626;
    }

    .alert a {
      color: #dc2626;
      text-decoration: underline;
      font-weight: 600;
    }

    /* Dark theme modal */
    .dark-theme .modal-content {
      background: #1f2937;
      border-color: #dc2626;
    }

    .dark-theme .modal-body,
    .dark-theme .modal-footer {
      background: #1f2937;
      color: #e2e8f0;
    }

    .dark-theme .alert {
      background-color: #1f2937;
      border-color: #dc2626;
      color: #dc2626;
    }

    .dark-theme .alert a {
      color: #dc2626;
    }
  </style>
</body>

</html>