<%- include('./partials/admin-header', { pageCSS: 'question-banks', additionalJS: ['/js/question-bank.js'] }) %>

<!-- Chart.js CDN -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>

<!-- MathLive for professional math input -->
<script src="https://unpkg.com/mathlive"></script>


<!-- Admin Layout -->
<div class="admin-layout">

  <!-- Sidebar -->
  <%- include('./partials/admin-sidebar', { currentPage: 'question-banks' }) %>

  <!-- Main Content -->
  <main class="admin-main">

    <!-- Top Bar -->
    <%- include('./partials/admin-topbar', { 
        breadcrumb: 'Question Banks',
        breadcrumbSubtitle: questionBank.name,
        showSearch: true
    }) %>

    <!-- Content Area -->
    <div class="admin-content">
      <div class="admin-dashboard admin-fade-in">

        <!-- Bank Header -->
        <div class="admin-dashboard-header">
          <div class="d-flex justify-content-between align-items-center">
            <div>
              <div class="d-flex align-items-center mb-2">
                <a href="/admin/question-banks/banks" class="btn btn-outline-secondary btn-sm me-3">
                  <i class="fas fa-arrow-left me-1"></i>
                  Back to Banks
                </a>
                <div class="admin-status-badge admin-status-<%= questionBank.status %>">
                  <i class="fas fa-circle me-1"></i>
                  <%= questionBank.status.charAt(0).toUpperCase() + questionBank.status.slice(1) %>
                </div>
              </div>
              <h1 class="admin-dashboard-title"><%= questionBank.name %></h1>
              <p class="admin-dashboard-subtitle"><%= questionBank.description %></p>
            </div>
            <div class="admin-header-actions">
              <button class="btn btn-outline-primary me-2" data-bs-toggle="modal" data-bs-target="#editBankModal" onclick="openEditBankModal()">
                <i class="fas fa-edit me-2"></i>
                Edit Bank
              </button>
              <button class="btn btn-success me-2" onclick="exportQuestionBankToExcel()" id="exportBankBtn">
                <i class="fas fa-download me-2"></i>
                Export to Excel
              </button>
              <button class="btn btn-danger me-2" onclick="deleteQuestionBank('<%= questionBank.bankCode %>', '<%= questionBank.name %>')">
                <i class="fas fa-trash me-2"></i>
                Delete Bank
              </button>
              <button class="btn btn-primary admin-btn-primary" data-bs-toggle="modal" data-bs-target="#createQuestionModal">
                <i class="fas fa-plus me-2"></i>
                Add Question
              </button>
            </div>
          </div>
        </div>

        <!-- Bank Info Cards -->
        <div class="admin-stats-grid">
          <div class="admin-stat-card admin-slide-in">
            <div class="admin-stat-header">
              <div class="admin-stat-icon">
                <i class="fas fa-question-circle"></i>
              </div>
              <div class="admin-stat-trend positive">
                <i class="fas fa-arrow-up"></i>
                +5
              </div>
            </div>
            <h3 class="admin-stat-number"><%= questionStats.totalQuestions %></h3>
            <p class="admin-stat-label">Total Questions</p>
          </div>

          <div class="admin-stat-card admin-slide-in">
            <div class="admin-stat-header">
              <div class="admin-stat-icon">
                <i class="fas fa-check-circle text-success"></i>
              </div>
              <div class="admin-stat-trend positive">
                <i class="fas fa-arrow-up"></i>
                +2
              </div>
            </div>
            <h3 class="admin-stat-number"><%= questionStats.easyQuestions %></h3>
            <p class="admin-stat-label">Easy Questions</p>
          </div>

          <div class="admin-stat-card admin-slide-in">
            <div class="admin-stat-header">
              <div class="admin-stat-icon">
                <i class="fas fa-exclamation-circle text-warning"></i>
              </div>
              <div class="admin-stat-trend neutral">
                <i class="fas fa-minus"></i>
                0
              </div>
            </div>
            <h3 class="admin-stat-number"><%= questionStats.mediumQuestions %></h3>
            <p class="admin-stat-label">Medium Questions</p>
          </div>

          <div class="admin-stat-card admin-slide-in">
            <div class="admin-stat-header">
              <div class="admin-stat-icon">
                <i class="fas fa-times-circle text-danger"></i>
              </div>
              <div class="admin-stat-trend negative">
                <i class="fas fa-arrow-down"></i>
                -1
              </div>
            </div>
            <h3 class="admin-stat-number"><%= questionStats.hardQuestions %></h3>
            <p class="admin-stat-label">Hard Questions</p>
          </div>
        </div>

        <!-- Bank Details -->
        <div class="admin-content-section">
          <div class="row">
            <!-- Bank Information Card -->
            <div class="col-md-8">
              <div class="bank-info-card-modern">
                <div class="bank-info-header">
                  <div class="bank-info-header-bg"></div>
                  <div class="bank-info-header-content">
                    <div class="d-flex justify-content-between align-items-center">
                      <div>
                        <h5 class="bank-info-title">
                          <i class="fas fa-info-circle me-2"></i>
                          Bank Information
                        </h5>
                        <p class="bank-info-subtitle">Complete details about this question bank</p>
                      </div>
                      <div class="bank-info-status">
                        <span class="status-badge status-<%= questionBank.status %>">
                          <i class="fas fa-circle me-1"></i>
                          <%= questionBank.status.charAt(0).toUpperCase() + questionBank.status.slice(1) %>
                        </span>
                      </div>
                    </div>
                  </div>
                </div>

                <div class="bank-info-body">
                  <div class="row">
                    <div class="col-md-6">
                      <div class="info-item">
                        <div class="info-icon">
                          <i class="fas fa-barcode"></i>
                        </div>
                        <div class="info-content">
                          <label class="info-label">Bank Code</label>
                          <span class="info-value"><%= questionBank.bankCode %></span>
                        </div>
                      </div>

                      <div class="info-item">
                        <div class="info-icon">
                          <i class="fas fa-file-alt"></i>
                        </div>
                        <div class="info-content">
                          <label class="info-label">Test Type</label>
                          <span class="info-value"><%= questionBank.testType || 'Not specified' %></span>
                        </div>
                      </div>

                      <div class="info-item">
                        <div class="info-icon">
                          <i class="fas fa-calendar-plus"></i>
                        </div>
                        <div class="info-content">
                          <label class="info-label">Created Date</label>
                          <span class="info-value"><%= new Date(questionBank.createdAt).toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' }) %></span>
                        </div>
                      </div>
                    </div>

                    <div class="col-md-6">
                      <div class="info-item">
                        <div class="info-icon">
                          <i class="fas fa-clock"></i>
                        </div>
                        <div class="info-content">
                          <label class="info-label">Last Updated</label>
                          <span class="info-value"><%= new Date(questionBank.updatedAt).toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' }) %></span>
                        </div>
                      </div>

                      <div class="info-item">
                        <div class="info-icon">
                          <i class="fas fa-user"></i>
                        </div>
                        <div class="info-content">
                          <label class="info-label">Created By</label>
                          <span class="info-value"><%= questionBank.createdBy ? questionBank.createdBy.name || 'Admin' : 'System' %></span>
                        </div>
                      </div>
                    </div>
                  </div>

                  <% if (questionBank.tags && questionBank.tags.length > 0) { %>
                  <div class="info-tags-section" data-bank-tags="<%= questionBank.tags.join(',') %>">
                    <label class="info-label">
                      <i class="fas fa-tags me-2"></i>
                      Tags
                    </label>
                    <div class="info-tags">
                      <% questionBank.tags.forEach(tag => { %>
                      <span class="info-tag"><%= tag %></span>
                      <% }); %>
                    </div>
                  </div>
                  <% } %>
                </div>
              </div>
            </div>

            <!-- Question Distribution Chart -->
            <div class="col-md-4">
              <div class="chart-card-modern">
                <div class="chart-header">
                  <h5 class="chart-title">
                    <i class="fas fa-chart-pie me-2"></i>
                    Question Distribution
                  </h5>
                  <p class="chart-subtitle">Difficulty breakdown</p>
                </div>
                <div class="chart-body">
                  <div class="chart-container">
                    <canvas id="questionDistributionChart"></canvas>
                  </div>
                  <div class="chart-legend">
                    <div class="legend-item">
                      <span class="legend-color legend-easy"></span>
                      <span class="legend-label">Easy (<%= questionStats.easyQuestions %>)</span>
                    </div>
                    <div class="legend-item">
                      <span class="legend-color legend-medium"></span>
                      <span class="legend-label">Medium (<%= questionStats.mediumQuestions %>)</span>
                    </div>
                    <div class="legend-item">
                      <span class="legend-color legend-hard"></span>
                      <span class="legend-label">Hard (<%= questionStats.hardQuestions %>)</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Questions Section -->
        <div class="admin-content-section">
          <div class="questions-section-header">
            <div class="d-flex justify-content-between align-items-center">
              <div>
                <h3 class="questions-section-title">
                  <i class="fas fa-list me-2"></i>
                  Questions
                </h3>
                <p class="questions-section-subtitle">
                  <span id="questionsCount"><%= questionStats.totalQuestions %></span> questions in this bank
                </p>
              </div>
              <div class="questions-section-actions">
                <div class="search-box">
                  <i class="fas fa-search"></i>
                  <input type="text" id="questionSearch" placeholder="Search questions..." class="search-input">
                </div>
              </div>
            </div>
          </div>

          <!-- Advanced Search and Filters -->
          <div class="questions-search-section">
            <div class="search-container">
              <div class="search-input-group">
                <i class="fas fa-search search-icon"></i>
                <input type="text" id="questionsSearchInput" class="search-input" placeholder="Search questions by text, tags, or difficulty...">
                <button class="search-clear-btn" id="searchClearBtn" style="display: none;">
                  <i class="fas fa-times"></i>
                </button>
              </div>
            </div>

            <div class="filters-row">
              <div class="filter-group">
                <label class="filter-label">Difficulty</label>
                <select id="difficultyFilter" class="filter-select">
                  <option value="all">All Difficulty</option>
                  <option value="Easy">Easy</option>
                  <option value="Medium">Medium</option>
                  <option value="Hard">Hard</option>
                </select>
              </div>

              <div class="filter-group">
                <label class="filter-label">Sort By</label>
                <select id="sortFilter" class="filter-select">
                  <option value="createdAt">Date Created</option>
                  <option value="difficulty">Difficulty</option>
                  <option value="points">Points</option>
                </select>
              </div>

              <div class="filter-group">
                <label class="filter-label">Tags</label>
                <input type="text" id="tagsFilter" class="filter-input" placeholder="Filter by tags (comma-separated for multiple)...">
              
              </div>

              <div class="filter-group" style="display: flex; align-items: flex-end;">
                <button class="btn" onclick="openQuestionsSlider()" id="questionsSliderBtn" style="background: var(--admin-primary, #B80101); color: white; border: none; padding: 8px 16px; border-radius: 6px; font-weight: 500; transition: all 0.3s ease; white-space: nowrap; box-shadow: 0 2px 4px rgba(184, 1, 1, 0.2);" onmouseover="this.style.background='var(--admin-primary-dark, #8b0000)'; this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 8px rgba(184, 1, 1, 0.3)';" onmouseout="this.style.background='var(--admin-primary, #B80101)'; this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 4px rgba(184, 1, 1, 0.2)';">
                  <i class="fas fa-images me-2"></i>
                  Preview All Questions
                  <span class="badge bg-white text-danger ms-2" id="sliderBtnCount" style="color: var(--admin-primary, #B80101) !important;"><%= questions.length %></span>
                </button>
              </div>
            </div>

            <!-- Available Tags Section -->
            <div id="availableTagsSection" class="available-tags-section" style="display: none; margin-top: 15px; padding: 15px; background: #f8f9fa; border-radius: 8px; border: 1px solid #e9ecef;">
              <div class="d-flex justify-content-between align-items-center mb-2">
                <label class="filter-label mb-0">
                  <i class="fas fa-tags me-1"></i>
                  Available Tags (click to filter)
                </label>
                <button class="btn btn-sm btn-outline-secondary" id="clearTagsFilterBtn" style="display: none;">
                  <i class="fas fa-times me-1"></i>Clear Tags
                </button>
              </div>
              <div id="availableTagsContainer" class="d-flex flex-wrap gap-2">
                <!-- Tags will be populated here -->
              </div>
            </div>

            <!-- Filter Results Summary -->
            <div id="filterResultsSummary" class="filter-results-summary" style="display: none; margin-top: 15px; padding: 12px; background: #e0f2fe; border-radius: 8px; border: 1px solid #7dd3fc;">
              <i class="fas fa-filter me-2"></i>
              <span id="filterResultsText">Showing all questions</span>
            </div>
          </div>

          <!-- Bulk Actions Toolbar -->
          <div id="bulkActionsToolbar" class="bulk-actions-toolbar">
            <div class="bulk-actions-left">
              <button type="button" class="btn btn-bulk-toggle" id="toggleBulkModeBtn" onclick="toggleBulkSelectionMode()">
                <i class="fas fa-check-square me-2"></i>
                <span id="bulkModeText">Bulk Select</span>
              </button>
              
              <div id="bulkSelectionControls" class="bulk-selection-controls" style="display: none;">
                <div class="bulk-divider"></div>
                
                <button type="button" class="btn btn-bulk-action" onclick="selectAllQuestions()">
                  <i class="fas fa-check-double me-1"></i> Select All
                </button>
                
                <button type="button" class="btn btn-bulk-action" onclick="deselectAllQuestions()">
                  <i class="fas fa-times me-1"></i> Deselect All
                </button>
                
                <div class="bulk-divider"></div>
                
                <div class="bulk-select-by-tag">
                  <select id="bulkSelectByTag" class="bulk-select-dropdown" onchange="selectQuestionsByTag(this.value)">
                    <option value="">Select by Tag...</option>
                    <!-- Tags will be populated dynamically -->
                  </select>
                </div>
                
                <div class="bulk-select-by-numbers">
                  <input type="text" id="bulkSelectByNumbers" class="bulk-input" placeholder="e.g., 1,3,5-10" title="Enter question numbers (e.g., 1,3,5-10)">
                  <button type="button" class="btn btn-bulk-action" onclick="selectQuestionsByNumbers()">
                    <i class="fas fa-hashtag me-1"></i> Select
                  </button>
                </div>
              </div>
            </div>
            
            <div id="bulkActionsRight" class="bulk-actions-right" style="display: none;">
              <span class="bulk-selected-count">
                <i class="fas fa-check-circle me-1"></i>
                <span id="selectedCount">0</span> selected
              </span>
              
              <button type="button" class="btn btn-bulk-delete" onclick="showBulkDeleteConfirmation()">
                <i class="fas fa-trash-alt me-2"></i>
                Delete Selected
              </button>
            </div>
          </div>

          <!-- Questions Grid -->
          <div id="questionsContainer" class="questions-grid">
            <% if (questions && questions.length > 0) { %>
            <% questions.forEach((question, index) => { %>
            <div class="question-card-modern" data-question-id="<%= question._id %>" data-question-number="<%= index + 1 %>" data-difficulty="<%= question.difficulty %>" data-tags="<%= question.tags ? question.tags.join(',') : '' %>" data-points="<%= question.points %>" data-created-at="<%= question.createdAt %>">

              <div class="question-card-header">
                <!-- Bulk Selection Checkbox -->
                <div class="bulk-checkbox-wrapper" style="display: none;">
                  <label class="bulk-checkbox-label">
                    <input type="checkbox" class="bulk-question-checkbox" data-question-id="<%= question._id %>" onchange="handleQuestionCheckboxChange(this)">
                    <span class="bulk-checkbox-custom"></span>
                  </label>
                </div>
                
                <div class="question-number">
                  <span class="question-num"><%= index + 1 %></span>
                </div>
                <div class="question-actions">
                  <div class="dropdown">
                    <button class="btn btn-sm question-action-btn" data-bs-toggle="dropdown">
                      <i class="fas fa-ellipsis-v"></i>
                    </button>
                    <ul class="dropdown-menu question-dropdown">
                      <li>
                        <a class="dropdown-item" href="#" onclick="previewQuestion('<%= question._id %>')">
                          <i class="fas fa-eye me-2"></i>Preview Question
                        </a>
                      </li>
                      <li>
                        <a class="dropdown-item" href="#" onclick="editQuestion('<%= question._id %>')">
                          <i class="fas fa-edit me-2"></i>Edit Question
                        </a>
                      </li>
                      <li>
                        <hr class="dropdown-divider">
                      </li>
                      <li>
                        <a class="dropdown-item text-danger" href="#" onclick="deleteQuestion('<%= question._id %>', '<%= question.questionText.substring(0, 50) %>...')">
                          <i class="fas fa-trash me-2"></i>Delete
                        </a>
                      </li>
                    </ul>
                  </div>
                </div>
              </div>

              <div class="question-card-body">
                <div class="question-text-wrapper">
                  <h6 class="question-text-label">
                    <i class="fas fa-question-circle me-2"></i>Question:
                  </h6>
                  <div class="question-text-content">
                    <% 
                      const questionTextDisplay = question.questionText.length > 120 ? question.questionText.substring(0, 120) + '...' : question.questionText;
                      // Enhanced math detection - check for LaTeX markers and math patterns
                      const hasMath = question.questionText && (
                        question.questionText.includes('\\') || 
                        question.questionText.includes('$') || 
                        /[\^_\{\}]/.test(question.questionText) ||
                        /[α-ωΑ-Ωπ∞∫∑∏√≤≥≠≈]/.test(question.questionText)
                      );
                      // Escape HTML but preserve math content
                      const escapedText = questionTextDisplay
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;')
                        .replace(/"/g, '&quot;')
                        .replace(/'/g, '&#39;');
                    %>
                    <% if (hasMath) { %>
                      <math-field readonly 
                        class="question-math-field"
                        data-question-text="<%= escapedText %>">
                        <%= questionTextDisplay %>
                      </math-field>
                    <% } else { %>
                      <p class="question-text-plain"><%= questionTextDisplay %></p>
                    <% } %>
                  </div>
                </div>

                <div class="question-meta">
                  <div class="meta-item">
                    <span class="difficulty-badge difficulty-<%= question.difficulty.toLowerCase() %>">
                      <i class="fas fa-<%= question.difficulty === 'Easy' ? 'check-circle' : question.difficulty === 'Medium' ? 'exclamation-circle' : 'times-circle' %> me-1"></i>
                      <%= question.difficulty %>
                    </span>
                  </div>
                  <div class="meta-item">
                    <span class="question-type-badge <%= question.questionType.toLowerCase().replace('/', '-') %>">
                      <i class="fas fa-<%= question.questionType === 'Written' ? 'edit' : question.questionType === 'MCQ' ? 'list' : 'check-square' %> me-1"></i>
                      <%= question.questionType %>
                    </span>
                  </div>
                </div>

                <% if (question.tags && question.tags.length > 0) { %>
                <div class="question-tags">
                  <% question.tags.slice(0, 3).forEach(tag => { %>
                  <span class="question-tag"><%= tag %></span>
                  <% }); %>
                  <% if (question.tags.length > 3) { %>
                  <span class="question-tag question-tag-more">+<%= question.tags.length - 3 %></span>
                  <% } %>
                </div>
                <% } %>
              </div>

              <div class="question-card-footer">
                <div class="question-stats">
                  <span class="stat-item">
                    <i class="fas fa-calendar me-1"></i>
                    <%= new Date(question.createdAt).toLocaleDateString() %>
                  </span>
                </div>
              </div>
            </div>
            <% }); %>
            <% } else { %>
            <div class="questions-empty-state">
              <div class="empty-icon">
                <i class="fas fa-question-circle"></i>
              </div>
              <h3 class="empty-title">No Questions Found</h3>
              <p class="empty-description">
                Start building your question bank by adding your first question.
              </p>
              <button class="btn btn-primary" data-bs-toggle="modal" data-bs-target="#createQuestionModal">
                <i class="fas fa-plus me-2"></i>
                Add Your First Question
              </button>
            </div>
            <% } %>
          </div>
        </div>
      </div>
    </div>
  </main>
</div>

<!-- Edit Bank Modal -->
<div class="modal fade admin-modal" id="editBankModal" tabindex="-1">
  <div class="modal-dialog modal-lg">
    <div class="modal-content admin-modal-content">
      <div class="modal-header admin-modal-header">
        <h5 class="modal-title admin-modal-title">
          <i class="fas fa-edit me-2"></i>
          Edit Question Bank
        </h5>
        <button type="button" class="btn-close admin-btn-close" data-bs-dismiss="modal"></button>
      </div>

      <form id="editBankForm" class="admin-form">
        <div class="modal-body admin-modal-body">
          <div class="row">
            <div class="col-md-12">
              <div class="admin-form-group">
                <label for="editName" class="admin-form-label">Bank Name *</label>
                <input type="text" class="form-control admin-form-control" id="editName" name="name" value="<%= questionBank.name %>" required>
              </div>
            </div>
          </div>

          <div class="admin-form-group">
            <label for="editDescription" class="admin-form-label">Description (Optional)</label>
            <textarea class="form-control admin-form-control" id="editDescription" name="description" rows="3"><%= questionBank.description %></textarea>
          </div>

          <div class="row">
            <div class="col-md-6">
              <div class="admin-form-group">
                <label for="editTestType" class="admin-form-label">Test Type *</label>
                <select class="form-select admin-form-control" id="editTestType" name="testType" required>
                  <option value="">Select Test Type</option>
                  <option value="EST" <%= questionBank.testType === 'EST' ? 'selected' : '' %>>EST</option>
                  <option value="SAT" <%= questionBank.testType === 'SAT' ? 'selected' : '' %>>SAT</option>
                  <option value="ACT" <%= questionBank.testType === 'ACT' ? 'selected' : '' %>>ACT</option>
                  <option value="EST 2" <%= questionBank.testType === 'EST 2' ? 'selected' : '' %>>EST 2</option>
                  <option value="ACT 2" <%= questionBank.testType === 'ACT 2' ? 'selected' : '' %>>ACT 2</option>
                  <option value="Basics ACT" <%= questionBank.testType === 'Basics ACT' ? 'selected' : '' %>>Basics ACT</option>
                  <option value="Basics SAT & EST" <%= questionBank.testType === 'Basics SAT & EST' ? 'selected' : '' %>>Basics SAT & EST</option>
                </select>
              </div>
            </div>
            <div class="col-md-6">
              <div class="admin-form-group">
                <label for="editStatus" class="admin-form-label">Status</label>
                <select class="form-select admin-form-control" id="editStatus" name="status">
                  <option value="draft" <%= questionBank.status === 'draft' ? 'selected' : '' %>>Draft</option>
                  <option value="active" <%= questionBank.status === 'active' ? 'selected' : '' %>>Active</option>
                  <option value="archived" <%= questionBank.status === 'archived' ? 'selected' : '' %>>Archived</option>
                </select>
              </div>
            </div>
          </div>

          <div class="admin-form-group">
            <label for="editTags" class="admin-form-label">Tags</label>
            <input type="text" class="form-control admin-form-control" id="editTags" name="tags" value="<%= questionBank.tags ? questionBank.tags.join(', ') : '' %>" placeholder="Enter tags separated by commas">
          </div>
        </div>

        <div class="modal-footer admin-modal-footer">
          <button type="button" class="btn btn-secondary admin-btn-secondary" data-bs-dismiss="modal">
            Cancel
          </button>
          <button type="submit" class="btn btn-primary admin-btn-primary">
            <i class="fas fa-save me-2"></i>
            Update Bank
          </button>
        </div>
      </form>
    </div>
  </div>
</div>

<!-- Bulk Delete Confirmation Modal -->
<div class="modal fade" id="bulkDeleteModal" tabindex="-1" data-bs-backdrop="static">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <div class="modal-header bg-danger text-white">
        <h5 class="modal-title">
          <i class="fas fa-exclamation-triangle me-2"></i>
          Confirm Bulk Delete
        </h5>
        <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
      </div>
      <div class="modal-body">
        <div class="bulk-delete-warning">
          <div class="warning-icon">
            <i class="fas fa-trash-alt"></i>
          </div>
          <h4>You are about to delete <span id="bulkDeleteCount" class="text-danger fw-bold">0</span> questions</h4>
          <p class="text-muted mb-4">This action cannot be undone. Please review the questions below before confirming.</p>
        </div>
        
        <div class="bulk-delete-questions-list">
          <div class="list-header d-flex justify-content-between align-items-center mb-3">
            <h6 class="mb-0">
              <i class="fas fa-list me-2"></i>Questions to be deleted:
            </h6>
            <span class="badge bg-danger" id="bulkDeleteListCount">0 questions</span>
          </div>
          <div id="bulkDeleteQuestionsList" class="questions-to-delete">
            <!-- Questions will be populated here -->
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
          <i class="fas fa-times me-2"></i>Cancel
        </button>
        <button type="button" class="btn btn-danger" id="confirmBulkDeleteBtn" onclick="executeBulkDelete()">
          <i class="fas fa-trash-alt me-2"></i>
          Delete <span id="confirmDeleteCount">0</span> Questions
        </button>
      </div>
    </div>
  </div>
</div>

<!-- Questions Slider Modal -->
<div class="modal fade" id="questionsSliderModal" tabindex="-1" data-bs-backdrop="static" data-bs-keyboard="false">
  <div class="modal-dialog modal-fullscreen">
    <div class="modal-content" style="background: #000000;">
      <div class="modal-header" style="background: rgba(0, 0, 0, 0.9); border-bottom: 1px solid rgba(255, 255, 255, 0.1); padding: 15px 30px;">
        <div class="d-flex align-items-center justify-content-between w-100">
          <h5 class="modal-title text-white mb-0">
            <i class="fas fa-images me-2"></i>
            Questions Preview
            <span class="badge bg-primary ms-2" id="sliderQuestionCounter">0 / 0</span>
          </h5>
          <div class="d-flex align-items-center gap-3">
            <span class="text-white-50" style="font-size: 13px;" id="sliderFilterInfo"></span>
            <button type="button" class="btn btn-sm btn-outline-light" data-bs-dismiss="modal">
              <i class="fas fa-times me-1"></i> Close
            </button>
          </div>
        </div>
      </div>
      
      <div class="modal-body p-0" style="background: #000000; position: relative; overflow: hidden;">
        <!-- Navigation Arrows -->
        <button class="slider-nav-btn slider-prev" id="sliderPrevBtn" onclick="navigateSlider(-1)">
          <i class="fas fa-chevron-left"></i>
        </button>
        <button class="slider-nav-btn slider-next" id="sliderNextBtn" onclick="navigateSlider(1)">
          <i class="fas fa-chevron-right"></i>
        </button>
        
        <!-- Slider Container -->
        <div id="questionsSliderContainer" class="questions-slider-container">
          <!-- Slides will be dynamically inserted here -->
        </div>
        
        <!-- Bottom Controls -->
        <div class="slider-controls">
          <div class="d-flex align-items-center justify-content-between w-100">
            <div class="d-flex align-items-center gap-3">
              <button class="btn btn-outline-light btn-sm" onclick="navigateSlider(-1)">
                <i class="fas fa-chevron-left me-1"></i> Previous
              </button>
              <button class="btn btn-outline-light btn-sm" onclick="navigateSlider(1)">
                Next <i class="fas fa-chevron-right ms-1"></i>
              </button>
            </div>
            
            <div class="slider-dots" id="sliderDots">
              <!-- Dots will be dynamically inserted here -->
            </div>
            
            <div class="d-flex align-items-center gap-2">
              <button class="btn btn-warning btn-sm" id="sliderEditBtn" onclick="editCurrentSlideQuestion()" style="display: none;">
                <i class="fas fa-edit me-1"></i> Edit This Question
              </button>
              <button class="btn btn-danger btn-sm" id="sliderDeleteBtn" onclick="deleteCurrentSlideQuestion()" style="display: none;">
                <i class="fas fa-trash me-1"></i> Delete
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Create Question Modal -->
<div class="modal fade admin-modal" id="createQuestionModal" tabindex="-1">
  <div class="modal-dialog modal-xl">
    <div class="modal-content admin-modal-content">
      <div class="modal-header admin-modal-header">
        <h5 class="modal-title admin-modal-title">
          <i class="fas fa-plus me-2"></i>
          Add New Question
        </h5>
        <button type="button" class="btn-close admin-btn-close" data-bs-dismiss="modal"></button>
      </div>

      <form action="/admin/question-banks/banks/<%= questionBank.bankCode %>/questions/create" method="POST" class="admin-form" id="createQuestionForm">
        <!-- Hidden field for question text to ensure it's sent to backend -->
        <input type="hidden" name="questionText" id="hiddenQuestionText" value="">
        <div class="modal-body admin-modal-body">
          <div class="row">
            <div class="col-md-8">
              <div class="admin-form-group">
                <label for="questionText" class="admin-form-label">
                  Question Text *
                  <button type="button" class="btn btn-sm btn-outline-primary ms-2" data-bs-toggle="collapse" data-bs-target="#mathEditorCollapse-questionText" aria-expanded="false" aria-controls="mathEditorCollapse-questionText" onclick="initMathEditor('questionText')" title="Toggle Math Editor with Virtual Keyboard">
                    <i class="fas fa-calculator"></i> Math Editor
                  </button>
                </label>
                <!-- Collapsible Math Editor -->
                <div class="collapse mt-2 mb-3" id="mathEditorCollapse-questionText">
                  <div class="card card-body" style="background: #f8f9fa; border: 1px solid #dee2e6;">
                    <div class="admin-form-group mb-3">
                      <label class="admin-form-label">Enter Math Expression</label>
                      <math-field 
                        id="mathEditorField-questionText" 
                        virtual-keyboard-mode="manual"
                        style="width: 100%; min-height: 80px; font-size: 16px; border: 1px solid #ced4da; border-radius: 4px; padding: 10px; background: #fff;">
                      </math-field>
                      <small class="admin-form-text">Use the keyboard icon on the right to open the virtual keyboard with all math symbols.</small>
                    </div>
                    <div class="admin-form-group mb-3">
                      <label class="admin-form-label">Preview</label>
                      <div id="mathEditorPreview-questionText" style="padding: 10px; border: 1px solid #dee2e6; border-radius: 4px; background: #fff; min-height: 50px;">
                        Preview will appear here...
                      </div>
                    </div>
                    <button type="button" class="btn btn-primary btn-sm" onclick="insertMathExpression('questionText')">
                      <i class="fas fa-plus me-2"></i>Insert Math Expression
                    </button>
                  </div>
                </div>
                <textarea class="form-control admin-form-control" id="questionText" name="questionText" rows="4" placeholder="Enter your question here... Use $...$ for math expressions, e.g., If $x^2 + 3 = 2x - 2$, what is the value of $x - 4$?" maxlength="1000" required></textarea>
                <small class="admin-form-text">Question must be between 10 and 1000 characters. Wrap math expressions in dollar signs: $x^2 + 3 = 2x - 2$. Click "Math Editor" for a full virtual keyboard.</small>
                <div class="invalid-feedback" id="questionTextError"></div>
              </div>

              <!-- Question Image Upload Section -->
              <div class="admin-form-group">
                <label class="admin-form-label">
                  <i class="fas fa-image me-2"></i>
                  Question Image (Optional)
                </label>
                <div class="upload-section">
                  <input type="file" id="questionImageFile" class="upload-input" accept="image/*">
                  <label for="questionImageFile" class="upload-label">
                    <i class="fas fa-cloud-upload-alt"></i>
                    Choose Question Image
                  </label>
                  <div id="questionImagePreview" class="upload-preview">
                    <div class="preview-overlay">
                      <i class="fas fa-cloud-upload-alt"></i>
                      <p>Click or drag to upload</p>
                      <small>JPEG, PNG, JPG, WebP (max 10MB)</small>
                    </div>
                  </div>
                  <div id="questionImageProgress" class="progress-container" style="display: none;"></div>
                </div>
                <input type="hidden" name="questionImage" id="questionImageUrl">
              </div>

              <div class="admin-form-group">
                <label for="questionType" class="admin-form-label">Question Type *</label>
                <select class="form-select admin-form-control" id="questionType" name="questionType" required onchange="handleQuestionTypeChange()">
                  <option value="">Select Question Type</option>
                  <option value="MCQ">Multiple Choice Question (MCQ)</option>
                  <option value="True/False">True/False Question</option>
                  <option value="Written">Written Question</option>
                </select>
                <small class="admin-form-text">Choose the type of question you want to create</small>
              </div>

              <div class="admin-form-group" id="answerOptionsSection" style="display: none;">
                <label class="admin-form-label">Answer Options *</label>
                <div class="options-container-wrapper">
                  <div id="optionsContainer" class="options-container">
                    <!-- Options will be populated dynamically -->
                  </div>
                  <button type="button" class="btn btn-outline-primary btn-sm add-option-btn" id="addOptionBtn" onclick="addOption()" style="display: none;">
                    <i class="fas fa-plus me-1"></i>
                    Add Option
                  </button>
                </div>
                <div class="invalid-feedback" id="optionsError"></div>
              </div>

              <!-- Written Question Answers Section -->
              <div class="admin-form-group" id="writtenAnswersSection" style="display: none;">
                <label class="admin-form-label">Answer Type *</label>
                <div class="answer-type-selector">
                  <div class="answer-type-option">
                    <input class="answer-type-radio" type="radio" name="answerMultiplicity" id="singleAnswer" value="single" checked>
                    <label class="answer-type-label" for="singleAnswer">
                      <div class="answer-type-icon">
                        <i class="fas fa-check-circle"></i>
                      </div>
                      <div class="answer-type-content">
                        <h6 class="answer-type-title">Single Answer</h6>
                        <p class="answer-type-description">Student must provide exactly one correct answer</p>
                        <div class="answer-type-badge">
                          <span class="badge bg-primary">Recommended</span>
                        </div>
                      </div>
                    </label>
                  </div>

                  <div class="answer-type-option">
                    <input class="answer-type-radio" type="radio" name="answerMultiplicity" id="multipleAnswers" value="multiple">
                    <label class="answer-type-label" for="multipleAnswers">
                      <div class="answer-type-icon">
                        <i class="fas fa-list-check"></i>
                      </div>
                      <div class="answer-type-content">
                        <h6 class="answer-type-title">Multiple Answers</h6>
                        <p class="answer-type-description">Student can provide multiple correct answers</p>
                        <div class="answer-type-badge">
                          <span class="badge bg-info">Advanced</span>
                        </div>
                      </div>
                    </label>
                  </div>
                </div>

                <label class="admin-form-label mt-3">Correct Answers *</label>
                <div class="written-answers-container">
                  <div id="correctAnswersContainer" class="correct-answers-container">
                    <!-- Correct answers will be populated dynamically -->
                  </div>
                  <button type="button" class="btn btn-outline-primary btn-sm" id="addAnswerBtn" onclick="addCorrectAnswer()" style="display: none;">
                    <i class="fas fa-plus me-1"></i>
                    Add Answer
                  </button>
                </div>
                <small class="admin-form-text">Add correct answers. For single answer type, provide exactly one answer.</small>
                <div class="invalid-feedback" id="writtenAnswersError"></div>
              </div>

              <div class="admin-form-group">
                <label for="explanation" class="admin-form-label">Explanation (Optional)</label>
                <textarea class="form-control admin-form-control" id="explanation" name="explanation" rows="2" placeholder="Explain why this is the correct answer..."></textarea>
              </div>
            </div>

            <div class="col-md-4">
              <div class="admin-form-group">
                <label for="difficulty" class="admin-form-label">Difficulty *</label>
                <select class="form-select admin-form-control" id="difficulty" name="difficulty" required>
                  <option value="">Select Difficulty</option>
                  <option value="Easy">Easy</option>
                  <option value="Medium">Medium</option>
                  <option value="Hard">Hard</option>
                </select>
              </div>

              <div class="admin-form-group">
                <label for="points" class="admin-form-label">Points</label>
                <input type="number" class="form-control admin-form-control" id="points" name="points" value="1" min="1" max="10">
              </div>


              <div class="admin-form-group">
                <label for="tags" class="admin-form-label">
                  Tags
                  <span class="badge bg-success ms-2" style="font-size: 9px; font-weight: 500;">
                    <i class="fas fa-mouse-pointer"></i> Click to remove
                  </span>
                </label>
                <input type="text" class="form-control admin-form-control" id="tags" name="tags" placeholder="Enter tags separated by commas">
                <small class="form-text text-muted" id="createTagsHelp" style="display: block; margin-top: 5px;">
                  <i class="fas fa-info-circle"></i> Separate multiple tags with commas. Tags will appear below for easy removal.
                </small>
                <div id="createTagsPreview" class="mt-2" style="display: none;">
                  <!-- Tag preview will be shown here -->
                </div>

                <!-- Previous Tags Selection -->
                <div id="createPreviousTagsSection" style="display: none;">
                  <label class="admin-form-label mt-3">Previous Tags</label>
                  <div id="createPreviousTagsContainer" class="previous-tags-container">
                    <!-- Previous tags will be populated here -->
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div class="modal-footer admin-modal-footer">
          <button type="button" class="btn btn-secondary admin-btn-secondary" data-bs-dismiss="modal">
            Cancel
          </button>
          <button type="submit" class="btn btn-primary admin-btn-primary">
            <i class="fas fa-save me-2"></i>
            Create Question
          </button>
        </div>
      </form>
    </div>
  </div>
</div>

<!-- Question Preview Modal -->
<div class="modal fade question-preview-modal" id="questionPreviewModal" tabindex="-1">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">
          <i class="fas fa-eye me-2"></i>
          Question Preview
        </h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
      </div>

      <div class="question-preview-content">
        <div class="question-preview-header">
          <h3 class="question-preview-title" id="previewQuestionTitle">Question Preview</h3>
          <div class="question-preview-meta">
            <span class="question-preview-difficulty" id="previewDifficulty">Medium</span>
            <span class="question-preview-points" id="previewPoints">5 pts</span>
          </div>
        </div>

        <div class="question-preview-text" id="previewQuestionText">
          Question text will appear here...
        </div>

        <div class="question-preview-image" id="previewQuestionImage" style="display: none;">
          <img src="" alt="Question Image" id="previewImageSrc">
        </div>

        <div class="question-preview-options">
          <div class="question-preview-options-title">Answer Options:</div>
          <div id="previewOptionsContainer">
            <!-- Options will be populated dynamically -->
          </div>
        </div>

        <div class="question-preview-explanation" id="previewExplanation" style="display: none;">
          <div class="question-preview-explanation-title">
            <i class="fas fa-lightbulb"></i>
            Explanation
          </div>
          <div class="question-preview-explanation-text" id="previewExplanationText">
            Explanation will appear here...
          </div>
        </div>

        <div class="question-preview-tags" id="previewTags" style="display: none;">
          <!-- Tags will be populated dynamically -->
        </div>

        <div class="question-preview-footer">
          <div class="question-preview-info">
            <small>
              <i class="fas fa-calendar me-1"></i>
              Created: <span id="previewCreatedDate">-</span>
            </small>
          </div>
          <div class="question-preview-actions">
            <button class="btn btn-preview-close" data-bs-dismiss="modal">
              <i class="fas fa-times me-1"></i>
              Close
            </button>
            <a href="#" class="btn btn-preview-action btn-preview-edit" id="previewEditBtn">
              <i class="fas fa-edit me-1"></i>
              Edit Question
            </a>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Edit Question Modal -->
<div class="modal fade admin-modal" id="editQuestionModal" tabindex="-1">
  <div class="modal-dialog modal-xl">
    <div class="modal-content admin-modal-content">
      <div class="modal-header admin-modal-header">
        <h5 class="modal-title admin-modal-title">
          <i class="fas fa-edit me-2"></i>
          Edit Question
          <span id="editQuestionTagsBadge" class="badge bg-primary ms-2" style="display: none; font-size: 11px; font-weight: 600;">
            <i class="fas fa-tags me-1"></i>
            <span id="editQuestionTagsCount">0</span> tags
          </span>
        </h5>
        <button type="button" class="btn-close admin-btn-close" data-bs-dismiss="modal"></button>
      </div>

      <form id="editQuestionForm" method="POST" class="admin-form">
        <input type="hidden" name="_method" value="PUT">
        <!-- Hidden field for question text to ensure it's sent to backend -->
        <input type="hidden" name="questionText" id="editHiddenQuestionText" value="">
        <div class="modal-body admin-modal-body">
          <!-- Loading State -->
          <div id="editQuestionLoader" class="text-center py-5" style="display: none;">
            <div class="spinner-border text-primary" role="status" style="width: 3rem; height: 3rem;">
              <span class="visually-hidden">Loading...</span>
            </div>
            <p class="mt-3 text-muted">Loading question data...</p>
          </div>
          <!-- Form Content -->
          <div id="editQuestionFormContent" style="display: block;">
          <div class="row">
            <div class="col-md-8">
              <div class="admin-form-group">
                <label for="editQuestionText" class="admin-form-label">
                  Question Text *
                  <button type="button" class="btn btn-sm btn-outline-primary ms-2" data-bs-toggle="collapse" data-bs-target="#mathEditorCollapse-editQuestionText" aria-expanded="false" aria-controls="mathEditorCollapse-editQuestionText" onclick="initMathEditor('editQuestionText')" title="Toggle Math Editor with Virtual Keyboard">
                    <i class="fas fa-calculator"></i> Math Editor
                  </button>
                </label>
                <!-- Collapsible Math Editor -->
                <div class="collapse mt-2 mb-3" id="mathEditorCollapse-editQuestionText">
                  <div class="card card-body" style="background: #f8f9fa; border: 1px solid #dee2e6;">
                    <div class="admin-form-group mb-3">
                      <label class="admin-form-label">Enter Math Expression</label>
                      <math-field 
                        id="mathEditorField-editQuestionText" 
                        virtual-keyboard-mode="manual"
                        style="width: 100%; min-height: 80px; font-size: 16px; border: 1px solid #ced4da; border-radius: 4px; padding: 10px; background: #fff;">
                      </math-field>
                      <small class="admin-form-text">Use the keyboard icon on the right to open the virtual keyboard with all math symbols.</small>
                    </div>
                    <div class="admin-form-group mb-3">
                      <label class="admin-form-label">Preview</label>
                      <div id="mathEditorPreview-editQuestionText" style="padding: 10px; border: 1px solid #dee2e6; border-radius: 4px; background: #fff; min-height: 50px;">
                        Preview will appear here...
                      </div>
                    </div>
                    <button type="button" class="btn btn-primary btn-sm" onclick="insertMathExpression('editQuestionText')">
                      <i class="fas fa-plus me-2"></i>Insert Math Expression
                    </button>
                  </div>
                </div>
                <textarea class="form-control admin-form-control" id="editQuestionText" name="questionText" rows="4" placeholder="Enter your question here... Use $...$ for math expressions, e.g., If $x^2 + 3 = 2x - 2$, what is the value of $x - 4$?" maxlength="1000" required></textarea>
                <small class="admin-form-text">Question must be between 10 and 1000 characters. Wrap math expressions in dollar signs: $x^2 + 3 = 2x - 2$. Click "Math Editor" for a full virtual keyboard.</small>
                <div class="invalid-feedback" id="editQuestionTextError"></div>
              </div>

              <!-- Edit Question Image Upload Section -->
              <div class="admin-form-group">
                <label class="admin-form-label">
                  <i class="fas fa-image me-2"></i>
                  Question Image (Optional)
                </label>
                <div class="upload-section">
                  <input type="file" id="editQuestionImageFile" class="upload-input" accept="image/*">
                  <label for="editQuestionImageFile" class="upload-label">
                    <i class="fas fa-cloud-upload-alt"></i>
                    Choose Question Image
                  </label>
                  <div id="editQuestionImagePreview" class="upload-preview">
                    <div class="preview-overlay">
                      <i class="fas fa-cloud-upload-alt"></i>
                      <p>Click or drag to upload</p>
                      <small>JPEG, PNG, JPG, WebP (max 10MB)</small>
                    </div>
                  </div>
                  <div id="editQuestionImageProgress" class="progress-container" style="display: none;"></div>
                  <!-- Image action buttons (shown when image exists) -->
                  <div id="editQuestionImageActions" class="image-actions mt-2" style="display: none;">
                    <button type="button" class="btn btn-outline-danger btn-sm" onclick="removeEditQuestionImage()">
                      <i class="fas fa-trash-alt me-1"></i> Remove Image
                    </button>
                    <button type="button" class="btn btn-outline-primary btn-sm ms-2" onclick="document.getElementById('editQuestionImageFile').click()">
                      <i class="fas fa-exchange-alt me-1"></i> Change Image
                    </button>
                  </div>
                </div>
                <input type="hidden" name="questionImage" id="editQuestionImageUrl">
              </div>

              <div class="admin-form-group">
                <label for="editQuestionType" class="admin-form-label">Question Type *</label>
                <select class="form-select admin-form-control" id="editQuestionType" name="questionType" required onchange="handleEditQuestionTypeChange()">
                  <option value="">Select Question Type</option>
                  <option value="MCQ">Multiple Choice Question (MCQ)</option>
                  <option value="True/False">True/False Question</option>
                  <option value="Written">Written Question</option>
                </select>
                <small class="admin-form-text">Choose the type of question you want to create</small>
              </div>

              <div class="admin-form-group" id="editAnswerOptionsSection" style="display: none;">
                <label class="admin-form-label">Answer Options *</label>
                <div class="options-container-wrapper">
                  <div id="editOptionsContainer" class="options-container">
                    <!-- Options will be populated dynamically -->
                  </div>
                  <button type="button" class="btn btn-outline-primary btn-sm add-option-btn" id="editAddOptionBtn" onclick="addEditOption()" style="display: none;">
                    <i class="fas fa-plus me-1"></i>
                    Add Option
                  </button>
                </div>
                <div class="invalid-feedback" id="editOptionsError"></div>
              </div>

              <!-- Edit Written Question Answers Section -->
              <div class="admin-form-group" id="editWrittenAnswersSection" style="display: none;">
                <label class="admin-form-label">Answer Type *</label>
                <div class="answer-type-selector">
                  <div class="answer-type-option">
                    <input class="answer-type-radio" type="radio" name="editAnswerMultiplicity" id="editSingleAnswer" value="single">
                    <label class="answer-type-label" for="editSingleAnswer">
                      <div class="answer-type-icon">
                        <i class="fas fa-check-circle"></i>
                      </div>
                      <div class="answer-type-content">
                        <h6 class="answer-type-title">Single Answer</h6>
                        <p class="answer-type-description">Student must provide exactly one correct answer</p>
                        <div class="answer-type-badge">
                          <span class="badge bg-primary">Recommended</span>
                        </div>
                      </div>
                    </label>
                  </div>

                  <div class="answer-type-option">
                    <input class="answer-type-radio" type="radio" name="editAnswerMultiplicity" id="editMultipleAnswers" value="multiple">
                    <label class="answer-type-label" for="editMultipleAnswers">
                      <div class="answer-type-icon">
                        <i class="fas fa-list-check"></i>
                      </div>
                      <div class="answer-type-content">
                        <h6 class="answer-type-title">Multiple Answers</h6>
                        <p class="answer-type-description">Student can provide multiple correct answers</p>
                        <div class="answer-type-badge">
                          <span class="badge bg-info">Advanced</span>
                        </div>
                      </div>
                    </label>
                  </div>
                </div>

                <label class="admin-form-label mt-3">Correct Answers *</label>
                <div class="written-answers-container">
                  <div id="editCorrectAnswersContainer" class="correct-answers-container">
                    <!-- Correct answers will be populated dynamically -->
                  </div>
                  <button type="button" class="btn btn-outline-primary btn-sm" id="editAddAnswerBtn" onclick="addEditCorrectAnswer()" style="display: none;">
                    <i class="fas fa-plus me-1"></i>
                    Add Answer
                  </button>
                </div>
                <small class="admin-form-text">Add correct answers. For single answer type, provide exactly one answer.</small>
                <div class="invalid-feedback" id="editWrittenAnswersError"></div>

                <!-- Removed: Answer type/case sensitive/partial credit controls (edit) -->
              </div>

              <div class="admin-form-group">
                <label for="editExplanation" class="admin-form-label">Explanation (Optional)</label>
                <textarea class="form-control admin-form-control" id="editExplanation" name="explanation" rows="2" placeholder="Explain why this is the correct answer..."></textarea>
              </div>
            </div>

            <div class="col-md-4">
              <div class="admin-form-group">
                <label for="editDifficulty" class="admin-form-label">Difficulty *</label>
                <select class="form-select admin-form-control" id="editDifficulty" name="difficulty" required>
                  <option value="">Select Difficulty</option>
                  <option value="Easy">Easy</option>
                  <option value="Medium">Medium</option>
                  <option value="Hard">Hard</option>
                </select>
              </div>

              <div class="admin-form-group">
                <label for="editPoints" class="admin-form-label">Points</label>
                <input type="number" class="form-control admin-form-control" id="editPoints" name="points" value="1" min="1" max="10">
              </div>

              <div class="admin-form-group">
                <label for="editQuestionTags" class="admin-form-label">
                  Tags
                  <span class="badge bg-info ms-2" style="font-size: 9px; font-weight: 500;">
                    <i class="fas fa-mouse-pointer"></i> Click to remove
                  </span>
                </label>
                <input type="text" class="form-control admin-form-control" id="editQuestionTags" name="tags" placeholder="Enter tags separated by commas">
                <small class="form-text text-muted" id="editQuestionTagsHelp" style="display: block; margin-top: 5px;">
                  <i class="fas fa-info-circle"></i> Separate multiple tags with commas. Tags will appear below for easy removal.
                </small>
                <div id="editQuestionTagsPreview" class="mt-2" style="display: none;">
                  <!-- Tag preview will be shown here -->
                </div>

                <!-- Previous Tags Selection -->
                <div id="previousTagsSection" style="display: none;">
                  <label class="admin-form-label mt-3">Previous Tags (from this bank)</label>
                  <div id="previousTagsContainer" class="previous-tags-container">
                    <!-- Previous tags will be populated here -->
                  </div>
                </div>
              </div>
            </div>
          </div>
          </div>
        </div>

        <div class="modal-footer admin-modal-footer">
          <button type="button" class="btn btn-secondary admin-btn-secondary" data-bs-dismiss="modal">
            Cancel
          </button>
          <button type="submit" class="btn btn-primary admin-btn-primary">
            <i class="fas fa-save me-2"></i>
            Update Question
          </button>
        </div>
      </form>
    </div>
  </div>
</div>

<%- include('./partials/admin-footer') %>

<!-- Local Upload Script -->
<script src="/js/local-upload.js"></script>

<script>
  let optionCount = 2;
  // Safe modal/backdrop cleanup to prevent stuck faded overlay
  function cleanupModals() {
    try {
      // Hide any visible modals
      document.querySelectorAll('.modal.show').forEach((modalEl) => {
        const instance = bootstrap.Modal.getInstance(modalEl);
        if (instance) instance.hide();
      });
      // Remove any lingering backdrops
      document.querySelectorAll('.modal-backdrop').forEach((el) => el.remove());
      // Remove body classes/styles added by Bootstrap
      document.body.classList.remove('modal-open');
      document.body.style.removeProperty('padding-right');
    } catch (e) {
      console.warn('cleanupModals warning:', e);
    }
  }

  // Ensure cleanup runs after any modal is hidden
  document.addEventListener('hidden.bs.modal', cleanupModals);

  // Handle question type change
  function handleQuestionTypeChange() {
    const questionType = document.getElementById('questionType').value;
    const optionsContainer = document.getElementById('optionsContainer');
    const addOptionBtn = document.getElementById('addOptionBtn');
    const answerOptionsSection = document.getElementById('answerOptionsSection');
    const writtenAnswersSection = document.getElementById('writtenAnswersSection');
    const correctAnswersContainer = document.getElementById('correctAnswersContainer');

    // Hide both sections first
    answerOptionsSection.style.display = 'none';
    writtenAnswersSection.style.display = 'none';

    if (questionType === 'True/False') {
      // Show the answer options section
      answerOptionsSection.style.display = 'block';

      // Create True/False options
      optionsContainer.innerHTML = `
      <div class="question-option-item">
        <div class="option-content">
          <div class="option-radio">
            <input type="radio" name="correctAnswer" value="0" class="option-radio-input" id="trueOption">
            <label for="trueOption" class="option-radio-label">True</label>
          </div>
          <input type="text" class="option-text-input" name="optionText" 
                 placeholder="True" value="True" readonly>
        </div>
      </div>
      <div class="question-option-item">
        <div class="option-content">
          <div class="option-radio">
            <input type="radio" name="correctAnswer" value="1" class="option-radio-input" id="falseOption">
            <label for="falseOption" class="option-radio-label">False</label>
          </div>
          <input type="text" class="option-text-input" name="optionText" 
                 placeholder="False" value="False" readonly>
        </div>
      </div>
    `;
      addOptionBtn.style.display = 'none';
      optionCount = 2;
    } else if (questionType === 'MCQ') {
      // Show the answer options section
      answerOptionsSection.style.display = 'block';

      // Create MCQ options
      optionsContainer.innerHTML = `
      <div class="question-option-item">
        <div class="option-content">
          <div class="option-radio">
            <input type="radio" name="correctAnswer" value="0" class="option-radio-input" id="optionA">
            <label for="optionA" class="option-radio-label">A</label>
          </div>
          <input type="text" class="form-control option-text-input" name="optionText" 
                 placeholder="Enter option A (use $...$ for math)" id="optionText_A">
          <button type="button" class="option-remove-btn" onclick="removeOption(this)" style="display: none;">
            <i class="fas fa-trash"></i>
          </button>
        </div>
      </div>
      <div class="question-option-item">
        <div class="option-content">
          <div class="option-radio">
            <input type="radio" name="correctAnswer" value="1" class="option-radio-input" id="optionB">
            <label for="optionB" class="option-radio-label">B</label>
          </div>
          <input type="text" class="form-control option-text-input" name="optionText" 
                 placeholder="Enter option B (use $...$ for math)" id="optionText_B">
          <button type="button" class="option-remove-btn" onclick="removeOption(this)" style="display: none;">
            <i class="fas fa-trash"></i>
          </button>
        </div>
      </div>
    `;

      addOptionBtn.style.display = 'block';
      optionCount = 2;
    } else if (questionType === 'Written') {
      // Show the written answers section
      writtenAnswersSection.style.display = 'block';

      // Create initial correct answer input with checkbox for mandatory (first answer is always mandatory)
      correctAnswersContainer.innerHTML = `
      <div class="question-option-item">
        <div class="option-content">
          <div class="option-checkbox">
            <input type="checkbox" name="answerMandatory" value="true" class="option-checkbox-input" id="mandatory0" checked disabled>
            <label for="mandatory0" class="option-checkbox-label mandatory-always">
              <i class="fas fa-lock"></i>
              <span class="mandatory-text">Mandatory</span>
            </label>
          </div>
          <input type="text" class="option-text-input" name="correctAnswers" 
                 placeholder="Enter correct answer (use $...$ for math)...">
          <button type="button" class="option-remove-btn" onclick="removeCorrectAnswer(this)" style="display: none;">
            <i class="fas fa-trash"></i>
          </button>
        </div>
      </div>
    `;

      // Update remove buttons visibility
      updateAnswerRemoveButtons();

      // Add event listeners for answer multiplicity radio buttons
      const singleAnswerRadio = document.getElementById('singleAnswer');
      const multipleAnswersRadio = document.getElementById('multipleAnswers');
      const addAnswerBtn = document.getElementById('addAnswerBtn');

      if (singleAnswerRadio && multipleAnswersRadio && addAnswerBtn) {
        // Set initial state based on selected radio button
        if (singleAnswerRadio.checked) {
          addAnswerBtn.style.display = 'none';
        } else if (multipleAnswersRadio.checked) {
          addAnswerBtn.style.display = 'block';
        }

        singleAnswerRadio.addEventListener('change', function() {
          if (this.checked) {
            // For single answer, hide the add button and ensure only one answer
            addAnswerBtn.style.display = 'none';
            const answers = document.querySelectorAll('#correctAnswersContainer .question-option-item');
            if (answers.length > 1) {
              // Remove extra answers, keep only the first one
              for (let i = 1; i < answers.length; i++) {
                answers[i].remove();
              }
            }
            updateAnswerRemoveButtons();
          }
        });

        multipleAnswersRadio.addEventListener('change', function() {
          if (this.checked) {
            // For multiple answers, show the add button
            addAnswerBtn.style.display = 'block';
            updateAnswerRemoveButtons();
          }
        });
      }
    } else {
      // Hide all sections when no type is selected
      answerOptionsSection.style.display = 'none';
      writtenAnswersSection.style.display = 'none';
      addOptionBtn.style.display = 'none';
    }
  }

  // Add new option
  function addOption() {
    const container = document.getElementById('optionsContainer');
    const optionItem = document.createElement('div');
    optionItem.className = 'question-option-item';
    const optionLetter = String.fromCharCode(65 + optionCount);
    optionItem.innerHTML = `
    <div class="option-content">
      <div class="option-radio">
        <input type="radio" name="correctAnswer" value="${optionCount}" class="option-radio-input" id="option${optionLetter}">
        <label for="option${optionLetter}" class="option-radio-label">${optionLetter}</label>
      </div>
      <input type="text" class="form-control option-text-input" name="optionText" 
             placeholder="Enter option ${optionLetter} (use $...$ for math)" id="optionText_${optionLetter}">
      <button type="button" class="option-remove-btn" onclick="removeOption(this)">
        <i class="fas fa-trash"></i>
      </button>
    </div>
  `;
    container.appendChild(optionItem);
    optionCount++;
  }

  // Remove option
  function removeOption(button) {
    const optionItem = button.closest('.question-option-item');
    const optionsContainer = document.getElementById('optionsContainer');
    const currentOptions = optionsContainer.querySelectorAll('.question-option-item');

    // Ensure minimum 2 options for MCQ questions
    if (currentOptions.length <= 2) {
      showNotification('MCQ questions must have at least 2 options', 'warning');
      return;
    }

    optionItem.remove();

    // Update option numbering after removal
    updateOptionNumbering();
  }

  // Update option numbering after removal
  function updateOptionNumbering() {
    const optionsContainer = document.getElementById('optionsContainer');
    const options = optionsContainer.querySelectorAll('.question-option-item');

    options.forEach((option, index) => {
      const radioInput = option.querySelector('.option-radio-input');
      const radioLabel = option.querySelector('.option-radio-label');
      const textInput = option.querySelector('.option-text-input');

      if (radioInput && radioLabel && textInput) {
        const letter = String.fromCharCode(65 + index);
        radioInput.value = index;
        radioInput.id = `option${letter}`;
        radioLabel.setAttribute('for', `option${letter}`);
        radioLabel.textContent = letter;
        textInput.placeholder = `Enter option ${letter}`;
      }
    });
  }

  // Add new correct answer
  function addCorrectAnswer() {
    const container = document.getElementById('correctAnswersContainer');
    const answerCount = container.querySelectorAll('.question-option-item').length;
    const answerItem = document.createElement('div');
    answerItem.className = 'question-option-item';
    answerItem.innerHTML = `
    <div class="option-content">
      <div class="option-checkbox">
        <input type="checkbox" name="answerMandatory" value="true" class="option-checkbox-input" id="mandatory${answerCount}" checked>
        <label for="mandatory${answerCount}" class="option-checkbox-label">
          <i class="fas fa-check"></i>
          <span class="mandatory-text">Mandatory</span>
        </label>
      </div>
      <input type="text" class="option-text-input" name="correctAnswers" 
             placeholder="Enter correct answer (use $...$ for math)...">
      <button type="button" class="option-remove-btn" onclick="removeCorrectAnswer(this)">
        <i class="fas fa-trash"></i>
      </button>
    </div>
  `;
    container.appendChild(answerItem);

    // Show remove buttons if more than one answer
    updateAnswerRemoveButtons();
  }

  // Remove correct answer
  function removeCorrectAnswer(button) {
    const answerItem = button.closest('.question-option-item');
    const container = document.getElementById('correctAnswersContainer');
    const currentAnswers = container.querySelectorAll('.question-option-item');

    // Ensure minimum 1 answer
    if (currentAnswers.length <= 1) {
      showNotification('Written questions must have at least one correct answer', 'warning');
      return;
    }

    answerItem.remove();
    updateAnswerRemoveButtons();
  }

  // Update answer remove buttons visibility
  function updateAnswerRemoveButtons() {
    const container = document.getElementById('correctAnswersContainer');
    const answers = container.querySelectorAll('.question-option-item');
    const removeButtons = container.querySelectorAll('.option-remove-btn');

    removeButtons.forEach(button => {
      button.style.display = answers.length > 1 ? 'block' : 'none';
    });
  }

  // Update edit option numbering after removal
  function updateEditOptionNumbering() {
    const optionsContainer = document.getElementById('editOptionsContainer');
    const options = optionsContainer.querySelectorAll('.question-option-item');

    options.forEach((option, index) => {
      const radioInput = option.querySelector('.option-radio-input');
      const radioLabel = option.querySelector('.option-radio-label');
      const textInput = option.querySelector('.option-text-input');

      if (radioInput && radioLabel && textInput) {
        const letter = String.fromCharCode(65 + index);
        radioInput.value = index;
        radioInput.id = `editOption${letter}`;
        radioLabel.setAttribute('for', `editOption${letter}`);
        radioLabel.textContent = letter;
        textInput.placeholder = `Option ${letter}`;
      }
    });
  }

  // Preview question
  function previewQuestion(questionId) {
    // Show loading state
    cleanupModals();
    const previewModal = new bootstrap.Modal(document.getElementById('questionPreviewModal'));
    previewModal.show();

    // Set loading content
    document.getElementById('previewQuestionTitle').textContent = 'Loading Question...';
    document.getElementById('previewQuestionText').innerHTML = '<div class="text-center"><i class="fas fa-spinner fa-spin"></i> Loading...</div>';

    // Fetch complete question data from server
    fetch(`/admin/question-banks/banks/<%= questionBank.bankCode %>/questions/${questionId}`, {
        headers: {
          'Accept': 'application/json',
          'Content-Type': 'application/json'
        }
      })
      .then(response => {
        console.log('Response status:', response.status);
        console.log('Response headers:', response.headers.get('content-type'));
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
      })
      .then(data => {
        if (data.success) {
          populatePreviewModal(data.question);
        } else {
          throw new Error(data.message || 'Failed to load question');
        }
      })
      .catch(error => {
        console.error('Error loading question:', error);
        document.getElementById('previewQuestionText').innerHTML = '<div class="text-danger">Error loading question: ' + error.message + '</div>';
      });
  }

  // Parse text and replace $...$ patterns with MathLive fields
  function parseMathExpressions(text) {
    if (!text) return '';
    
    // Regular expression to match $...$ patterns (non-greedy)
    const mathPattern = /\$([^$]+)\$/g;
    const parts = [];
    let lastIndex = 0;
    let match;
    let mathIndex = 0;
    
    while ((match = mathPattern.exec(text)) !== null) {
      // Add text before the math expression
      if (match.index > lastIndex) {
        parts.push({
          type: 'text',
          content: text.substring(lastIndex, match.index)
        });
      }
      
      // Add the math expression
      parts.push({
        type: 'math',
        content: match[1], // Content inside $...$
        index: mathIndex++
      });
      
      lastIndex = match.index + match[0].length;
    }
    
    // Add remaining text after the last math expression
    if (lastIndex < text.length) {
      parts.push({
        type: 'text',
        content: text.substring(lastIndex)
      });
    }
    
    // If no math expressions found, return the original text
    if (parts.length === 0) {
      return text;
    }
    
    // Build HTML with MathLive fields for math expressions
    let html = '';
    parts.forEach(part => {
      if (part.type === 'text') {
        html += escapeHtml(part.content);
      } else {
        // Create a unique ID for each math field
        const mathId = `math-field-${Date.now()}-${part.index}`;
        html += `<math-field id="${mathId}" readonly style="display: inline-block; min-height: 24px; font-size: 16px; border: none; background: transparent; padding: 2px 4px; vertical-align: middle;" class="preview-math-field">${escapeHtml(part.content)}</math-field>`;
      }
    });
    
    return html;
  }
  
  // Escape HTML to prevent XSS
  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  // Populate preview modal with question data
  function populatePreviewModal(question) {
    console.log('Populating preview modal with question:', question);

    // Populate the preview modal
    document.getElementById('previewQuestionTitle').textContent = 'Question Preview';

    // Parse question text and render math expressions
    const questionTextElement = document.getElementById('previewQuestionText');
    questionTextElement.innerHTML = parseMathExpressions(question.questionText);

    document.getElementById('previewDifficulty').textContent = question.difficulty;
    document.getElementById('previewDifficulty').className = `question-preview-difficulty ${question.difficulty.toLowerCase()}`;
    document.getElementById('previewPoints').textContent = `${question.points} pts`;
    document.getElementById('previewCreatedDate').textContent = new Date(question.createdAt).toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });

    // Set up edit button
    document.getElementById('previewEditBtn').onclick = () => {
      const previewEl = document.getElementById('questionPreviewModal');
      const instance = bootstrap.Modal.getInstance(previewEl);
      if (!instance) return;
      // After preview fully hides, open edit
      const onHidden = () => {
        previewEl.removeEventListener('hidden.bs.modal', onHidden);
        cleanupModals();
        editQuestion(question._id);
      };
      previewEl.addEventListener('hidden.bs.modal', onHidden);
      instance.hide();
    };

    // Handle tags
    const tagsContainer = document.getElementById('previewTags');
    if (question.tags && question.tags.length > 0) {
      tagsContainer.innerHTML = `
      <div class="question-preview-tags-title">
        <i class="fas fa-tags"></i>
        Tags
      </div>
      <div class="question-preview-tags-list">
        ${question.tags.map(tag => `<span class="question-preview-tag">${tag}</span>`).join('')}
      </div>
    `;
      tagsContainer.style.display = 'block';
    } else {
      tagsContainer.style.display = 'none';
    }

    // Display real options data
    const optionsContainer = document.getElementById('previewOptionsContainer');
    if (question.questionType === 'Written') {
      // For written questions, show correct answers with mandatory/optional status
      const correctAnswers = question.correctAnswers || [];
      if (correctAnswers.length > 0) {
        const answersHtml = correctAnswers.map((answer, index) => {
          // Handle both old string format and new object format
          let answerText = '';
          let isMandatory = true;

          if (typeof answer === 'string') {
            answerText = answer;
          } else if (typeof answer === 'object' && answer.text) {
            answerText = answer.text;
            isMandatory = answer.isMandatory !== false; // Default to true if not specified
          }

          // Parse answer text and render math expressions
          const answerTextHtml = parseMathExpressions(answerText);

          const mandatoryClass = isMandatory ? 'mandatory' : 'optional';
          const mandatoryIcon = isMandatory ? 'fas fa-lock' : 'fas fa-unlock';
          const mandatoryText = isMandatory ? 'Mandatory' : 'Optional';

          return `
          <div class="question-preview-answer ${mandatoryClass}">
            <span class="answer-label">${String.fromCharCode(65 + index)}</span>
            <div class="answer-text">${answerTextHtml}</div>
            <div class="answer-status">
              <i class="${mandatoryIcon}"></i>
              <span>${mandatoryText}</span>
            </div>
          </div>
        `;
        }).join('');

        optionsContainer.innerHTML = `
        <div class="question-preview-answers">
          <div class="question-preview-answers-title">Correct Answers:</div>
          ${answersHtml}
        </div>
      `;
      } else {
        optionsContainer.innerHTML = '<div class="text-muted">No correct answers defined</div>';
      }
    } else if (question.options && question.options.length > 0) {
      // For MCQ and True/False questions, show options
      console.log('Processing options:', question.options);
      const optionsHtml = question.options.map((option, index) => {
        const letter = String.fromCharCode(65 + index);
        const isCorrect = option.isCorrect ? ' correct' : '';

        // Parse option text and render math expressions
        const optionTextHtml = parseMathExpressions(option.text);

        return `
        <div class="question-preview-option${isCorrect}">
          <span class="option-label">${letter}</span>
          <div class="option-text">${optionTextHtml}${option.isCorrect ? ' <span class="correct-indicator">(Correct Answer)</span>' : ''}</div>
        </div>
      `;
      }).join('');

      optionsContainer.innerHTML = optionsHtml;
    } else {
      optionsContainer.innerHTML = '<div class="text-muted">No options defined</div>';
    }

    // Display real explanation data
    const explanationDiv = document.getElementById('previewExplanation');
    const explanationText = document.getElementById('previewExplanationText');

    if (question.explanation && question.explanation.trim()) {
      // Parse explanation and render math expressions
      explanationText.innerHTML = parseMathExpressions(question.explanation);
      explanationDiv.style.display = 'block';
    } else {
      explanationDiv.style.display = 'none';
    }

    // Display question image if it exists
    const previewImageContainer = document.getElementById('previewQuestionImage');
    const previewImageSrc = document.getElementById('previewImageSrc');
    if (question.questionImage && question.questionImage.trim()) {
      previewImageSrc.src = question.questionImage;
      previewImageSrc.alt = 'Question Image';
      previewImageContainer.style.display = 'block';
    } else {
      previewImageContainer.style.display = 'none';
    }

    // Show the modal
    const modal = new bootstrap.Modal(document.getElementById('questionPreviewModal'));
    modal.show();
  }

  // Clear edit form completely
  function clearEditForm() {
    // Clear all text inputs
    document.getElementById('editQuestionText').value = '';
    document.getElementById('editHiddenQuestionText').value = '';
    document.getElementById('editExplanation').value = '';
    document.getElementById('editQuestionTags').value = '';
    document.getElementById('editQuestionImageUrl').value = '';
    document.getElementById('editPoints').value = '1';
    
    // Reset selects
    document.getElementById('editQuestionType').value = '';
    document.getElementById('editDifficulty').value = '';
    
    // Clear options container
    const optionsContainer = document.getElementById('editOptionsContainer');
    if (optionsContainer) {
      optionsContainer.innerHTML = '';
    }
    
    // Clear correct answers container
    const answersContainer = document.getElementById('editCorrectAnswersContainer');
    if (answersContainer) {
      answersContainer.innerHTML = '';
    }
    
    // Clear image preview and reset file input
    const imagePreview = document.getElementById('editQuestionImagePreview');
    if (imagePreview) {
      imagePreview.innerHTML = `
        <div class="preview-overlay">
          <i class="fas fa-cloud-upload-alt"></i>
          <p>Click or drag to upload</p>
          <small>JPEG, PNG, JPG, WebP (max 10MB)</small>
        </div>
      `;
      imagePreview.onmouseenter = null;
      imagePreview.onmouseleave = null;
    }
    
    // Reset file input
    const fileInput = document.getElementById('editQuestionImageFile');
    if (fileInput) {
      fileInput.value = '';
      delete fileInput.dataset.uploaded;
      delete fileInput.dataset.localUrl;
    }
    
    // Hide image action buttons
    const imageActions = document.getElementById('editQuestionImageActions');
    if (imageActions) {
      imageActions.style.display = 'none';
    }
    
    // Clear tags preview
    const tagsPreview = document.getElementById('editQuestionTagsPreview');
    if (tagsPreview) {
      tagsPreview.innerHTML = '';
      tagsPreview.style.display = 'none';
    }
    
    // Reset math editor preview
    const mathPreview = document.getElementById('mathEditorPreview-editQuestionText');
    if (mathPreview) {
      mathPreview.innerHTML = 'Preview will appear here...';
    }
    
    // Clear math editor field
    const mathField = document.getElementById('mathEditorField-editQuestionText');
    if (mathField) {
      mathField.value = '';
    }
    
    // Hide sections
    document.getElementById('editAnswerOptionsSection').style.display = 'none';
    document.getElementById('editWrittenAnswersSection').style.display = 'none';
    
    // Clear validation errors
    const invalidFields = document.querySelectorAll('#editQuestionModal .is-invalid');
    invalidFields.forEach(field => field.classList.remove('is-invalid'));
    const errorMessages = document.querySelectorAll('#editQuestionModal .invalid-feedback');
    errorMessages.forEach(error => {
      error.style.display = 'none';
      error.textContent = '';
    });
    
    // Reset tags badge
    const tagsBadge = document.getElementById('editQuestionTagsBadge');
    if (tagsBadge) {
      tagsBadge.style.display = 'none';
    }
  }

  // Remove question image from edit form
  function removeEditQuestionImage() {
    // Clear the hidden URL field
    const imageUrl = document.getElementById('editQuestionImageUrl');
    if (imageUrl) {
      imageUrl.value = '';
    }
    
    // Reset file input
    const fileInput = document.getElementById('editQuestionImageFile');
    if (fileInput) {
      fileInput.value = '';
      delete fileInput.dataset.uploaded;
      delete fileInput.dataset.localUrl;
    }
    
    // Reset preview to default state
    const imagePreview = document.getElementById('editQuestionImagePreview');
    if (imagePreview) {
      imagePreview.innerHTML = `
        <div class="preview-overlay">
          <i class="fas fa-cloud-upload-alt"></i>
          <p>Click or drag to upload</p>
          <small>JPEG, PNG, JPG, WebP (max 10MB)</small>
        </div>
      `;
      imagePreview.onmouseenter = null;
      imagePreview.onmouseleave = null;
    }
    
    // Hide the action buttons
    const imageActions = document.getElementById('editQuestionImageActions');
    if (imageActions) {
      imageActions.style.display = 'none';
    }
    
    // Show success notification
    showNotification('Image removed. Save to apply changes.', 'info');
  }

  // Populate edit form directly with question data (no fetch - used for cached data)
  function populateEditFormDirectly(question, questionId) {
    cleanupModals();
    
    // Clear form completely to prevent cached data
    clearEditForm();
    
    // No loader needed since we have data immediately
    const loader = document.getElementById('editQuestionLoader');
    const formContent = document.getElementById('editQuestionFormContent');
    if (loader) loader.style.display = 'none';
    if (formContent) formContent.style.display = 'block';
    
    // Enable footer buttons
    const footerButtons = document.querySelectorAll('#editQuestionModal .modal-footer button');
    footerButtons.forEach(btn => btn.disabled = false);

    // Show modal immediately
    const modal = new bootstrap.Modal(document.getElementById('editQuestionModal'));
    modal.show();

    // Populate the edit form
    const editQuestionTextElement = document.getElementById('editQuestionText');
    editQuestionTextElement.value = question.questionText || '';
    
    // Continue with the rest of the population logic (same as editQuestion)
    populateEditFormFields(question, questionId);
  }
  
  // Shared function to populate edit form fields (used by both editQuestion and populateEditFormDirectly)
  function populateEditFormFields(question, questionId) {
    // Populate the edit form
    const editQuestionTextElement = document.getElementById('editQuestionText');
    editQuestionTextElement.value = question.questionText || '';

    // Populate basic fields
    document.getElementById('editQuestionType').value = question.questionType;
    document.getElementById('editDifficulty').value = question.difficulty;
    document.getElementById('editPoints').value = question.points;

          // Populate basic fields
          document.getElementById('editQuestionType').value = question.questionType;
          document.getElementById('editDifficulty').value = question.difficulty;
          document.getElementById('editPoints').value = question.points;
          
          // Populate tags - ensure they're properly set
          const editTagsInput = document.getElementById('editQuestionTags');
          if (editTagsInput) {
            if (question.tags && Array.isArray(question.tags) && question.tags.length > 0) {
              const tagsString = question.tags.join(', ');
              editTagsInput.value = tagsString;
              // Store original tags as data attribute for reference
              editTagsInput.setAttribute('data-original-tags', tagsString);
            } else {
              editTagsInput.value = '';
              editTagsInput.setAttribute('data-original-tags', '');
            }
            
            // Function to remove a tag with animation
            const removeEditTag = function(tagToRemove, badgeElement) {
              // Add removing animation
              if (badgeElement) {
                badgeElement.classList.add('removing');
                // Wait for animation to complete
                setTimeout(() => {
                  const currentTags = editTagsInput.value.trim();
                  const tags = currentTags.split(',').map(t => t.trim()).filter(t => t);
                  const updatedTags = tags.filter(tag => tag !== tagToRemove);
                  editTagsInput.value = updatedTags.join(', ');
                  updateTagsPreview();
                }, 400);
              } else {
                const currentTags = editTagsInput.value.trim();
                const tags = currentTags.split(',').map(t => t.trim()).filter(t => t);
                const updatedTags = tags.filter(tag => tag !== tagToRemove);
                editTagsInput.value = updatedTags.join(', ');
                updateTagsPreview();
              }
            };
            
            // Add visual indicator for tag changes and live preview
            const updateTagsPreview = function() {
              const originalTags = editTagsInput.getAttribute('data-original-tags') || '';
              const currentTags = editTagsInput.value.trim();
              const tagsPreview = document.getElementById('editQuestionTagsPreview');
              const tagsHelp = document.getElementById('editQuestionTagsHelp');
              const tagsBadge = document.getElementById('editQuestionTagsBadge');
              const tagsCount = document.getElementById('editQuestionTagsCount');
              
              // Visual indicator for changes
              if (currentTags !== originalTags) {
                editTagsInput.style.borderColor = '#f59e0b';
                editTagsInput.style.boxShadow = '0 0 0 3px rgba(245, 158, 11, 0.1)';
              } else {
                editTagsInput.style.borderColor = '';
                editTagsInput.style.boxShadow = '';
              }
              
              // Parse tags
              const tags = currentTags ? currentTags.split(',').map(t => t.trim()).filter(t => t) : [];
              
              // Update badge in modal header
              if (tagsBadge && tagsCount) {
                if (tags.length > 0) {
                  tagsCount.textContent = tags.length;
                  tagsBadge.style.display = 'inline-block';
                  
                  // Change badge color if tags were modified
                  if (currentTags !== originalTags) {
                    tagsBadge.className = 'badge bg-warning ms-2';
                  } else {
                    tagsBadge.className = 'badge bg-primary ms-2';
                  }
                } else {
                  tagsBadge.style.display = 'none';
                }
              }
              
              // Show tag preview with remove buttons
              if (currentTags && tagsPreview) {
                if (tags.length > 0) {
                  tagsPreview.innerHTML = `
                    <div style="display: flex; flex-wrap: wrap; gap: 6px; padding: 10px; background: #f8f9fa; border-radius: 6px; border: 1px solid #e9ecef;">
                      ${tags.map(tag => `
                        <span class="editable-tag-badge" data-tag="${tag.replace(/"/g, '&quot;')}" 
                              style="background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); color: white; padding: 4px 10px 4px 12px; border-radius: 12px; font-size: 11px; font-weight: 600; display: inline-flex; align-items: center; gap: 6px; cursor: pointer; transition: all 0.2s ease;">
                          <i class="fas fa-tag" style="font-size: 9px;"></i>
                          <span>${tag}</span>
                          <i class="fas fa-times" style="font-size: 10px; opacity: 0.8; padding: 2px; border-radius: 50%; transition: all 0.2s ease;"></i>
                        </span>
                      `).join('')}
                      <span style="color: #6b7280; font-size: 11px; padding: 4px 10px; display: inline-flex; align-items: center;">
                        <i class="fas fa-info-circle me-1"></i>
                        ${tags.length} tag${tags.length !== 1 ? 's' : ''} (click × to remove)
                      </span>
                    </div>
                  `;
                  
                  // Add click handlers to remove tags
                  const tagBadges = tagsPreview.querySelectorAll('.editable-tag-badge');
                  tagBadges.forEach(badge => {
                    badge.addEventListener('click', function(e) {
                      e.preventDefault();
                      const tagToRemove = this.getAttribute('data-tag');
                      removeEditTag(tagToRemove, this);
                    });
                    
                    // Add hover effect
                    badge.addEventListener('mouseenter', function() {
                      this.style.background = 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)';
                      this.style.transform = 'scale(1.05)';
                    });
                    
                    badge.addEventListener('mouseleave', function() {
                      this.style.background = 'linear-gradient(135deg, #3b82f6 0%, #2563eb 100%)';
                      this.style.transform = 'scale(1)';
                    });
                  });
                  
                  tagsPreview.style.display = 'block';
                  if (tagsHelp) tagsHelp.style.display = 'none';
                } else {
                  tagsPreview.style.display = 'none';
                  if (tagsHelp) tagsHelp.style.display = 'block';
                }
              } else {
                if (tagsPreview) tagsPreview.style.display = 'none';
                if (tagsHelp) tagsHelp.style.display = 'block';
              }
            };
            
            editTagsInput.addEventListener('input', updateTagsPreview);
            // Initial preview
            updateTagsPreview();
          } else {
            console.error('editQuestionTags input not found');
          }
          
          // Populate and display question image
          const editQuestionImageUrl = document.getElementById('editQuestionImageUrl');
          const editQuestionImagePreview = document.getElementById('editQuestionImagePreview');
          const editQuestionImageActions = document.getElementById('editQuestionImageActions');
          const editQuestionImageFile = document.getElementById('editQuestionImageFile');
          
          // Reset the file input
          if (editQuestionImageFile) {
            editQuestionImageFile.value = '';
            delete editQuestionImageFile.dataset.uploaded;
            delete editQuestionImageFile.dataset.localUrl;
          }
          
          if (question.questionImage && question.questionImage.trim()) {
            if (editQuestionImageUrl) editQuestionImageUrl.value = question.questionImage;
            // Display the image preview with proper styling
            if (editQuestionImagePreview) {
              editQuestionImagePreview.innerHTML = `
                <img src="${question.questionImage}" alt="Question Image" style="width: 100%; height: 100%; object-fit: cover; border-radius: 8px;">
                <div class="preview-overlay" style="opacity: 0; transition: opacity 0.3s;">
                  <i class="fas fa-image"></i>
                  <p>Current Image</p>
                  <small>Click buttons below to change or remove</small>
                </div>
              `;
              // Add hover effect for overlay
              editQuestionImagePreview.onmouseenter = function() {
                const overlay = this.querySelector('.preview-overlay');
                if (overlay) overlay.style.opacity = '1';
              };
              editQuestionImagePreview.onmouseleave = function() {
                const overlay = this.querySelector('.preview-overlay');
                if (overlay) overlay.style.opacity = '0';
              };
            }
            // Show image action buttons
            if (editQuestionImageActions) {
              editQuestionImageActions.style.display = 'flex';
            }
          } else {
            if (editQuestionImageUrl) editQuestionImageUrl.value = '';
            if (editQuestionImagePreview) {
              editQuestionImagePreview.innerHTML = `
                <div class="preview-overlay">
                  <i class="fas fa-cloud-upload-alt"></i>
                  <p>Click or drag to upload</p>
                  <small>JPEG, PNG, JPG, WebP (max 10MB)</small>
                </div>
              `;
              editQuestionImagePreview.onmouseenter = null;
              editQuestionImagePreview.onmouseleave = null;
            }
            // Hide image action buttons
            if (editQuestionImageActions) {
              editQuestionImageActions.style.display = 'none';
            }
          }
          
          document.getElementById('editExplanation').value = question.explanation || '';

          // Handle question type specific fields
          handleEditQuestionTypeChange();

          // Populate options if MCQ or True/False
          if (question.questionType === 'MCQ' || question.questionType === 'True/False') {
            if (question.options && question.options.length > 0) {
              const optionsContainer = document.getElementById('editOptionsContainer');
              if (optionsContainer) {
                // Wait a bit for the container to be created by handleEditQuestionTypeChange
                setTimeout(() => {
                  // If we have more than 2 options, we need to add them
                  if (question.options.length > 2) {
                    for (let i = 2; i < question.options.length; i++) {
                      addEditOption();
                    }
                    // Wait a bit more for the new options to be created
                    setTimeout(() => {
                      populateEditOptions(question.options, optionsContainer);
                    }, 100);
                  } else {
                    populateEditOptions(question.options, optionsContainer);
                  }
                }, 300);
              }
            }
          }

          if (question.questionType === 'Written') {
            // Set answer multiplicity
            const singleAnswerRadio = document.getElementById('editSingleAnswer');
            const multipleAnswersRadio = document.getElementById('editMultipleAnswers');

            if (question.answerMultiplicity === 'single') {
              singleAnswerRadio.checked = true;
            } else {
              multipleAnswersRadio.checked = true;
            }

            // Populate correct answers
            const container = document.getElementById('editCorrectAnswersContainer');
            container.innerHTML = '';

            if (question.correctAnswers && question.correctAnswers.length > 0) {
              question.correctAnswers.forEach((answer, index) => {
                const answerText = typeof answer === 'string' ? answer : answer.text;
                const isMandatory = typeof answer === 'string' ? true : answer.isMandatory;

                const answerItem = document.createElement('div');
                answerItem.className = 'question-option-item';
                answerItem.innerHTML = `
                <div class="option-content">
                  <div class="option-checkbox">
                    <input type="checkbox" name="editAnswerMandatory" value="true" class="option-checkbox-input" id="editMandatory${index}" ${isMandatory ? 'checked' : ''} ${index === 0 ? 'disabled' : ''}>
                    <label for="editMandatory${index}" class="option-checkbox-label ${index === 0 ? 'mandatory-always' : ''}">
                      <i class="fas fa-${index === 0 ? 'lock' : 'check'}"></i>
                      <span class="mandatory-text">Mandatory</span>
                    </label>
                  </div>
                  <input type="text" class="option-text-input" name="editCorrectAnswers" 
                         placeholder="Enter correct answer..." value="${answerText}">
                  <button type="button" class="option-remove-btn" onclick="removeEditCorrectAnswer(this)" style="display: none;">
                    <i class="fas fa-trash"></i>
                  </button>
                </div>
              `;
                container.appendChild(answerItem);
              });
            }

            updateEditAnswerRemoveButtons();
          }

    // Set the form action
    const editForm = document.getElementById('editQuestionForm');
    editForm.action = `/admin/question-banks/banks/<%= questionBank.bankCode %>/questions/${questionId}`;

    // Load previous tags asynchronously after form is shown (non-blocking)
    // Pass the current question's tags so they're included in the previous tags list
    setTimeout(function() {
      loadPreviousTags(question.tags || []);
    }, 100); // Reduced delay
  }
  
  // Edit question (fetches from server)
  function editQuestion(questionId) {
    cleanupModals();
    
    // Clear form completely to prevent cached data
    clearEditForm();
    
    // Show loader and hide form content
    const loader = document.getElementById('editQuestionLoader');
    const formContent = document.getElementById('editQuestionFormContent');
    if (loader) loader.style.display = 'block';
    if (formContent) formContent.style.display = 'none';
    
    // Disable footer buttons during loading
    const footerButtons = document.querySelectorAll('#editQuestionModal .modal-footer button');
    footerButtons.forEach(btn => btn.disabled = true);

    // Show modal with loader
    const modal = new bootstrap.Modal(document.getElementById('editQuestionModal'));
    modal.show();

    // Fetch complete question data from server (optimized with cache control)
    fetch(`/admin/question-banks/banks/<%= questionBank.bankCode %>/questions/${questionId}`, {
        method: 'GET',
        headers: {
          'Accept': 'application/json',
          'Content-Type': 'application/json',
          'Cache-Control': 'no-cache'
        },
        cache: 'no-store' // Prevent browser caching for fresh data
      })
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
      })
      .then(data => {
        if (data.success && data.question) {
          const question = data.question;
          
          // Hide loader and show form content
          const loader = document.getElementById('editQuestionLoader');
          const formContent = document.getElementById('editQuestionFormContent');
          if (loader) loader.style.display = 'none';
          if (formContent) formContent.style.display = 'block';
          
          // Enable footer buttons
          const footerButtons = document.querySelectorAll('#editQuestionModal .modal-footer button');
          footerButtons.forEach(btn => btn.disabled = false);

          // Populate the edit form using shared function
          populateEditFormFields(question, questionId);

        } else {
          // Hide loader on error
          const loader = document.getElementById('editQuestionLoader');
          if (loader) loader.style.display = 'none';
          showNotification('Failed to load question data', 'error');
          modal.hide();
        }
      })
      .catch(error => {
        console.error('Error fetching question:', error);
        // Hide loader on error
        const loader = document.getElementById('editQuestionLoader');
        if (loader) loader.style.display = 'none';
        showNotification('Failed to load question data: ' + (error.message || 'Network error'), 'error');
        modal.hide();
      });
  }

  // Delete question
  function deleteQuestion(questionId, questionText) {
    if (confirm(`Are you sure you want to delete this question?\n\n"${questionText}"\n\nThis action cannot be undone.`)) {
      // Show loading state
      showNotification('Deleting question...', 'info');

      fetch(`/admin/question-banks/banks/<%= questionBank.bankCode %>/questions/${questionId}`, {
          method: 'DELETE',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
          }
        })
        .then(response => {
          if (!response.ok) {
            return response.json().then(data => {
              throw new Error(data.message || 'Failed to delete question');
            });
          }
          return response.json();
        })
        .then(data => {
          if (data.success) {
            showNotification('Question deleted successfully!', 'success');
            // Remove the question card from the page
            const questionCard = document.querySelector(`[data-question-id="${questionId}"]`);
            if (questionCard) {
              questionCard.remove();
              // Update the questions count
              updateQuestionsCount();
            }
            // Reload the page to refresh the question list
            setTimeout(() => {
              window.location.reload();
            }, 1000);
          } else {
            throw new Error(data.message || 'Failed to delete question');
          }
        })
        .catch(error => {
          console.error('Error:', error);
          showNotification('Error deleting question: ' + error.message, 'error');
        });
    }
  }

  // Delete question bank
  function deleteQuestionBank(bankCode, bankName) {
    if (confirm(`Are you sure you want to delete the question bank "${bankName}"?\n\nThis action cannot be undone and will delete:\n- The question bank itself\n- All questions in this bank\n\nDo you want to continue?`)) {
      // Show loading state
      showNotification('Deleting question bank...', 'info');

      const deleteUrl = `/admin/question-banks/banks/${encodeURIComponent(bankCode)}`;
      console.log('Attempting to delete question bank at:', deleteUrl);

      // Use fetch API with method-override fallback
      fetch(deleteUrl, {
        method: 'DELETE',
        headers: {
          'Accept': 'application/json',
          'Content-Type': 'application/json'
        },
        credentials: 'same-origin'
      })
      .then(response => {
        console.log('Delete response status:', response.status);
        console.log('Delete response URL:', response.url);
        console.log('Delete response redirected:', response.redirected);
        
        // If we got redirected (404 or other), follow it
        if (response.redirected) {
          console.log('Response redirected to:', response.url);
          window.location.href = response.url;
          return { success: false, redirected: true };
        }
        
        // Check if response is JSON
        const contentType = response.headers.get('content-type');
        console.log('Response content-type:', contentType);
        
        if (contentType && contentType.includes('application/json')) {
          return response.json().then(data => {
            console.log('JSON response data:', data);
            if (!response.ok) {
              throw new Error(data.message || `Failed to delete question bank (${response.status})`);
            }
            return data;
          });
        } else if (response.status === 404) {
          throw new Error('Question bank not found (404). Please check the bank code.');
        } else if (response.status >= 400) {
          throw new Error(`Server error: ${response.status} ${response.statusText}`);
        } else {
          // Success but not JSON - redirect manually
          return { success: true, redirect: true };
        }
      })
      .then(data => {
        if (data && data.redirected) {
          // Already redirected above
          return;
        }
        
        if (data && data.redirect) {
          // Manual redirect needed
          showNotification('Question bank deleted successfully!', 'success');
          setTimeout(() => {
            window.location.href = '/admin/question-banks/banks';
          }, 1000);
          return;
        }
        
        if (data && data.success) {
          showNotification('Question bank deleted successfully!', 'success');
          setTimeout(() => {
            window.location.href = '/admin/question-banks/banks';
          }, 1000);
        }
      })
      .catch(error => {
        console.error('Error deleting question bank:', error);
        console.error('Error stack:', error.stack);
        showNotification('Error deleting question bank: ' + error.message, 'error');
        
        // Fallback: try using form submission with method-override
        console.log('Attempting fallback: form submission with method-override');
        const form = document.createElement('form');
        form.method = 'POST';
        form.action = deleteUrl;
        form.style.display = 'none';
        
        const methodInput = document.createElement('input');
        methodInput.type = 'hidden';
        methodInput.name = '_method';
        methodInput.value = 'DELETE';
        form.appendChild(methodInput);
        
        document.body.appendChild(form);
        form.submit();
      });
    }
  }

  // Export questions to Excel
  async function exportQuestionBankToExcel() {
    const btn = document.getElementById('exportBankBtn');
    const originalText = btn.innerHTML;

    try {
      // Show loading state
      btn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i> Exporting...';
      btn.disabled = true;

      // Make request to export endpoint
      const response = await fetch('/admin/question-banks/<%= questionBank._id %>/export', {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json'
        }
      });

      if (!response.ok) {
        throw new Error('Export failed: ' + response.statusText);
      }

      // Get the blob from response
      const blob = await response.blob();

      // Create download link
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'questionbank-<%= questionBank.bankCode %>-<%= questionBank.name.replace(/[^a-zA-Z0-9]/g, "-") %>-questions.xlsx';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);

      // Show success notification
      showNotification('Question bank exported successfully!', 'success');

    } catch (error) {
      console.error('Export error:', error);
      showNotification('Failed to export question bank: ' + error.message, 'error');
    } finally {
      // Reset button state
      btn.innerHTML = originalText;
      btn.disabled = false;
    }
  }

  // Open edit bank modal
  function openEditBankModal() {
    try {
      // Ensure Bootstrap is loaded
      if (typeof bootstrap === 'undefined') {
        console.error('Bootstrap not loaded');
        showNotification('Error: Bootstrap library not loaded', 'error');
        return;
      }

      // Clean up any existing modals
      cleanupModals();

      // Clear any previous errors
      clearEditFormErrors();

      // Show the modal
      const modalElement = document.getElementById('editBankModal');
      if (modalElement) {
        const modal = new bootstrap.Modal(modalElement, {
          backdrop: 'static',
          keyboard: false
        });
        modal.show();
      } else {
        console.error('Edit modal element not found');
        showNotification('Error: Could not open edit modal', 'error');
      }
    } catch (error) {
      console.error('Error opening edit modal:', error);
      showNotification('Error opening edit modal: ' + error.message, 'error');
    }
  }

  // Form submission handler
  document.addEventListener('DOMContentLoaded', function() {
    const createForm = document.getElementById('createQuestionForm');
    if (createForm) {
      createForm.addEventListener('submit', function(e) {
        const questionText = document.getElementById('questionText').value.trim();
        const questionType = document.getElementById('questionType').value;
        const options = document.querySelectorAll('input[name="optionText"]');
        const correctAnswer = document.querySelector('input[name="correctAnswer"]:checked');

        // Clear previous errors
        clearFormErrors();

        let hasErrors = false;

        // Basic validation - only check essential fields
        // Get question text from textarea
        const questionTextElement = document.getElementById('questionText');
        const finalQuestionText = questionTextElement ? questionTextElement.value.trim() : '';
        console.log('Question text:', finalQuestionText);

        // Update the hidden field with the final question text
        const hiddenQuestionText = document.getElementById('hiddenQuestionText');
        if (hiddenQuestionText) {
          hiddenQuestionText.value = finalQuestionText;
        }

        // Validate question text
        if (!finalQuestionText) {
          showFieldError('questionText', 'Question text is required');
          hasErrors = true;
        } else if (finalQuestionText.length < 10) {
          showFieldError('questionText', `Question text must be at least 10 characters (currently ${finalQuestionText.length})`);
          hasErrors = true;
        }

        // Validate question type
        if (!questionType) {
          showFieldError('questionType', 'Please select a question type');
          hasErrors = true;
        }

        // Validate difficulty
        const difficulty = document.getElementById('difficulty').value;
        if (!difficulty) {
          showFieldError('difficulty', 'Please select a difficulty level');
          hasErrors = true;
        }

        // Validate based on question type
        if (questionType === 'Written') {
          const correctAnswers = document.querySelectorAll('input[name="correctAnswers"]');
          const filledAnswers = Array.from(correctAnswers).filter(input => input.value.trim());
          const answerMultiplicity = document.querySelector('input[name="answerMultiplicity"]:checked');

          if (filledAnswers.length === 0) {
            showFieldError('writtenAnswers', 'Written questions must have at least one correct answer');
            hasErrors = true;
          } else if (answerMultiplicity && answerMultiplicity.value === 'single' && filledAnswers.length !== 1) {
            showFieldError('writtenAnswers', 'Single answer questions must have exactly one correct answer');
            hasErrors = true;
          }
        } else {
          // Validate options based on question type
          if (questionType === 'MCQ') {
            if (options.length < 2) {
              showFieldError('options', `MCQ questions must have at least 2 options (currently ${options.length})`);
              hasErrors = true;
            } else if (options.length > 6) {
              showFieldError('options', `MCQ questions should have at most 6 options (currently ${options.length})`);
              hasErrors = true;
            }
          } else if (questionType === 'True/False') {
            if (options.length !== 2) {
              showFieldError('options', `True/False questions must have exactly 2 options (currently ${options.length})`);
              hasErrors = true;
            }
          }

          // Validate that all options have text
          const emptyOptions = Array.from(options).filter(input => !input.value.trim());
          if (emptyOptions.length > 0) {
            showFieldError('options', `${emptyOptions.length} option(s) are empty. Please fill all options or remove empty ones.`);
            hasErrors = true;
          }

          // Only validate correct answer if we have valid options
          if (options.length > 0 && !correctAnswer) {
            showFieldError('options', 'Please select the correct answer');
            hasErrors = true;
          }
        }

        if (hasErrors) {
          e.preventDefault();

          // Show notification about validation errors
          showNotification('Please fix the validation errors before submitting', 'error');

          // Scroll to first error
          const firstError = document.querySelector('.field-error');
          if (firstError) {
            firstError.scrollIntoView({
              behavior: 'smooth',
              block: 'center'
            });
          }

          return false;
        }

        // Convert form data based on question type
        if (questionType === 'Written') {
          // Collect answers and mandatory flags
          const answersData = [];
          const mandatoryData = [];

          // Check all answer containers
          const answerContainers = document.querySelectorAll('#correctAnswersContainer .question-option-item');
          answerContainers.forEach((container, index) => {
            const textInput = container.querySelector('input[name="correctAnswers"]');
            const mandatoryCheckbox = container.querySelector('input[name="answerMandatory"]');

            if (textInput && textInput.value.trim()) {
              answersData.push(textInput.value.trim());
              mandatoryData.push(mandatoryCheckbox ? mandatoryCheckbox.checked : true);
            }
          });

          // Clear existing hidden inputs
          const existingAnswersInputs = this.querySelectorAll('input[name="correctAnswers"]');
          const existingMandatoryInputs = this.querySelectorAll('input[name="answerMandatory"]');
          existingAnswersInputs.forEach(input => input.remove());
          existingMandatoryInputs.forEach(input => input.remove());

          // Add new hidden inputs for answers
          answersData.forEach((answer, index) => {
            const answerInput = document.createElement('input');
            answerInput.type = 'hidden';
            answerInput.name = 'correctAnswers';
            answerInput.value = answer;
            this.appendChild(answerInput);
          });

          // Add new hidden inputs for mandatory flags
          mandatoryData.forEach((isMandatory, index) => {
            const mandatoryInput = document.createElement('input');
            mandatoryInput.type = 'hidden';
            mandatoryInput.name = 'answerMandatory';
            mandatoryInput.value = isMandatory;
            this.appendChild(mandatoryInput);
          });

          // Add answer multiplicity field
          const answerMultiplicity = document.querySelector('input[name="answerMultiplicity"]:checked');
          if (answerMultiplicity) {
            const multiplicityInput = document.createElement('input');
            multiplicityInput.type = 'hidden';
            multiplicityInput.name = 'answerMultiplicity';
            multiplicityInput.value = answerMultiplicity.value;
            this.appendChild(multiplicityInput);
          }
        } else {
          // Convert form data to JSON format for options
          const optionsData = [];

          // Check all option containers
          const optionContainers = document.querySelectorAll('.question-option-item');
          optionContainers.forEach((container, index) => {
            const textInput = container.querySelector('input[type="text"].option-text-input');
            const radioInput = container.querySelector('input[type="radio"]');

            if (textInput) {
              const optionText = textInput.value.trim();
              if (optionText) {
                optionsData.push({
                  text: optionText,
                  isCorrect: correctAnswer && index.toString() === correctAnswer.value
                });
              }
            }
          });

          // Add hidden input with options JSON
          const existingOptionsInput = this.querySelector('input[name="options"]');
          if (existingOptionsInput) {
            existingOptionsInput.remove();
          }

          const optionsInput = document.createElement('input');
          optionsInput.type = 'hidden';
          optionsInput.name = 'options';
          optionsInput.value = JSON.stringify(optionsData);
          this.appendChild(optionsInput);
        }

        // Show loading state
        const submitBtn = this.querySelector('button[type="submit"]');
        const originalText = submitBtn.innerHTML;
        submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Creating...';
        submitBtn.disabled = true;

        // Prevent default form submission and handle with fetch
        e.preventDefault();

        // Create JSON data from the form
        const formData = new FormData(this);
        const jsonData = {};

        // Convert FormData to JSON object
        for (let [key, value] of formData.entries()) {
          if (jsonData[key]) {
            // Handle arrays (like correctAnswers, answerMandatory) but not single-value fields
            if (key === 'correctAnswers' || key === 'answerMandatory') {
              if (Array.isArray(jsonData[key])) {
                jsonData[key].push(value);
              } else {
                jsonData[key] = [jsonData[key], value];
              }
            }
            // For single-value fields like answerMultiplicity, keep the latest value
            else {
              jsonData[key] = value;
            }
          } else {
            jsonData[key] = value;
          }
        }

        // Debug logging
        console.log('Sending data to server:', {
          questionType: jsonData.questionType,
          correctAnswers: jsonData.correctAnswers,
          answerMandatory: jsonData.answerMandatory,
          answerMultiplicity: jsonData.answerMultiplicity,
          allKeys: Object.keys(jsonData)
        });

        // Submit via fetch
        fetch(this.action, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(jsonData)
          })
          .then(response => {
            // Check if response is JSON
            const contentType = response.headers.get('content-type');
            if (!contentType || !contentType.includes('application/json')) {
              throw new Error(`Server returned ${response.status}: ${response.statusText}. Expected JSON but got ${contentType}`);
            }
            return response.json();
          })
          .then(data => {
            if (data.success) {
              showNotification(data.message, 'success');
              // Close modal and reload page
              const modal = bootstrap.Modal.getInstance(document.getElementById('createQuestionModal'));
              modal.hide();
              setTimeout(() => {
                window.location.reload();
              }, 1000);
            } else {
              showNotification(data.message, 'error');
            }
          })
          .catch(error => {
            console.error('Error:', error);
            showNotification('An error occurred while creating the question: ' + error.message, 'error');
          })
          .finally(() => {
            // Reset button state
            submitBtn.innerHTML = originalText;
            submitBtn.disabled = false;
          });

        return false;
      });
    }
  });

  // Edit form submission handler
  document.addEventListener('DOMContentLoaded', function() {
    const editForm = document.getElementById('editQuestionForm');
    if (editForm) {
      editForm.addEventListener('submit', function(e) {
        // Get question text from textarea
        const questionTextElement = document.getElementById('editQuestionText');
        const finalQuestionText = questionTextElement ? questionTextElement.value.trim() : '';
        console.log('Edit Question text:', finalQuestionText);

        // Update the hidden field with the final question text
        const hiddenQuestionText = document.getElementById('editHiddenQuestionText');
        if (hiddenQuestionText) {
          hiddenQuestionText.value = finalQuestionText;
        }

        const questionType = document.getElementById('editQuestionType').value;
        const options = document.querySelectorAll('input[name="editOptionText"]');
        const correctAnswer = document.querySelector('input[name="editCorrectAnswer"]:checked');

        // Clear previous errors
        clearEditFormErrors();

        let hasErrors = false;

        // Validate question text
        if (!finalQuestionText) {
          showEditFieldError('editQuestionText', 'Question text is required');
          hasErrors = true;
        } else if (finalQuestionText.length < 10) {
          showEditFieldError('editQuestionText', `Question text must be at least 10 characters (currently ${finalQuestionText.length})`);
          hasErrors = true;
        }

        // Validate question type
        if (!questionType) {
          showEditFieldError('editQuestionType', 'Please select a question type');
          hasErrors = true;
        }

        // Validate based on question type
        if (questionType === 'Written') {
          const correctAnswers = document.querySelectorAll('#editCorrectAnswersContainer input[name="editCorrectAnswers"]');
          const filledAnswers = Array.from(correctAnswers).filter(input => input.value.trim());
          const answerMultiplicity = document.querySelector('input[name="editAnswerMultiplicity"]:checked');

          if (filledAnswers.length === 0) {
            showEditFieldError('editWrittenAnswers', 'Written questions must have at least one correct answer');
            hasErrors = true;
          } else if (answerMultiplicity && answerMultiplicity.value === 'single' && filledAnswers.length !== 1) {
            showEditFieldError('editWrittenAnswers', 'Single answer questions must have exactly one correct answer');
            hasErrors = true;
          }
        } else {
          // Validate options based on question type
          if (questionType === 'True/False') {
            if (options.length !== 2) {
              showEditFieldError('editOptions', 'True/False questions must have exactly 2 options');
              hasErrors = true;
            } else {
              const optionTexts = Array.from(options).map(input => input.value.toLowerCase().trim());
              if (!optionTexts.includes('true') || !optionTexts.includes('false')) {
                showEditFieldError('editOptions', 'True/False questions must have "True" and "False" as options');
                hasErrors = true;
              }
            }
          } else if (questionType === 'MCQ') {
            if (options.length < 2) {
              showEditFieldError('editOptions', 'MCQ questions must have at least 2 options');
              hasErrors = true;
            }
          }

          // Validate correct answer selection
          if (!correctAnswer) {
            showEditFieldError('editOptions', 'Please select the correct answer');
            hasErrors = true;
          }
        }

        if (hasErrors) {
          e.preventDefault();
          return;
        }

        // Show loading state
        const submitBtn = this.querySelector('button[type="submit"]');
        const originalText = submitBtn.innerHTML;
        submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Updating...';
        submitBtn.disabled = true;

        // Prevent default form submission and handle with fetch
        e.preventDefault();

        // Process form data based on question type
        if (questionType === 'Written') {
          // Collect answers and mandatory flags
          const answersData = [];
          const mandatoryData = [];

          // Check all answer containers
          const answerContainers = document.querySelectorAll('#editCorrectAnswersContainer .question-option-item');
          answerContainers.forEach((container, index) => {
            const textInput = container.querySelector('input[name="editCorrectAnswers"]');
            const mandatoryCheckbox = container.querySelector('input[name="editAnswerMandatory"]');

            if (textInput && textInput.value.trim()) {
              answersData.push(textInput.value.trim());
              mandatoryData.push(mandatoryCheckbox ? mandatoryCheckbox.checked : true);
            }
          });

          // Clear existing hidden inputs
          const existingAnswersInputs = this.querySelectorAll('input[name="correctAnswers"]');
          const existingMandatoryInputs = this.querySelectorAll('input[name="answerMandatory"]');
          existingAnswersInputs.forEach(input => input.remove());
          existingMandatoryInputs.forEach(input => input.remove());

          // Add new hidden inputs for answers
          answersData.forEach((answer, index) => {
            const answerInput = document.createElement('input');
            answerInput.type = 'hidden';
            answerInput.name = 'correctAnswers';
            answerInput.value = answer;
            this.appendChild(answerInput);
          });

          // Add new hidden inputs for mandatory flags
          mandatoryData.forEach((isMandatory, index) => {
            const mandatoryInput = document.createElement('input');
            mandatoryInput.type = 'hidden';
            mandatoryInput.name = 'answerMandatory';
            mandatoryInput.value = isMandatory;
            this.appendChild(mandatoryInput);
          });

          // Add answer multiplicity field
          const answerMultiplicity = document.querySelector('input[name="editAnswerMultiplicity"]:checked');
          if (answerMultiplicity) {
            const multiplicityInput = document.createElement('input');
            multiplicityInput.type = 'hidden';
            multiplicityInput.name = 'answerMultiplicity';
            multiplicityInput.value = answerMultiplicity.value;
            this.appendChild(multiplicityInput);
          }
        } else {
          // Convert form data to JSON format for options
          const optionsData = [];

          // Check all option containers
          const optionContainers = document.querySelectorAll('#editOptionsContainer .question-option-item');
          optionContainers.forEach((container, index) => {
            const textInput = container.querySelector('input[type="text"].option-text-input');
            const radioInput = container.querySelector('input[type="radio"]');

            if (textInput) {
              const optionText = textInput.value.trim();
              if (optionText) {
                optionsData.push({
                  text: optionText,
                  isCorrect: correctAnswer && index.toString() === correctAnswer.value
                });
              }
            }
          });

          // Add hidden input with options JSON
          const existingOptionsInput = this.querySelector('input[name="options"]');
          if (existingOptionsInput) {
            existingOptionsInput.remove();
          }

          const optionsInput = document.createElement('input');
          optionsInput.type = 'hidden';
          optionsInput.name = 'options';
          optionsInput.value = JSON.stringify(optionsData);
          this.appendChild(optionsInput);
        }

        // Create JSON data from the form
        const formData = new FormData(this);
        const jsonData = {};

        // Convert FormData to JSON object
        for (let [key, value] of formData.entries()) {
          if (jsonData[key]) {
            // Handle arrays (like correctAnswers, answerMandatory) but not single-value fields
            if (key === 'correctAnswers' || key === 'answerMandatory') {
              if (Array.isArray(jsonData[key])) {
                jsonData[key].push(value);
              } else {
                jsonData[key] = [jsonData[key], value];
              }
            }
            // For single-value fields like answerMultiplicity, keep the latest value
            else {
              jsonData[key] = value;
            }
          } else {
            jsonData[key] = value;
          }
        }

        // Explicitly ensure tags are included from the input field
        const tagsInput = document.getElementById('editQuestionTags');
        if (tagsInput) {
          const tagsValue = tagsInput.value.trim();
          const originalTags = tagsInput.getAttribute('data-original-tags') || '';
          
          // Warn if tags are being removed
          if (originalTags && !tagsValue) {
            const confirmRemove = confirm(
              `Warning: You are about to remove all tags from this question.\n\n` +
              `Original tags: ${originalTags}\n\n` +
              `Are you sure you want to continue?`
            );
            
            if (!confirmRemove) {
              // Restore original tags
              tagsInput.value = originalTags;
              submitBtn.innerHTML = originalText;
              submitBtn.disabled = false;
              return;
            }
          }
          
          // Always include tags field, even if empty (so server knows to preserve/clear tags)
          jsonData.tags = tagsValue;
          console.log('Tags from input field:', tagsValue);
          console.log('Original tags:', originalTags);
        } else {
          // If input not found, set empty string to preserve existing behavior
          jsonData.tags = '';
          console.warn('editQuestionTags input not found, setting tags to empty string');
        }

        // Debug logging
        console.log('Sending update data to server:', {
          questionType: jsonData.questionType,
          correctAnswers: jsonData.correctAnswers,
          answerMandatory: jsonData.answerMandatory,
          answerMultiplicity: jsonData.answerMultiplicity,
          tags: jsonData.tags,
          allKeys: Object.keys(jsonData)
        });

        // Submit via fetch
        fetch(this.action, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(jsonData)
          })
          .then(response => {
            // Check if response is JSON
            const contentType = response.headers.get('content-type');
            if (!contentType || !contentType.includes('application/json')) {
              throw new Error(`Server returned ${response.status}: ${response.statusText}. Expected JSON but got ${contentType}`);
            }
            return response.json();
          })
          .then(data => {
            if (data.success) {
              showNotification(data.message, 'success');
              
              // Close modal
              const modal = bootstrap.Modal.getInstance(document.getElementById('editQuestionModal'));
              modal.hide();
              
              // Update the question card in the DOM without reloading
              setTimeout(() => {
                updateQuestionCardInDOM(data.question);
                
                // Re-initialize questions array
                reinitializeQuestionsArray();
                
                // Show success animation
                const questionCard = document.querySelector(`[data-question-id="${data.question._id}"]`);
                if (questionCard) {
                  questionCard.style.animation = 'none';
                  setTimeout(() => {
                    questionCard.style.animation = 'pulse 0.5s ease';
                  }, 10);
                }
              }, 300);
            } else {
              showNotification(data.message, 'error');
            }
          })
          .catch(error => {
            console.error('Error:', error);
            showNotification('An error occurred while updating the question: ' + error.message, 'error');
          })
          .finally(() => {
            // Reset button state
            submitBtn.innerHTML = originalText;
            submitBtn.disabled = false;
          });

        return false;
      });
    }
  });

  // Helper functions for edit form validation
  function showEditFieldError(fieldId, message) {
    const field = document.getElementById(fieldId);
    const errorDiv = document.getElementById(fieldId + 'Error');

    if (field) {
      field.classList.add('is-invalid');
    }

    if (errorDiv) {
      errorDiv.textContent = message;
      errorDiv.style.display = 'block';
    }
  }

  function clearEditFormErrors() {
    const invalidFields = document.querySelectorAll('#editQuestionModal .is-invalid');
    const errorMessages = document.querySelectorAll('#editQuestionModal .invalid-feedback');

    invalidFields.forEach(field => field.classList.remove('is-invalid'));
    errorMessages.forEach(error => {
      error.style.display = 'none';
      error.textContent = '';
    });
  }

  // Helper functions for form validation
  function showFieldError(fieldId, message) {
    const field = document.getElementById(fieldId);
    const errorDiv = document.getElementById(fieldId + 'Error');

    if (field) {
      field.classList.add('is-invalid');
    }

    if (errorDiv) {
      errorDiv.textContent = message;
      errorDiv.style.display = 'block';
    }
  }

  function clearFormErrors() {
    const invalidFields = document.querySelectorAll('.is-invalid');
    const errorMessages = document.querySelectorAll('.invalid-feedback');

    invalidFields.forEach(field => field.classList.remove('is-invalid'));
    errorMessages.forEach(error => {
      error.style.display = 'none';
      error.textContent = '';
    });
  }

  // ==================== EDIT QUESTION FUNCTIONALITY ====================

  let editOptionCount = 2;

  // Handle edit question type change
  function handleEditQuestionTypeChange() {
    const questionType = document.getElementById('editQuestionType').value;
    const optionsContainer = document.getElementById('editOptionsContainer');
    const addOptionBtn = document.getElementById('editAddOptionBtn');
    const editAnswerOptionsSection = document.getElementById('editAnswerOptionsSection');
    const editWrittenAnswersSection = document.getElementById('editWrittenAnswersSection');
    const editCorrectAnswersContainer = document.getElementById('editCorrectAnswersContainer');

    // Hide both sections first
    editAnswerOptionsSection.style.display = 'none';
    editWrittenAnswersSection.style.display = 'none';

    if (questionType === 'True/False') {
      // Show the answer options section
      editAnswerOptionsSection.style.display = 'block';

      // Clear and recreate options for True/False
      optionsContainer.innerHTML = `
      <div class="question-option-item">
        <div class="option-content">
          <div class="option-radio">
            <input type="radio" name="editCorrectAnswer" value="0" class="option-radio-input" id="editTrueOption">
            <label for="editTrueOption" class="option-radio-label">True</label>
          </div>
          <input type="text" class="option-text-input" name="editOptionText" 
                 placeholder="True" value="True" required readonly>
        </div>
      </div>
      <div class="question-option-item">
        <div class="option-content">
          <div class="option-radio">
            <input type="radio" name="editCorrectAnswer" value="1" class="option-radio-input" id="editFalseOption">
            <label for="editFalseOption" class="option-radio-label">False</label>
          </div>
          <input type="text" class="option-text-input" name="editOptionText" 
                 placeholder="False" value="False" required readonly>
        </div>
      </div>
    `;
      addOptionBtn.style.display = 'none';
      editOptionCount = 2;
    } else if (questionType === 'MCQ') {
      // Show the answer options section
      editAnswerOptionsSection.style.display = 'block';

      // Clear and recreate options for MCQ
      optionsContainer.innerHTML = `
      <div class="question-option-item">
        <div class="option-content">
          <div class="option-radio">
            <input type="radio" name="editCorrectAnswer" value="0" class="option-radio-input" id="editOptionA">
            <label for="editOptionA" class="option-radio-label">A</label>
          </div>
          <input type="text" class="form-control option-text-input" name="editOptionText" 
                 placeholder="Enter option A (use $...$ for math)" id="editOptionText_A">
          <button type="button" class="option-remove-btn" onclick="removeEditOption(this)" style="display: none;">
            <i class="fas fa-trash"></i>
          </button>
        </div>
      </div>
      <div class="question-option-item">
        <div class="option-content">
          <div class="option-radio">
            <input type="radio" name="editCorrectAnswer" value="1" class="option-radio-input" id="editOptionB">
            <label for="editOptionB" class="option-radio-label">B</label>
          </div>
          <input type="text" class="form-control option-text-input" name="editOptionText" 
                 placeholder="Enter option B (use $...$ for math)" id="editOptionText_B">
          <button type="button" class="option-remove-btn" onclick="removeEditOption(this)" style="display: none;">
            <i class="fas fa-trash"></i>
          </button>
        </div>
      </div>
    `;
      addOptionBtn.style.display = 'block';
      editOptionCount = 2;
    } else if (questionType === 'Written') {
      // Show the written answers section
      editWrittenAnswersSection.style.display = 'block';

      // Create initial correct answer input with checkbox for mandatory (first answer is always mandatory)
      editCorrectAnswersContainer.innerHTML = `
      <div class="question-option-item">
        <div class="option-content">
          <div class="option-checkbox">
            <input type="checkbox" name="editAnswerMandatory" value="true" class="option-checkbox-input" id="editMandatory0" checked disabled>
            <label for="editMandatory0" class="option-checkbox-label mandatory-always">
              <i class="fas fa-lock"></i>
              <span class="mandatory-text">Mandatory</span>
            </label>
          </div>
          <input type="text" class="option-text-input" name="editCorrectAnswers" 
                 placeholder="Enter correct answer (use $...$ for math)...">
          <button type="button" class="option-remove-btn" onclick="removeEditCorrectAnswer(this)" style="display: none;">
            <i class="fas fa-trash"></i>
          </button>
        </div>
      </div>
    `;

      // Update remove buttons visibility
      updateEditAnswerRemoveButtons();

      // Add event listeners for edit answer multiplicity radio buttons
      const editSingleAnswerRadio = document.getElementById('editSingleAnswer');
      const editMultipleAnswersRadio = document.getElementById('editMultipleAnswers');
      const editAddAnswerBtn = document.getElementById('editAddAnswerBtn');

      if (editSingleAnswerRadio && editMultipleAnswersRadio && editAddAnswerBtn) {
        // Set initial state based on selected radio button
        if (editSingleAnswerRadio.checked) {
          editAddAnswerBtn.style.display = 'none';
        } else if (editMultipleAnswersRadio.checked) {
          editAddAnswerBtn.style.display = 'block';
        }

        editSingleAnswerRadio.addEventListener('change', function() {
          if (this.checked) {
            // For single answer, hide the add button and ensure only one answer
            editAddAnswerBtn.style.display = 'none';
            const answers = document.querySelectorAll('#editCorrectAnswersContainer .question-option-item');
            if (answers.length > 1) {
              // Remove extra answers, keep only the first one
              for (let i = 1; i < answers.length; i++) {
                answers[i].remove();
              }
            }
            updateEditAnswerRemoveButtons();
          }
        });

        editMultipleAnswersRadio.addEventListener('change', function() {
          if (this.checked) {
            // For multiple answers, show the add button
            editAddAnswerBtn.style.display = 'block';
            updateEditAnswerRemoveButtons();
          }
        });
      }
    } else {
      // Hide all sections when no type selected
      editAnswerOptionsSection.style.display = 'none';
      editWrittenAnswersSection.style.display = 'none';
      addOptionBtn.style.display = 'none';
    }
  }

  // Add new option for edit
  function addEditOption() {
    const container = document.getElementById('editOptionsContainer');
    const optionItem = document.createElement('div');
    optionItem.className = 'question-option-item';
    const optionLetter = String.fromCharCode(65 + editOptionCount);
    optionItem.innerHTML = `
    <div class="option-content">
      <div class="option-radio">
        <input type="radio" name="editCorrectAnswer" value="${editOptionCount}" class="option-radio-input" id="editOption${optionLetter}">
        <label for="editOption${optionLetter}" class="option-radio-label">${optionLetter}</label>
      </div>
      <input type="text" class="form-control option-text-input" name="editOptionText" 
             placeholder="Enter option ${optionLetter} (use $...$ for math)" id="editOptionText_${optionLetter}">
      <button type="button" class="option-remove-btn" onclick="removeEditOption(this)">
        <i class="fas fa-trash"></i>
      </button>
    </div>
  `;
    container.appendChild(optionItem);
    editOptionCount++;
  }

  // Remove option for edit
  function removeEditOption(button) {
    const optionItem = button.closest('.question-option-item');
    const optionsContainer = document.getElementById('editOptionsContainer');
    const currentOptions = optionsContainer.querySelectorAll('.question-option-item');

    // Ensure minimum 2 options for MCQ questions
    if (currentOptions.length <= 2) {
      showNotification('MCQ questions must have at least 2 options', 'warning');
      return;
    }

    optionItem.remove();

    // Update option numbering after removal
    updateEditOptionNumbering();
  }

  // Add new correct answer for edit
  function addEditCorrectAnswer() {
    const container = document.getElementById('editCorrectAnswersContainer');
    const answerCount = container.querySelectorAll('.question-option-item').length;
    const answerItem = document.createElement('div');
    answerItem.className = 'question-option-item';
    answerItem.innerHTML = `
    <div class="option-content">
      <div class="option-checkbox">
        <input type="checkbox" name="editAnswerMandatory" value="true" class="option-checkbox-input" id="editMandatory${answerCount}" checked>
        <label for="editMandatory${answerCount}" class="option-checkbox-label">
          <i class="fas fa-check"></i>
          <span class="mandatory-text">Mandatory</span>
        </label>
      </div>
      <input type="text" class="option-text-input" name="editCorrectAnswers" 
             placeholder="Enter correct answer (use $...$ for math)...">
      <button type="button" class="option-remove-btn" onclick="removeEditCorrectAnswer(this)">
        <i class="fas fa-trash"></i>
      </button>
    </div>
  `;
    container.appendChild(answerItem);

    // Show remove buttons if more than one answer
    updateEditAnswerRemoveButtons();
  }

  // Remove correct answer for edit
  function removeEditCorrectAnswer(button) {
    const answerItem = button.closest('.question-option-item');
    const container = document.getElementById('editCorrectAnswersContainer');
    const currentAnswers = container.querySelectorAll('.question-option-item');

    // Ensure minimum 1 answer
    if (currentAnswers.length <= 1) {
      showNotification('Written questions must have at least one correct answer', 'warning');
      return;
    }

    answerItem.remove();
    updateEditAnswerRemoveButtons();
  }

  // Update edit answer remove buttons visibility
  function updateEditAnswerRemoveButtons() {
    const container = document.getElementById('editCorrectAnswersContainer');
    const answers = container.querySelectorAll('.question-option-item');
    const removeButtons = container.querySelectorAll('.option-remove-btn');

    removeButtons.forEach(button => {
      button.style.display = answers.length > 1 ? 'block' : 'none';
    });
  }

  // Helper function to populate edit options with values
  function populateEditOptions(options, optionsContainer) {
    options.forEach((option, index) => {
      const optionItem = optionsContainer.querySelectorAll('.question-option-item')[index];
      if (optionItem) {
        const textInput = optionItem.querySelector('input[type="text"].option-text-input');
        const radioInput = optionItem.querySelector('input[type="radio"]');
        
        // Populate text input
        if (textInput) {
          textInput.value = option.text || '';
        }
        
        // Set correct answer radio
        if (option.isCorrect && radioInput) {
          radioInput.checked = true;
        }
      }
    });
  }

  // Setup create modal event listeners
  function setupCreateModalEvents() {
    const createModal = document.getElementById('createQuestionModal');
    if (createModal) {
      // Use 'shown.bs.modal' to ensure modal is fully visible
      createModal.addEventListener('shown.bs.modal', function() {
        // Clear tags input
        const tagsInput = document.getElementById('tags');
        if (tagsInput) {
          tagsInput.value = '';
          
          // Function to remove a tag from create form with animation
          const removeCreateTag = function(tagToRemove, badgeElement) {
            // Add removing animation
            if (badgeElement) {
              badgeElement.classList.add('removing');
              // Wait for animation to complete
              setTimeout(() => {
                const currentTags = tagsInput.value.trim();
                const tags = currentTags.split(',').map(t => t.trim()).filter(t => t);
                const updatedTags = tags.filter(tag => tag !== tagToRemove);
                tagsInput.value = updatedTags.join(', ');
                updateCreateTagsPreview();
              }, 400);
            } else {
              const currentTags = tagsInput.value.trim();
              const tags = currentTags.split(',').map(t => t.trim()).filter(t => t);
              const updatedTags = tags.filter(tag => tag !== tagToRemove);
              tagsInput.value = updatedTags.join(', ');
              updateCreateTagsPreview();
            }
          };
          
          // Setup live preview for create form tags
          const updateCreateTagsPreview = function() {
            const currentTags = tagsInput.value.trim();
            const tagsPreview = document.getElementById('createTagsPreview');
            const tagsHelp = document.getElementById('createTagsHelp');
            
            // Show tag preview with remove buttons
            if (currentTags && tagsPreview) {
              const tags = currentTags.split(',').map(t => t.trim()).filter(t => t);
              if (tags.length > 0) {
                tagsPreview.innerHTML = `
                  <div style="display: flex; flex-wrap: wrap; gap: 6px; padding: 10px; background: #f8f9fa; border-radius: 6px; border: 1px solid #e9ecef;">
                    ${tags.map(tag => `
                      <span class="editable-tag-badge-create" data-tag="${tag.replace(/"/g, '&quot;')}" 
                            style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; padding: 4px 10px 4px 12px; border-radius: 12px; font-size: 11px; font-weight: 600; display: inline-flex; align-items: center; gap: 6px; cursor: pointer; transition: all 0.2s ease;">
                        <i class="fas fa-tag" style="font-size: 9px;"></i>
                        <span>${tag}</span>
                        <i class="fas fa-times" style="font-size: 10px; opacity: 0.8; padding: 2px; border-radius: 50%; transition: all 0.2s ease;"></i>
                      </span>
                    `).join('')}
                    <span style="color: #6b7280; font-size: 11px; padding: 4px 10px; display: inline-flex; align-items: center;">
                      <i class="fas fa-info-circle me-1"></i>
                      ${tags.length} tag${tags.length !== 1 ? 's' : ''} (click × to remove)
                    </span>
                  </div>
                `;
                
                // Add click handlers to remove tags
                const tagBadges = tagsPreview.querySelectorAll('.editable-tag-badge-create');
                tagBadges.forEach(badge => {
                  badge.addEventListener('click', function(e) {
                    e.preventDefault();
                    const tagToRemove = this.getAttribute('data-tag');
                    removeCreateTag(tagToRemove, this);
                  });
                  
                  // Add hover effect
                  badge.addEventListener('mouseenter', function() {
                    this.style.background = 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)';
                    this.style.transform = 'scale(1.05)';
                  });
                  
                  badge.addEventListener('mouseleave', function() {
                    this.style.background = 'linear-gradient(135deg, #10b981 0%, #059669 100%)';
                    this.style.transform = 'scale(1)';
                  });
                });
                
                tagsPreview.style.display = 'block';
                if (tagsHelp) tagsHelp.style.display = 'none';
              } else {
                tagsPreview.style.display = 'none';
                if (tagsHelp) tagsHelp.style.display = 'block';
              }
            } else {
              if (tagsPreview) tagsPreview.style.display = 'none';
              if (tagsHelp) tagsHelp.style.display = 'block';
            }
          };
          
          // Remove old listener if exists
          tagsInput.removeEventListener('input', updateCreateTagsPreview);
          // Add new listener
          tagsInput.addEventListener('input', updateCreateTagsPreview);
        }
        
        // Load previous tags with a small delay to ensure DOM is ready
        setTimeout(function() {
          loadPreviousTagsForCreate();
        }, 100);
      });
    }
  }

  // Setup edit modal tag input handlers
  function setupEditModalTagHandlers() {
    // Use event delegation since the modal might not be in DOM initially
    document.addEventListener('focus', function(e) {
      if (e.target && e.target.id === 'editQuestionTags') {
        // Ensure previous tags are loaded when user focuses on tags input
        // Get current question's tags from the input
        const currentTags = e.target.value.trim();
        const tagsArray = currentTags ? currentTags.split(',').map(t => t.trim()).filter(t => t) : [];
        setTimeout(function() {
          loadPreviousTags(tagsArray);
        }, 100);
      }
    }, true); // Use capture phase to catch the event early

    // Also handle click events
    document.addEventListener('click', function(e) {
      if (e.target && e.target.id === 'editQuestionTags') {
        // Ensure previous tags are loaded when user clicks on tags input
        // Get current question's tags from the input
        const currentTags = e.target.value.trim();
        const tagsArray = currentTags ? currentTags.split(',').map(t => t.trim()).filter(t => t) : [];
        setTimeout(function() {
          loadPreviousTags(tagsArray);
        }, 100);
      }
    });
  }

  // Setup edit bank form
  function setupEditBankForm() {
    const editBankForm = document.getElementById('editBankForm');
    if (editBankForm) {
      editBankForm.addEventListener('submit', function(e) {
        e.preventDefault();

        // Get form data
        const formData = new FormData(this);
        const bankData = {
          name: formData.get('name'),
          description: formData.get('description'),
          status: formData.get('status'),
          testType: formData.get('testType'),
          tags: formData.get('tags')
        };

        // Validate form
        if (!bankData.name) {
          showNotification('Please fill in all required fields', 'error');
          return;
        }

        // Show loading state
        const submitBtn = this.querySelector('button[type="submit"]');
        const originalText = submitBtn.innerHTML;
        submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Updating...';
        submitBtn.disabled = true;

        // Send AJAX request
        fetch(`/admin/question-banks/banks/<%= questionBank.bankCode %>`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(bankData)
          })
          .then(response => {
            if (response.ok) {
              return response.json();
            } else {
              throw new Error('Failed to update question bank');
            }
          })
          .then(data => {
            showNotification('Question bank updated successfully!', 'success');

            // Update the page content
            updateBankInfo(bankData);

            // Close modal
            const modal = bootstrap.Modal.getInstance(document.getElementById('editBankModal'));
            modal.hide();
          })
          .catch(error => {
            console.error('Error:', error);
            showNotification('Error updating question bank. Please try again.', 'error');
          })
          .finally(() => {
            // Reset button state
            submitBtn.innerHTML = originalText;
            submitBtn.disabled = false;
          });
      });
    }
  }

  // Update bank info on the page
  function updateBankInfo(bankData) {
    // Update bank name in header
    const bankTitle = document.querySelector('.admin-dashboard-title');
    if (bankTitle) {
      bankTitle.textContent = bankData.name;
    }

    // Update bank description
    const bankSubtitle = document.querySelector('.admin-dashboard-subtitle');
    if (bankSubtitle) {
      bankSubtitle.textContent = bankData.description;
    }

    // Update status badge
    const statusBadge = document.querySelector('.admin-status-badge');
    if (statusBadge) {
      statusBadge.className = `admin-status-badge admin-status-${bankData.status}`;
      statusBadge.innerHTML = `<i class="fas fa-circle me-1"></i>${bankData.status.charAt(0).toUpperCase() + bankData.status.slice(1)}`;
    }

    // Update breadcrumb
    const breadcrumbSubtitle = document.querySelector('.breadcrumb-subtitle');
    if (breadcrumbSubtitle) {
      breadcrumbSubtitle.textContent = bankData.name;
    }

    // Update test type in bank info card if it exists
    const testTypeElements = document.querySelectorAll('.info-value');
    testTypeElements.forEach(el => {
      const label = el.previousElementSibling;
      if (label && label.textContent.includes('Test Type')) {
        el.textContent = bankData.testType || 'Not specified';
      }
    });
  }

  // Load previous tags from all questions in the bank (for edit modal)
  // currentQuestionTags: array of tags from the question being edited
  function loadPreviousTags(currentQuestionTags = []) {
    const allTags = new Set();

    // First, add the current question's tags (so they appear in the list)
    if (currentQuestionTags && Array.isArray(currentQuestionTags)) {
      currentQuestionTags.forEach(tag => {
        if (tag && tag.trim()) {
          allTags.add(tag.trim());
        }
      });
    }

    // Collect all tags from existing questions in the DOM
    const questionCards = document.querySelectorAll('.question-card-modern');
    
    questionCards.forEach(card => {
      const tags = card.getAttribute('data-tags');
      if (tags && tags.trim()) {
        // Split by comma and add each tag
        tags.split(',').forEach(tag => {
          const trimmedTag = tag.trim();
          if (trimmedTag) {
            allTags.add(trimmedTag);
          }
        });
      }
    });

    // Also check if there are tags in the question bank itself
    const bankTagsElement = document.querySelector('.info-tags-section[data-bank-tags]');
    if (bankTagsElement) {
      const bankTags = bankTagsElement.getAttribute('data-bank-tags');
      if (bankTags && bankTags.trim()) {
        bankTags.split(',').forEach(tag => {
          const trimmedTag = tag.trim();
          if (trimmedTag) {
            allTags.add(trimmedTag);
          }
        });
      }
    }

    // Display previous tags
    const previousTagsContainer = document.getElementById('previousTagsContainer');
    const previousTagsSection = document.getElementById('previousTagsSection');

    if (!previousTagsContainer || !previousTagsSection) {
      console.error('Previous tags container elements not found for edit modal');
      return;
    }

    if (allTags.size > 0) {
      previousTagsContainer.innerHTML = '';
      // Sort tags alphabetically for better UX
      const sortedTags = Array.from(allTags).sort();
      
      sortedTags.forEach(tag => {
        const tagElement = document.createElement('span');
        tagElement.className = 'previous-tag';
        tagElement.textContent = tag;
        tagElement.style.cursor = 'pointer';
        tagElement.title = 'Click to add this tag';
        // Use arrow function to preserve tag value in closure
        tagElement.addEventListener('click', function(e) {
          e.preventDefault();
          e.stopPropagation();
          addTagToInput(tag, this);
        });
        previousTagsContainer.appendChild(tagElement);
      });
      previousTagsSection.style.display = 'block';
    } else {
      previousTagsSection.style.display = 'none';
    }
  }

  // Load previous tags for create modal
  function loadPreviousTagsForCreate() {
    const allTags = new Set();

    // Collect all tags from existing questions
    const questionCards = document.querySelectorAll('.question-card-modern');
    
    questionCards.forEach(card => {
      const tags = card.getAttribute('data-tags');
      if (tags && tags.trim()) {
        // Split by comma and add each tag
        tags.split(',').forEach(tag => {
          const trimmedTag = tag.trim();
          if (trimmedTag) {
            allTags.add(trimmedTag);
          }
        });
      }
    });

    // Also check if there are tags in the question bank itself
    const bankTagsElement = document.querySelector('.info-tags-section[data-bank-tags]');
    if (bankTagsElement) {
      const bankTags = bankTagsElement.getAttribute('data-bank-tags');
      if (bankTags && bankTags.trim()) {
        bankTags.split(',').forEach(tag => {
          const trimmedTag = tag.trim();
          if (trimmedTag) {
            allTags.add(trimmedTag);
          }
        });
      }
    }

    // Display previous tags
    const previousTagsContainer = document.getElementById('createPreviousTagsContainer');
    const previousTagsSection = document.getElementById('createPreviousTagsSection');

    if (!previousTagsContainer || !previousTagsSection) {
      console.error('Previous tags container elements not found');
      return;
    }

    if (allTags.size > 0) {
      previousTagsContainer.innerHTML = '';
      // Sort tags alphabetically for better UX
      const sortedTags = Array.from(allTags).sort();
      
      sortedTags.forEach(tag => {
        const tagElement = document.createElement('span');
        tagElement.className = 'previous-tag';
        tagElement.textContent = tag;
        tagElement.onclick = function() { addTagToCreateInput(tag, this); };
        previousTagsContainer.appendChild(tagElement);
      });
      previousTagsSection.style.display = 'block';
    } else {
      previousTagsSection.style.display = 'none';
    }
  }

  // Add tag to input field (for edit modal)
  function addTagToInput(tag, element) {
    console.log('addTagToInput called with tag:', tag);
    const tagsInput = document.getElementById('editQuestionTags');
    if (!tagsInput) {
      console.error('editQuestionTags input not found');
      return;
    }

    const currentTags = tagsInput.value.trim();
    const trimmedTag = tag.trim();

    if (!trimmedTag) {
      console.warn('Empty tag provided');
      return;
    }

    if (currentTags) {
      const tags = currentTags.split(',').map(t => t.trim()).filter(t => t.length > 0);
      // Case-insensitive check to avoid duplicates
      const tagExists = tags.some(t => t.toLowerCase() === trimmedTag.toLowerCase());
      if (!tagExists) {
        tagsInput.value = currentTags + ', ' + trimmedTag;
        console.log('Tag added. New value:', tagsInput.value);
        // Trigger input event to ensure form validation works
        tagsInput.dispatchEvent(new Event('input', { bubbles: true }));
        tagsInput.dispatchEvent(new Event('change', { bubbles: true }));
      } else {
        console.log('Tag already exists, skipping');
      }
    } else {
      tagsInput.value = trimmedTag;
      console.log('Tag set as first tag. New value:', tagsInput.value);
      // Trigger input event to ensure form validation works
      tagsInput.dispatchEvent(new Event('input', { bubbles: true }));
      tagsInput.dispatchEvent(new Event('change', { bubbles: true }));
    }

    // Focus the input field
    tagsInput.focus();

    // Highlight the clicked tag
    if (element) {
      element.classList.add('tag-selected');
      setTimeout(() => {
        element.classList.remove('tag-selected');
      }, 1000);
    }
  }

  // Add tag to create input field
  function addTagToCreateInput(tag, element) {
    const tagsInput = document.getElementById('tags');
    if (!tagsInput) {
      console.error('tags input not found');
      return;
    }

    const currentTags = tagsInput.value.trim();

    if (currentTags) {
      const tags = currentTags.split(',').map(t => t.trim());
      // Case-insensitive check to avoid duplicates
      const tagExists = tags.some(t => t.toLowerCase() === tag.toLowerCase());
      if (!tagExists) {
        tagsInput.value = currentTags + ', ' + tag;
        // Trigger input event to ensure form validation works
        tagsInput.dispatchEvent(new Event('input', { bubbles: true }));
      }
    } else {
      tagsInput.value = tag;
      // Trigger input event to ensure form validation works
      tagsInput.dispatchEvent(new Event('input', { bubbles: true }));
    }

    // Focus the input field
    tagsInput.focus();

    // Highlight the clicked tag
    if (element) {
      element.classList.add('tag-selected');
      setTimeout(() => {
        element.classList.remove('tag-selected');
      }, 1000);
    }
  }

  // Update questions count after deletion
  function updateQuestionsCount() {
    const questionsCount = document.getElementById('questionsCount');
    const remainingQuestions = document.querySelectorAll('.question-card-modern').length;
    if (questionsCount) {
      questionsCount.textContent = remainingQuestions;
    }
  }

  // ==================== BULK SELECTION AND DELETE ====================
  
  let bulkSelectionMode = false;
  let selectedQuestions = new Set();
  
  // Toggle bulk selection mode
  function toggleBulkSelectionMode() {
    bulkSelectionMode = !bulkSelectionMode;
    
    const bulkModeBtn = document.getElementById('toggleBulkModeBtn');
    const bulkModeText = document.getElementById('bulkModeText');
    const bulkSelectionControls = document.getElementById('bulkSelectionControls');
    const bulkActionsRight = document.getElementById('bulkActionsRight');
    const checkboxWrappers = document.querySelectorAll('.bulk-checkbox-wrapper');
    const questionCards = document.querySelectorAll('.question-card-modern');
    
    if (bulkSelectionMode) {
      // Enable bulk mode
      bulkModeBtn.classList.add('active');
      bulkModeText.textContent = 'Exit Bulk Mode';
      bulkSelectionControls.style.display = 'flex';
      
      // Show checkboxes
      checkboxWrappers.forEach(wrapper => {
        wrapper.style.display = 'flex';
      });
      
      // Add bulk-mode class to question cards
      questionCards.forEach(card => {
        card.classList.add('bulk-mode');
      });
      
      // Populate tag dropdown
      populateBulkTagDropdown();
    } else {
      // Disable bulk mode
      bulkModeBtn.classList.remove('active');
      bulkModeText.textContent = 'Bulk Select';
      bulkSelectionControls.style.display = 'none';
      bulkActionsRight.style.display = 'none';
      
      // Hide checkboxes
      checkboxWrappers.forEach(wrapper => {
        wrapper.style.display = 'none';
      });
      
      // Remove bulk-mode class
      questionCards.forEach(card => {
        card.classList.remove('bulk-mode', 'selected');
      });
      
      // Clear selection
      deselectAllQuestions();
    }
  }
  
  // Populate bulk select by tag dropdown
  function populateBulkTagDropdown() {
    const dropdown = document.getElementById('bulkSelectByTag');
    const allTags = new Set();
    
    document.querySelectorAll('.question-card-modern').forEach(card => {
      const tags = card.getAttribute('data-tags');
      if (tags && tags.trim()) {
        tags.split(',').forEach(tag => {
          const trimmed = tag.trim();
          if (trimmed) allTags.add(trimmed);
        });
      }
    });
    
    // Clear and rebuild options
    dropdown.innerHTML = '<option value="">Select by Tag...</option>';
    Array.from(allTags).sort().forEach(tag => {
      const option = document.createElement('option');
      option.value = tag;
      option.textContent = tag;
      dropdown.appendChild(option);
    });
  }
  
  // Handle checkbox change
  function handleQuestionCheckboxChange(checkbox) {
    const questionId = checkbox.dataset.questionId;
    const card = checkbox.closest('.question-card-modern');
    
    if (checkbox.checked) {
      selectedQuestions.add(questionId);
      card.classList.add('selected');
    } else {
      selectedQuestions.delete(questionId);
      card.classList.remove('selected');
    }
    
    updateSelectedCount();
  }
  
  // Update selected count display
  function updateSelectedCount() {
    const countElement = document.getElementById('selectedCount');
    const bulkActionsRight = document.getElementById('bulkActionsRight');
    
    countElement.textContent = selectedQuestions.size;
    
    if (selectedQuestions.size > 0) {
      bulkActionsRight.style.display = 'flex';
    } else {
      bulkActionsRight.style.display = 'none';
    }
  }
  
  // Select all visible questions
  function selectAllQuestions() {
    document.querySelectorAll('.question-card-modern:not([style*="display: none"])').forEach(card => {
      const checkbox = card.querySelector('.bulk-question-checkbox');
      if (checkbox && !checkbox.checked) {
        checkbox.checked = true;
        selectedQuestions.add(checkbox.dataset.questionId);
        card.classList.add('selected');
      }
    });
    updateSelectedCount();
    showNotification(`Selected ${selectedQuestions.size} questions`, 'success');
  }
  
  // Deselect all questions
  function deselectAllQuestions() {
    document.querySelectorAll('.bulk-question-checkbox').forEach(checkbox => {
      checkbox.checked = false;
    });
    document.querySelectorAll('.question-card-modern').forEach(card => {
      card.classList.remove('selected');
    });
    selectedQuestions.clear();
    updateSelectedCount();
  }
  
  // Select questions by tag
  function selectQuestionsByTag(tag) {
    if (!tag) return;
    
    let count = 0;
    document.querySelectorAll('.question-card-modern').forEach(card => {
      const cardTags = card.getAttribute('data-tags') || '';
      const tagsArray = cardTags.split(',').map(t => t.trim().toLowerCase());
      
      if (tagsArray.includes(tag.toLowerCase())) {
        const checkbox = card.querySelector('.bulk-question-checkbox');
        if (checkbox && !checkbox.checked) {
          checkbox.checked = true;
          selectedQuestions.add(checkbox.dataset.questionId);
          card.classList.add('selected');
          count++;
        }
      }
    });
    
    updateSelectedCount();
    document.getElementById('bulkSelectByTag').value = '';
    
    if (count > 0) {
      showNotification(`Selected ${count} questions with tag "${tag}"`, 'success');
    } else {
      showNotification(`No additional questions found with tag "${tag}"`, 'info');
    }
  }
  
  // Select questions by numbers (e.g., "1,3,5-10")
  function selectQuestionsByNumbers() {
    const input = document.getElementById('bulkSelectByNumbers');
    const numbersStr = input.value.trim();
    
    if (!numbersStr) {
      showNotification('Please enter question numbers', 'warning');
      return;
    }
    
    const numbers = parseNumberRanges(numbersStr);
    if (numbers.length === 0) {
      showNotification('Invalid number format. Use: 1,3,5-10', 'error');
      return;
    }
    
    let count = 0;
    document.querySelectorAll('.question-card-modern').forEach(card => {
      const questionNum = parseInt(card.getAttribute('data-question-number'));
      
      if (numbers.includes(questionNum)) {
        const checkbox = card.querySelector('.bulk-question-checkbox');
        if (checkbox && !checkbox.checked) {
          checkbox.checked = true;
          selectedQuestions.add(checkbox.dataset.questionId);
          card.classList.add('selected');
          count++;
        }
      }
    });
    
    updateSelectedCount();
    input.value = '';
    
    if (count > 0) {
      showNotification(`Selected ${count} questions`, 'success');
    } else {
      showNotification('No additional questions found with those numbers', 'info');
    }
  }
  
  // Parse number ranges (e.g., "1,3,5-10" => [1,3,5,6,7,8,9,10])
  function parseNumberRanges(str) {
    const numbers = [];
    const parts = str.split(',');
    
    parts.forEach(part => {
      part = part.trim();
      if (part.includes('-')) {
        const [start, end] = part.split('-').map(n => parseInt(n.trim()));
        if (!isNaN(start) && !isNaN(end) && start <= end) {
          for (let i = start; i <= end; i++) {
            if (!numbers.includes(i)) numbers.push(i);
          }
        }
      } else {
        const num = parseInt(part);
        if (!isNaN(num) && !numbers.includes(num)) {
          numbers.push(num);
        }
      }
    });
    
    return numbers;
  }
  
  // Show bulk delete confirmation modal
  function showBulkDeleteConfirmation() {
    if (selectedQuestions.size === 0) {
      showNotification('Please select questions to delete', 'warning');
      return;
    }
    
    const count = selectedQuestions.size;
    document.getElementById('bulkDeleteCount').textContent = count;
    document.getElementById('bulkDeleteListCount').textContent = `${count} question${count !== 1 ? 's' : ''}`;
    document.getElementById('confirmDeleteCount').textContent = count;
    
    // Populate questions list
    const listContainer = document.getElementById('bulkDeleteQuestionsList');
    listContainer.innerHTML = '';
    
    let questionIndex = 1;
    selectedQuestions.forEach(questionId => {
      const card = document.querySelector(`.question-card-modern[data-question-id="${questionId}"]`);
      if (card) {
        const questionNum = card.getAttribute('data-question-number');
        const difficulty = card.getAttribute('data-difficulty');
        const tags = card.getAttribute('data-tags') || 'No tags';
        
        // Get question text
        let questionText = '';
        const plainTextEl = card.querySelector('.question-text-plain');
        const mathFieldEl = card.querySelector('.question-math-field');
        if (plainTextEl) {
          questionText = plainTextEl.textContent.trim();
        } else if (mathFieldEl) {
          questionText = mathFieldEl.textContent || mathFieldEl.getAttribute('data-question-text') || '';
        }
        questionText = questionText.substring(0, 80) + (questionText.length > 80 ? '...' : '');
        
        const item = document.createElement('div');
        item.className = 'delete-question-item';
        item.innerHTML = `
          <div class="delete-question-header">
            <span class="delete-question-num">#${questionNum}</span>
            <span class="delete-question-difficulty difficulty-${difficulty.toLowerCase()}">${difficulty}</span>
            <button type="button" class="btn btn-sm btn-outline-secondary" onclick="removeFromBulkDelete('${questionId}')">
              <i class="fas fa-times"></i>
            </button>
          </div>
          <div class="delete-question-text">${questionText}</div>
          <div class="delete-question-tags">
            <i class="fas fa-tags me-1"></i>${tags || 'No tags'}
          </div>
        `;
        listContainer.appendChild(item);
        questionIndex++;
      }
    });
    
    // Show modal
    const modal = new bootstrap.Modal(document.getElementById('bulkDeleteModal'));
    modal.show();
  }
  
  // Remove a question from bulk delete selection
  function removeFromBulkDelete(questionId) {
    selectedQuestions.delete(questionId);
    
    // Update checkbox and card
    const card = document.querySelector(`.question-card-modern[data-question-id="${questionId}"]`);
    if (card) {
      const checkbox = card.querySelector('.bulk-question-checkbox');
      if (checkbox) checkbox.checked = false;
      card.classList.remove('selected');
    }
    
    // Update modal
    const count = selectedQuestions.size;
    if (count === 0) {
      // Close modal if no questions left
      const modal = bootstrap.Modal.getInstance(document.getElementById('bulkDeleteModal'));
      modal.hide();
      updateSelectedCount();
      showNotification('All questions removed from selection', 'info');
      return;
    }
    
    document.getElementById('bulkDeleteCount').textContent = count;
    document.getElementById('bulkDeleteListCount').textContent = `${count} question${count !== 1 ? 's' : ''}`;
    document.getElementById('confirmDeleteCount').textContent = count;
    
    // Remove item from list
    const item = document.querySelector(`.delete-question-item button[onclick*="${questionId}"]`);
    if (item) {
      item.closest('.delete-question-item').remove();
    }
    
    updateSelectedCount();
  }
  
  // Execute bulk delete
  async function executeBulkDelete() {
    if (selectedQuestions.size === 0) return;
    
    const confirmBtn = document.getElementById('confirmBulkDeleteBtn');
    const originalText = confirmBtn.innerHTML;
    confirmBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Deleting...';
    confirmBtn.disabled = true;
    
    const questionIds = Array.from(selectedQuestions);
    
    try {
      const response = await fetch(`/admin/question-banks/banks/<%= questionBank.bankCode %>/questions/bulk-delete`, {
        method: 'DELETE',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify({ questionIds })
      });
      
      const data = await response.json();
      
      if (data.success) {
        // Close modal
        const modal = bootstrap.Modal.getInstance(document.getElementById('bulkDeleteModal'));
        modal.hide();
        
        // Remove deleted questions from DOM
        questionIds.forEach(id => {
          const card = document.querySelector(`.question-card-modern[data-question-id="${id}"]`);
          if (card) {
            card.style.animation = 'fadeOutUp 0.3s ease forwards';
            setTimeout(() => card.remove(), 300);
          }
        });
        
        // Clear selection
        selectedQuestions.clear();
        updateSelectedCount();
        
        // Update question numbers
        setTimeout(() => {
          updateQuestionNumbers();
          reinitializeQuestionsArray();
          updateQuestionsCount();
        }, 350);
        
        showNotification(`Successfully deleted ${data.deletedCount} questions`, 'success');
        
        // Exit bulk mode
        toggleBulkSelectionMode();
      } else {
        showNotification(data.message || 'Failed to delete questions', 'error');
      }
    } catch (error) {
      console.error('Bulk delete error:', error);
      showNotification('An error occurred while deleting questions', 'error');
    } finally {
      confirmBtn.innerHTML = originalText;
      confirmBtn.disabled = false;
    }
  }
  
  // Update question numbers after deletion
  function updateQuestionNumbers() {
    const cards = document.querySelectorAll('.question-card-modern');
    cards.forEach((card, index) => {
      const numElement = card.querySelector('.question-num');
      if (numElement) {
        numElement.textContent = index + 1;
      }
      card.setAttribute('data-question-number', index + 1);
    });
  }

  // ==================== REAL-TIME SEARCH AND FILTERING ====================

  // Store all questions for client-side filtering
  let allQuestions = [];
  let filteredQuestions = [];
  
  // Slider state
  let currentSlideIndex = 0;
  let sliderQuestions = [];
  let sliderModal = null;

  // Initialize the page
  document.addEventListener('DOMContentLoaded', function() {
    // Store all questions from the page
    const questionCards = document.querySelectorAll('.question-card-modern');
    console.log('Found', questionCards.length, 'question cards');
    
    allQuestions = Array.from(questionCards).map(card => {
      // Get question text from either plain text or math field
      let questionText = '';
      const plainTextEl = card.querySelector('.question-text-plain');
      const mathFieldEl = card.querySelector('.question-math-field');
      
      if (plainTextEl) {
        questionText = plainTextEl.textContent.toLowerCase();
      } else if (mathFieldEl) {
        questionText = (mathFieldEl.textContent || mathFieldEl.getAttribute('data-question-text') || '').toLowerCase();
      }
      
      const tagsData = card.dataset.tags;
      const tagsArray = tagsData ? tagsData.toLowerCase().split(',').map(t => t.trim()).filter(t => t) : [];
      
      return {
        element: card,
        id: card.dataset.questionId,
        difficulty: card.dataset.difficulty,
        tags: tagsArray,
        tagsString: tagsData ? tagsData.toLowerCase() : '',
        points: parseInt(card.dataset.points),
        createdAt: new Date(card.dataset.createdAt),
        text: questionText
      };
    });

    // Log sample question to debug tags
    if (allQuestions.length > 0) {
      console.log('Sample question data:', {
        id: allQuestions[0].id,
        tags: allQuestions[0].tags,
        tagsString: allQuestions[0].tagsString,
        difficulty: allQuestions[0].difficulty
      });
    }

    filteredQuestions = [...allQuestions];

    // Populate available tags
    populateAvailableTags();

    // Initialize Chart.js - wait for Chart.js to be fully loaded
    function initChartWhenReady() {
      if (typeof Chart !== 'undefined') {
        const chartCanvas = document.getElementById('questionDistributionChart');
        if (chartCanvas) {
          try {
            initializeChart();
          } catch (error) {
            console.error('Error initializing chart:', error);
          }
        }
      } else {
        // Retry after a short delay if Chart.js isn't loaded yet
        setTimeout(initChartWhenReady, 100);
      }
    }
    
    // Start initialization
    initChartWhenReady();

    // Setup search and filter event listeners
    setupSearchAndFilters();

    // Image upload functionality is handled by LocalUploader (initialized when modals are shown)

    // Setup create modal event listeners
    setupCreateModalEvents();

    // Setup edit modal tag input focus handlers
    setupEditModalTagHandlers();

    // Setup edit bank form
    setupEditBankForm();

    // Setup MathLive virtual keyboard z-index fix
    setupMathLiveKeyboardFix();

    // Initialize math-fields in question cards
    initializeQuestionCardMathFields();

  });

  // Also try to initialize chart on window load (fallback)
  window.addEventListener('load', function() {
    const chartCanvas = document.getElementById('questionDistributionChart');
    if (chartCanvas && typeof Chart !== 'undefined' && !window.questionDistributionChartInstance) {
      try {
        initializeChart();
      } catch (error) {
        console.error('Error initializing chart on window load:', error);
      }
    }
  });

  // Initialize math-fields in question cards
  function initializeQuestionCardMathFields() {
    const mathFields = document.querySelectorAll('.question-math-field');
    mathFields.forEach((field) => {
      try {
        // Get the question text from data attribute or innerHTML
        let questionText = '';
        if (field.hasAttribute('data-question-text')) {
          questionText = field.getAttribute('data-question-text');
        } else if (field.textContent) {
          questionText = field.textContent.trim();
        } else if (field.innerHTML) {
          questionText = field.innerHTML.trim();
        }
        
        // Set the value if we have text
        if (questionText) {
          // Clean up the text - remove HTML entities if needed
          questionText = questionText
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&quot;/g, '"')
            .replace(/&#39;/g, "'")
            .replace(/&amp;/g, '&');
          
          // Set the value
          if (field.value !== undefined) {
            field.value = questionText;
          } else if (field.setValue) {
            field.setValue(questionText);
          } else {
            // Fallback: set innerHTML
            field.innerHTML = questionText;
          }
        }
        
        // Ensure the math-field is visible
        field.style.display = 'block';
        field.style.visibility = 'visible';
        field.style.opacity = '1';
        
        // Force MathLive to render
        if (typeof MathLive !== 'undefined') {
          // Wait for MathLive to be ready
          setTimeout(() => {
            try {
              // Trigger a re-render
              if (field.updateValue) {
                field.updateValue();
              }
              // Force update
              const event = new Event('input', { bubbles: true });
              field.dispatchEvent(event);
            } catch (e) {
              console.warn('MathLive update warning:', e);
            }
          }, 100);
        }
      } catch (e) {
        console.warn('MathLive initialization warning:', e);
      }
    });
  }
  
  // Re-initialize math fields when new cards are added (for dynamic content)
  const observer = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      if (mutation.addedNodes.length > 0) {
        const hasNewMathFields = Array.from(mutation.addedNodes).some(node => {
          if (node.nodeType === 1) { // Element node
            return node.querySelector && (node.querySelector('.question-math-field') || node.classList.contains('question-math-field'));
          }
          return false;
        });
        if (hasNewMathFields) {
          setTimeout(initializeQuestionCardMathFields, 200);
        }
      }
    });
  });
  
  // Observe the questions container
  const questionsContainer = document.getElementById('questionsContainer');
  if (questionsContainer) {
    observer.observe(questionsContainer, { childList: true, subtree: true });
  }

  // Fix MathLive virtual keyboard z-index to appear above modals
  function setupMathLiveKeyboardFix() {
    // Monitor for virtual keyboard appearance
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === 'childList') {
          const virtualKeyboard = document.querySelector('.ML__virtual-keyboard');
          const keyboardContainer = document.querySelector('.ML__virtual-keyboard-container');
          const keyboardBackdrop = document.querySelector('.ML__virtual-keyboard-backdrop');
          const keyboard = document.querySelector('.ML__keyboard');

          if (virtualKeyboard) {
            virtualKeyboard.style.zIndex = '99999';
            virtualKeyboard.style.position = 'fixed';
          }
          if (keyboardContainer) {
            keyboardContainer.style.zIndex = '99999';
          }
          if (keyboardBackdrop) {
            keyboardBackdrop.style.zIndex = '99998';
          }
          if (keyboard) {
            keyboard.style.zIndex = '99999';
          }
        }
      });
    });

    // Start observing
    observer.observe(document.body, {
      childList: true,
      subtree: true
    });
  }

  // Initialize the question distribution chart
  function initializeChart() {
    const ctx = document.getElementById('questionDistributionChart');
    if (!ctx) {
      console.error('Chart canvas not found');
      return;
    }

    // Get data values with fallback to 0
    const easyQuestions = <%= questionStats.easyQuestions || 0 %>;
    const mediumQuestions = <%= questionStats.mediumQuestions || 0 %>;
    const hardQuestions = <%= questionStats.hardQuestions || 0 %>;

    // Check if Chart.js is available
    if (typeof Chart === 'undefined') {
      console.error('Chart.js is not loaded');
      return;
    }

    // Destroy existing chart if it exists
    if (window.questionDistributionChartInstance) {
      window.questionDistributionChartInstance.destroy();
    }

    const chartData = {
      labels: ['Easy', 'Medium', 'Hard'],
      datasets: [{
        data: [easyQuestions, mediumQuestions, hardQuestions],
        backgroundColor: [
          '#10b981',
          '#f59e0b',
          '#ef4444'
        ],
        borderColor: [
          '#059669',
          '#d97706',
          '#dc2626'
        ],
        borderWidth: 2,
        hoverOffset: 4
      }]
    };

    try {
      window.questionDistributionChartInstance = new Chart(ctx, {
        type: 'doughnut',
        data: chartData,
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  const total = context.dataset.data.reduce((a, b) => a + b, 0);
                  const percentage = total > 0 ? ((context.parsed / total) * 100).toFixed(1) : 0;
                  return `${context.label}: ${context.parsed} (${percentage}%)`;
                }
              }
            }
          },
          cutout: '60%'
        }
      });
      console.log('Question distribution chart initialized successfully');
    } catch (error) {
      console.error('Error creating chart:', error);
    }
  }

  // Populate available tags from all questions
  function populateAvailableTags() {
    const allTags = new Set();
    
    // Collect all unique tags from questions
    allQuestions.forEach(question => {
      if (question.tags && question.tags.length > 0) {
        question.tags.forEach(tag => {
          if (tag && tag.trim()) {
            allTags.add(tag.trim());
          }
        });
      }
    });

    console.log('Total unique tags found:', allTags.size);
    console.log('Tags:', Array.from(allTags));

    const availableTagsSection = document.getElementById('availableTagsSection');
    const availableTagsContainer = document.getElementById('availableTagsContainer');
    
    if (!availableTagsSection || !availableTagsContainer) {
      console.error('Available tags section or container not found');
      return;
    }

    // If there are tags, show the section
    if (allTags.size > 0) {
      availableTagsSection.style.display = 'block';
      
      // Sort tags alphabetically
      const sortedTags = Array.from(allTags).sort();
      
      // Create tag chips
      availableTagsContainer.innerHTML = sortedTags.map(tag => `
        <span class="available-tag-chip" data-tag="${tag}" onclick="toggleTagFilter('${tag.replace(/'/g, "\\'")}')">
          <i class="fas fa-tag me-1"></i>${tag}
        </span>
      `).join('');
      
      console.log('Available tags section populated with', sortedTags.length, 'tags');
    } else {
      availableTagsSection.style.display = 'none';
      console.log('No tags found in questions');
    }
  }

  // Toggle tag in filter
  function toggleTagFilter(tag) {
    const tagsFilter = document.getElementById('tagsFilter');
    const clearTagsBtn = document.getElementById('clearTagsFilterBtn');
    
    if (!tagsFilter) return;
    
    const currentTags = tagsFilter.value.split(',').map(t => t.trim()).filter(t => t);
    const tagLower = tag.toLowerCase();
    
    // Check if tag is already in filter
    const tagIndex = currentTags.findIndex(t => t.toLowerCase() === tagLower);
    
    if (tagIndex > -1) {
      // Remove tag
      currentTags.splice(tagIndex, 1);
    } else {
      // Add tag
      currentTags.push(tag);
    }
    
    // Update input
    tagsFilter.value = currentTags.join(', ');
    
    // Show/hide clear button
    if (currentTags.length > 0) {
      clearTagsBtn.style.display = 'inline-block';
    } else {
      clearTagsBtn.style.display = 'none';
    }
    
    // Update tag chip styles
    updateTagChipStyles();
    
    // Trigger filter
    filterQuestions();
  }

  // Update tag chip styles based on active filters
  function updateTagChipStyles() {
    const tagsFilter = document.getElementById('tagsFilter');
    if (!tagsFilter) return;
    
    const activeTags = tagsFilter.value.split(',').map(t => t.trim().toLowerCase()).filter(t => t);
    const tagChips = document.querySelectorAll('.available-tag-chip');
    
    tagChips.forEach(chip => {
      const chipTag = chip.getAttribute('data-tag').toLowerCase();
      if (activeTags.includes(chipTag)) {
        chip.classList.add('active');
      } else {
        chip.classList.remove('active');
      }
    });
  }

  // Update filter results summary
  function updateFilterSummary() {
    const summaryEl = document.getElementById('filterResultsSummary');
    const summaryText = document.getElementById('filterResultsText');
    
    if (!summaryEl || !summaryText) return;

    const searchInput = document.getElementById('questionsSearchInput');
    const difficultyFilter = document.getElementById('difficultyFilter');
    const tagsFilter = document.getElementById('tagsFilter');

    const hasSearch = searchInput && searchInput.value.trim();
    const hasDifficulty = difficultyFilter && difficultyFilter.value !== 'all';
    const hasTags = tagsFilter && tagsFilter.value.trim();

    const isFiltering = hasSearch || hasDifficulty || hasTags;

    if (isFiltering) {
      summaryEl.style.display = 'block';
      
      let filterParts = [];
      
      if (hasSearch) {
        filterParts.push(`search: "${searchInput.value.trim()}"`);
      }
      
      if (hasDifficulty) {
        filterParts.push(`difficulty: ${difficultyFilter.value}`);
      }
      
      if (hasTags) {
        const tags = tagsFilter.value.split(',').map(t => t.trim()).filter(t => t);
        filterParts.push(`tags: ${tags.join(', ')}`);
      }

      summaryText.innerHTML = `
        Showing <strong>${filteredQuestions.length}</strong> of <strong>${allQuestions.length}</strong> questions
        ${filterParts.length > 0 ? `(${filterParts.join(' | ')})` : ''}
      `;
    } else {
      summaryEl.style.display = 'none';
    }
    
    // Update slider button count
    updateSliderButtonCount();
  }
  
  // Update slider button count
  function updateSliderButtonCount() {
    const sliderBtnCount = document.getElementById('sliderBtnCount');
    if (sliderBtnCount) {
      const count = filteredQuestions.length > 0 ? filteredQuestions.length : allQuestions.length;
      sliderBtnCount.textContent = count;
    }
  }

  // Setup search and filter event listeners
  function setupSearchAndFilters() {
    const searchInput = document.getElementById('questionsSearchInput');
    const searchClearBtn = document.getElementById('searchClearBtn');
    const difficultyFilter = document.getElementById('difficultyFilter');
    const sortFilter = document.getElementById('sortFilter');
    const tagsFilter = document.getElementById('tagsFilter');
    const clearTagsBtn = document.getElementById('clearTagsFilterBtn');

    // Check if elements exist before adding event listeners
    if (!searchInput || !searchClearBtn || !difficultyFilter || !sortFilter || !tagsFilter) {
      console.warn('Some search/filter elements not found, skipping event listener setup');
      return;
    }

    // Search input event
    searchInput.addEventListener('input', function() {
      const query = this.value.toLowerCase().trim();

      if (query.length > 0) {
        searchClearBtn.style.display = 'block';
      } else {
        searchClearBtn.style.display = 'none';
      }

      filterQuestions();
    });

    // Clear search button
    searchClearBtn.addEventListener('click', function() {
      searchInput.value = '';
      this.style.display = 'none';
      filterQuestions();
    });

    // Filter change events
    difficultyFilter.addEventListener('change', filterQuestions);
    sortFilter.addEventListener('change', filterAndSortQuestions);
    tagsFilter.addEventListener('input', function() {
      debounce(filterQuestions, 300)();
      updateTagChipStyles();
      
      // Show/hide clear button
      if (this.value.trim()) {
        clearTagsBtn.style.display = 'inline-block';
      } else {
        clearTagsBtn.style.display = 'none';
      }
    });

    // Clear tags filter button
    if (clearTagsBtn) {
      clearTagsBtn.addEventListener('click', function() {
        tagsFilter.value = '';
        this.style.display = 'none';
        updateTagChipStyles();
        filterQuestions();
      });
    }
  }

  // Filter questions based on search and filters
  function filterQuestions() {
    const searchInput = document.getElementById('questionsSearchInput');
    const difficultySelect = document.getElementById('difficultyFilter');
    const tagsInput = document.getElementById('tagsFilter');

    // Check if elements exist
    if (!searchInput || !difficultySelect || !tagsInput) {
      return;
    }

    const searchQuery = searchInput.value.toLowerCase().trim();
    const difficultyFilter = difficultySelect.value;
    const tagsFilter = tagsInput.value.toLowerCase().trim();

    // Parse tags filter - support comma-separated tags for AND logic
    const filterTags = tagsFilter ? tagsFilter.split(',').map(t => t.trim()).filter(t => t) : [];

    filteredQuestions = allQuestions.filter(question => {
      // Search filter - search in question text and tags
      if (searchQuery) {
        const matchesText = question.text.includes(searchQuery);
        const matchesTags = question.tagsString.includes(searchQuery);
        const matchesDifficulty = question.difficulty.toLowerCase().includes(searchQuery);
        
        if (!matchesText && !matchesTags && !matchesDifficulty) {
          return false;
        }
      }

      // Difficulty filter
      if (difficultyFilter !== 'all' && question.difficulty !== difficultyFilter) {
        return false;
      }

      // Tags filter - enhanced to support multiple tags
      if (filterTags.length > 0) {
        // Check if question has all the filter tags (AND logic)
        const hasAllTags = filterTags.every(filterTag => {
          // Check if any of the question's tags includes the filter tag
          return question.tags.some(questionTag => 
            questionTag.includes(filterTag) || filterTag.includes(questionTag)
          );
        });
        
        if (!hasAllTags) {
          return false;
        }
      }

      return true;
    });

    // Sort questions
    sortQuestions();

    // Update display
    updateQuestionsDisplay();
  }

  // Sort questions based on selected criteria
  function sortQuestions() {
    const sortSelect = document.getElementById('sortFilter');
    if (!sortSelect) return;

    const sortBy = sortSelect.value;

    filteredQuestions.sort((a, b) => {
      switch (sortBy) {
        case 'difficulty':
          const difficultyOrder = {
            'Easy': 1,
            'Medium': 2,
            'Hard': 3
          };
          return difficultyOrder[a.difficulty] - difficultyOrder[b.difficulty];
        case 'points':
          return b.points - a.points;
        case 'createdAt':
        default:
          return a.createdAt - b.createdAt;
      }
    });
  }

  // Filter and sort questions (for sort filter change)
  function filterAndSortQuestions() {
    filterQuestions();
  }

  // Update the questions display
  function updateQuestionsDisplay() {
    const container = document.getElementById('questionsContainer');
    const questionsCount = document.getElementById('questionsCount');

    // Check if elements exist
    if (!container || !questionsCount) {
      return;
    }

    // Hide all questions first
    allQuestions.forEach(question => {
      question.element.style.display = 'none';
    });

    // Show filtered questions with updated numbering
    filteredQuestions.forEach((question, index) => {
      question.element.style.display = 'block';
      const questionNum = question.element.querySelector('.question-num');
      if (questionNum) {
        questionNum.textContent = index + 1;
      }
    });

    // Update count
    questionsCount.textContent = filteredQuestions.length;

    // Update filter results summary
    updateFilterSummary();

    // Show empty state if no results
    if (filteredQuestions.length === 0) {
      showEmptyState();
    } else {
      hideEmptyState();
    }
  }

  // Show empty state for filtered results
  function showEmptyState() {
    let emptyState = document.querySelector('.questions-empty-state-filtered');

    if (!emptyState) {
      emptyState = document.createElement('div');
      emptyState.className = 'questions-empty-state-filtered';
      emptyState.innerHTML = `
      <div class="empty-icon">
        <i class="fas fa-search"></i>
      </div>
      <h3 class="empty-title">No Questions Found</h3>
      <p class="empty-description">
        No questions match your current search criteria. Try adjusting your filters.
      </p>
      <button class="btn btn-outline-primary" onclick="clearAllFilters()">
        <i class="fas fa-times me-2"></i>
        Clear All Filters
      </button>
    `;

      const container = document.getElementById('questionsContainer');
      container.appendChild(emptyState);
    }

    emptyState.style.display = 'block';
  }

  // Hide empty state
  function hideEmptyState() {
    const emptyState = document.querySelector('.questions-empty-state-filtered');
    if (emptyState) {
      emptyState.style.display = 'none';
    }
  }

  // Clear all filters
  function clearAllFilters() {
    const searchInput = document.getElementById('questionsSearchInput');
    const searchClearBtn = document.getElementById('searchClearBtn');
    const difficultyFilter = document.getElementById('difficultyFilter');
    const sortFilter = document.getElementById('sortFilter');
    const tagsFilter = document.getElementById('tagsFilter');

    if (searchInput) searchInput.value = '';
    if (searchClearBtn) searchClearBtn.style.display = 'none';
    if (difficultyFilter) difficultyFilter.value = 'all';
    if (sortFilter) sortFilter.value = 'createdAt';
    if (tagsFilter) tagsFilter.value = '';

    filterQuestions();
  }

  // Debounce function for performance
  function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }

  // ==================== QUESTIONS SLIDER ====================
  
  // Cache for full question data in slider (keyed by question ID)
  const sliderQuestionDataCache = new Map();
  
  // Open questions slider
  function openQuestionsSlider() {
    // Use filtered questions if filters are active, otherwise use all questions
    sliderQuestions = filteredQuestions.length > 0 ? filteredQuestions : allQuestions;
    // Clear cache when opening slider
    sliderQuestionDataCache.clear();
    
    if (sliderQuestions.length === 0) {
      showNotification('No questions to display', 'warning');
      return;
    }
    
    currentSlideIndex = 0;
    
    // Initialize modal
    const modalEl = document.getElementById('questionsSliderModal');
    sliderModal = new bootstrap.Modal(modalEl);
    
    // Build slider
    buildSlider();
    
    // Show modal
    sliderModal.show();
    
    // Add keyboard navigation
    document.addEventListener('keydown', handleSliderKeyboard);
    
    // Update filter info
    updateSliderFilterInfo();
  }
  
  // Build slider HTML
  function buildSlider() {
    const container = document.getElementById('questionsSliderContainer');
    const dotsContainer = document.getElementById('sliderDots');
    
    if (!container || !dotsContainer) return;
    
    // Clear existing content
    container.innerHTML = '';
    dotsContainer.innerHTML = '';
    
    if (sliderQuestions.length === 0) {
      container.innerHTML = `
        <div class="slider-empty-state">
          <i class="fas fa-question-circle"></i>
          <h3>No Questions Found</h3>
          <p>Try adjusting your filters or add some questions to get started.</p>
        </div>
      `;
      return;
    }
    
    // Create slides
    sliderQuestions.forEach((question, index) => {
      const slide = createSlide(question, index);
      container.appendChild(slide);
      
      // Create dot
      const dot = document.createElement('div');
      dot.className = 'slider-dot';
      if (index === 0) dot.classList.add('active');
      dot.onclick = () => goToSlide(index);
      dot.title = `Question ${index + 1}`;
      dotsContainer.appendChild(dot);
    });
    
    // Show first slide
    updateSlidePosition();
    updateSliderCounter();
    updateNavigationButtons();
  }
  
  // Create a slide
  function createSlide(question, index) {
    const slide = document.createElement('div');
    slide.className = 'slider-slide';
    if (index === 0) slide.classList.add('active');
    
    // Fetch full question data (optimized)
    fetch(`/admin/question-banks/banks/<%= questionBank.bankCode %>/questions/${question.id}`, {
      method: 'GET',
      headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json'
      },
      cache: 'default' // Allow caching for slider since it's not critical
    })
    .then(response => response.json())
    .then(data => {
      if (data.success && data.question) {
        // Cache the full question data for quick access when editing
        sliderQuestionDataCache.set(question.id, data.question);
        
        // Store question ID on slide element for easy access
        slide.setAttribute('data-question-id', question.id);
        
        slide.innerHTML = createSlideHTML(data.question, index);
        // Initialize MathLive fields after HTML is inserted
        setTimeout(() => {
          const mathFields = slide.querySelectorAll('math-field');
          mathFields.forEach(field => {
            if (typeof MathLive !== 'undefined') {
              // MathLive fields are automatically initialized when inserted into DOM
              // Just ensure they're properly rendered
              field.style.display = 'inline-block';
            }
          });
        }, 100);
      }
    })
    .catch(error => {
      console.error('Error fetching question:', error);
      slide.innerHTML = `
        <div class="slider-question-card">
          <div class="alert alert-danger">
            <i class="fas fa-exclamation-triangle me-2"></i>
            Error loading question details
          </div>
        </div>
      `;
    });
    
    // Show loading state
    slide.innerHTML = `
      <div class="slider-question-card">
        <div class="text-center">
          <i class="fas fa-spinner fa-spin fa-3x text-primary mb-3"></i>
          <p class="text-muted">Loading question...</p>
        </div>
      </div>
    `;
    
    return slide;
  }
  
  // Create slide HTML
  function createSlideHTML(question, index) {
    const optionLetters = ['A', 'B', 'C', 'D', 'E', 'F'];
    
    let html = `
      <div class="slider-question-card">
        <div class="slider-question-header">
          <div class="slider-question-number">
            Question ${index + 1} of ${sliderQuestions.length}
          </div>
          <div class="slider-question-meta">
            <span class="difficulty-badge difficulty-${question.difficulty.toLowerCase()}">
              <i class="fas fa-${question.difficulty === 'Easy' ? 'check-circle' : question.difficulty === 'Medium' ? 'exclamation-circle' : 'times-circle'} me-1"></i>
              ${question.difficulty}
            </span>
            <span class="question-type-badge ${question.questionType.toLowerCase().replace('/', '-')}">
              <i class="fas fa-${question.questionType === 'Written' ? 'edit' : question.questionType === 'MCQ' ? 'list' : 'check-square'} me-1"></i>
              ${question.questionType}
            </span>
            <span class="badge bg-secondary">
              <i class="fas fa-star me-1"></i>
              ${question.points} point${question.points !== 1 ? 's' : ''}
            </span>
          </div>
        </div>
        
        <div class="slider-question-text">
          ${parseMathExpressions(question.questionText)}
        </div>
    `;
    
    // Question image
    if (question.questionImage && question.questionImage.trim()) {
      html += `
        <div class="slider-question-image">
          <img src="${question.questionImage}" alt="Question Image">
        </div>
      `;
    }
    
    // Options for MCQ/True-False
    if (question.questionType === 'MCQ' || question.questionType === 'True/False') {
      html += '<div class="slider-options-container">';
      question.options.forEach((option, optIndex) => {
        const isCorrect = option.isCorrect;
        html += `
          <div class="slider-option ${isCorrect ? 'correct' : ''}">
            <div class="slider-option-letter">${optionLetters[optIndex]}</div>
            <div class="slider-option-text">${parseMathExpressions(option.text)}</div>
            ${isCorrect ? '<i class="fas fa-check-circle text-success ms-auto"></i>' : ''}
          </div>
        `;
      });
      html += '</div>';
    }
    
    // Written answers
    if (question.questionType === 'Written' && question.correctAnswers && question.correctAnswers.length > 0) {
      html += `
        <div class="slider-written-answers">
          <h6><i class="fas fa-check-double me-2"></i>Correct Answers:</h6>
      `;
      question.correctAnswers.forEach((answer, idx) => {
        const answerText = typeof answer === 'string' ? answer : answer.text;
        const isMandatory = typeof answer === 'object' && answer.isMandatory !== undefined ? answer.isMandatory : true;
        html += `
          <div class="slider-written-answer">
            <i class="fas fa-check text-success"></i>
            <span>${parseMathExpressions(answerText)}</span>
            ${!isMandatory ? '<span class="badge bg-info ms-2">Optional</span>' : ''}
          </div>
        `;
      });
      html += '</div>';
    }
    
    // Explanation
    if (question.explanation && question.explanation.trim()) {
      html += `
        <div class="slider-explanation">
          <h6><i class="fas fa-lightbulb"></i> Explanation</h6>
          <div class="slider-explanation-text">${parseMathExpressions(question.explanation)}</div>
        </div>
      `;
    }
    
    // Tags
    if (question.tags && question.tags.length > 0) {
      html += '<div class="slider-tags">';
      question.tags.forEach(tag => {
        html += `<span class="slider-tag"><i class="fas fa-tag me-1"></i>${escapeHtml(tag)}</span>`;
      });
      html += '</div>';
    }
    
    html += '</div>';
    return html;
  }
  
  // Navigate slider
  function navigateSlider(direction) {
    const newIndex = currentSlideIndex + direction;
    
    if (newIndex >= 0 && newIndex < sliderQuestions.length) {
      goToSlide(newIndex);
    }
  }
  
  // Go to specific slide
  function goToSlide(index) {
    if (index < 0 || index >= sliderQuestions.length) return;
    
    currentSlideIndex = index;
    updateSlidePosition();
    updateSliderCounter();
    updateNavigationButtons();
    updateSliderDots();
  }
  
  // Update slide position
  function updateSlidePosition() {
    const slides = document.querySelectorAll('.slider-slide');
    slides.forEach((slide, index) => {
      if (index === currentSlideIndex) {
        slide.classList.add('active');
        slide.style.display = 'flex';
      } else {
        slide.classList.remove('active');
        slide.style.display = 'none';
      }
    });
  }
  
  // Update counter
  function updateSliderCounter() {
    const counter = document.getElementById('sliderQuestionCounter');
    if (counter) {
      counter.textContent = `${currentSlideIndex + 1} / ${sliderQuestions.length}`;
    }
    
    // Update edit/delete buttons
    const editBtn = document.getElementById('sliderEditBtn');
    const deleteBtn = document.getElementById('sliderDeleteBtn');
    
    if (editBtn && deleteBtn) {
      if (sliderQuestions.length > 0) {
        editBtn.style.display = 'inline-block';
        deleteBtn.style.display = 'inline-block';
      } else {
        editBtn.style.display = 'none';
        deleteBtn.style.display = 'none';
      }
    }
  }
  
  // Update navigation buttons
  function updateNavigationButtons() {
    const prevBtn = document.getElementById('sliderPrevBtn');
    const nextBtn = document.getElementById('sliderNextBtn');
    
    if (prevBtn) {
      prevBtn.disabled = currentSlideIndex === 0;
    }
    
    if (nextBtn) {
      nextBtn.disabled = currentSlideIndex === sliderQuestions.length - 1;
    }
  }
  
  // Update dots
  function updateSliderDots() {
    const dots = document.querySelectorAll('.slider-dot');
    dots.forEach((dot, index) => {
      if (index === currentSlideIndex) {
        dot.classList.add('active');
      } else {
        dot.classList.remove('active');
      }
    });
  }
  
  // Update filter info
  function updateSliderFilterInfo() {
    const filterInfo = document.getElementById('sliderFilterInfo');
    if (!filterInfo) return;
    
    const searchInput = document.getElementById('questionsSearchInput');
    const difficultyFilter = document.getElementById('difficultyFilter');
    const tagsFilter = document.getElementById('tagsFilter');
    
    const hasFilters = (searchInput && searchInput.value.trim()) ||
                      (difficultyFilter && difficultyFilter.value !== 'all') ||
                      (tagsFilter && tagsFilter.value.trim());
    
    if (hasFilters) {
      filterInfo.innerHTML = '<i class="fas fa-filter me-1"></i> Filtered Results';
    } else {
      filterInfo.innerHTML = '<i class="fas fa-list me-1"></i> All Questions';
    }
  }
  
  // Keyboard navigation
  function handleSliderKeyboard(e) {
    if (!sliderModal || !sliderModal._isShown) return;
    
    if (e.key === 'ArrowLeft') {
      navigateSlider(-1);
    } else if (e.key === 'ArrowRight') {
      navigateSlider(1);
    } else if (e.key === 'Escape') {
      closeSlider();
    }
  }
  
  // Close slider
  function closeSlider() {
    if (sliderModal) {
      sliderModal.hide();
    }
    document.removeEventListener('keydown', handleSliderKeyboard);
  }
  
  // Edit current slide question
  function editCurrentSlideQuestion() {
    if (sliderQuestions.length === 0) return;
    
    const currentQuestion = sliderQuestions[currentSlideIndex];
    
    // Check if we have cached full question data (much faster!)
    const cachedQuestionData = sliderQuestionDataCache.get(currentQuestion.id);
    
    // Close slider immediately
    closeSlider();
    
    // If we have cached data, populate edit form directly without fetching
    if (cachedQuestionData) {
      // Small delay to ensure slider modal is closed
      setTimeout(() => {
        // Populate edit form directly with cached data (no fetch needed!)
        populateEditFormDirectly(cachedQuestionData, currentQuestion.id);
      }, 100);
    } else {
      // Fallback: fetch if cache miss (shouldn't happen normally)
      setTimeout(() => {
        editQuestion(currentQuestion.id);
      }, 100);
    }
  }
  
  // Delete current slide question
  function deleteCurrentSlideQuestion() {
    if (sliderQuestions.length === 0) return;
    
    const currentQuestion = sliderQuestions[currentSlideIndex];
    const questionText = currentQuestion.text.substring(0, 50) + '...';
    
    // Close slider
    closeSlider();
    
    // Wait for slider to close, then confirm delete
    setTimeout(() => {
      deleteQuestion(currentQuestion.id, questionText);
    }, 300);
  }
  
  // Helper function to escape HTML
  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }
  
  // Update question card in DOM without reload
  function updateQuestionCardInDOM(question) {
    const questionCard = document.querySelector(`[data-question-id="${question._id}"]`);
    if (!questionCard) return;
    
    // Update data attributes
    questionCard.setAttribute('data-difficulty', question.difficulty);
    questionCard.setAttribute('data-tags', question.tags ? question.tags.join(',') : '');
    questionCard.setAttribute('data-points', question.points);
    
    // Update question text
    const questionTextEl = questionCard.querySelector('.question-text-plain, .question-math-field');
    if (questionTextEl) {
      if (questionTextEl.classList.contains('question-text-plain')) {
        questionTextEl.textContent = question.questionText.length > 120 ? 
          question.questionText.substring(0, 120) + '...' : question.questionText;
      } else {
        questionTextEl.value = question.questionText;
      }
    }
    
    // Update difficulty badge
    const difficultyBadge = questionCard.querySelector('.difficulty-badge');
    if (difficultyBadge) {
      difficultyBadge.className = `difficulty-badge difficulty-${question.difficulty.toLowerCase()}`;
      difficultyBadge.innerHTML = `
        <i class="fas fa-${question.difficulty === 'Easy' ? 'check-circle' : question.difficulty === 'Medium' ? 'exclamation-circle' : 'times-circle'} me-1"></i>
        ${question.difficulty}
      `;
    }
    
    // Update type badge
    const typeBadge = questionCard.querySelector('.question-type-badge');
    if (typeBadge) {
      typeBadge.className = `question-type-badge ${question.questionType.toLowerCase().replace('/', '-')}`;
      typeBadge.innerHTML = `
        <i class="fas fa-${question.questionType === 'Written' ? 'edit' : question.questionType === 'MCQ' ? 'list' : 'check-square'} me-1"></i>
        ${question.questionType}
      `;
    }
    
    // Update tags
    const tagsContainer = questionCard.querySelector('.question-tags');
    if (tagsContainer) {
      if (question.tags && question.tags.length > 0) {
        tagsContainer.innerHTML = '';
        question.tags.slice(0, 3).forEach(tag => {
          const tagSpan = document.createElement('span');
          tagSpan.className = 'question-tag';
          tagSpan.textContent = tag;
          tagsContainer.appendChild(tagSpan);
        });
        
        if (question.tags.length > 3) {
          const moreSpan = document.createElement('span');
          moreSpan.className = 'question-tag question-tag-more';
          moreSpan.textContent = `+${question.tags.length - 3}`;
          tagsContainer.appendChild(moreSpan);
        }
        tagsContainer.style.display = 'flex';
      } else {
        tagsContainer.style.display = 'none';
      }
    }
  }
  
  // Reinitialize questions array after update
  function reinitializeQuestionsArray() {
    const questionCards = document.querySelectorAll('.question-card-modern');
    
    allQuestions = Array.from(questionCards).map(card => {
      let questionText = '';
      const plainTextEl = card.querySelector('.question-text-plain');
      const mathFieldEl = card.querySelector('.question-math-field');
      
      if (plainTextEl) {
        questionText = plainTextEl.textContent.toLowerCase();
      } else if (mathFieldEl) {
        questionText = (mathFieldEl.textContent || mathFieldEl.getAttribute('data-question-text') || '').toLowerCase();
      }
      
      const tagsData = card.dataset.tags;
      const tagsArray = tagsData ? tagsData.toLowerCase().split(',').map(t => t.trim()).filter(t => t) : [];
      
      return {
        element: card,
        id: card.dataset.questionId,
        difficulty: card.dataset.difficulty,
        tags: tagsArray,
        tagsString: tagsData ? tagsData.toLowerCase() : '',
        points: parseInt(card.dataset.points),
        createdAt: new Date(card.dataset.createdAt),
        text: questionText
      };
    });
    
    // Reapply filters
    filterQuestions();
    
    // Repopulate available tags
    populateAvailableTags();
  }

  // ==================== IMAGE UPLOAD FUNCTIONALITY ====================
  // Using LocalUploader class (local storage)

  // Initialize LocalUploader for question forms when modals are shown
  let questionUploader = null;

  // Initialize uploader for create question modal
  document.getElementById('createQuestionModal')?.addEventListener('shown.bs.modal', function() {
    if (!questionUploader) {
      questionUploader = new LocalUploader();
    }
    
    // Initialize for create question form (using 'questionImage' as field name)
    if (document.querySelector('#createQuestionForm')) {
      questionUploader.init(
        '#createQuestionForm',
        '#questionImageFile',
        '#questionImagePreview',
        '#questionImageProgress',
        'questionImage' // Field name for hidden input
      );
    }
    
    // Clear tags input and load previous tags
    const tagsInput = document.getElementById('tags');
    if (tagsInput) {
      tagsInput.value = '';
    }
    // Load previous tags with a small delay to ensure DOM is ready
    setTimeout(function() {
      loadPreviousTagsForCreate();
    }, 150);
  });

  // Initialize uploader for edit question modal
  document.getElementById('editQuestionModal')?.addEventListener('shown.bs.modal', function() {
    if (!questionUploader) {
      questionUploader = new LocalUploader();
    }
    
    // Initialize for edit question form (using 'questionImage' as field name)
    if (document.querySelector('#editQuestionForm')) {
      questionUploader.init(
        '#editQuestionForm',
        '#editQuestionImageFile',
        '#editQuestionImagePreview',
        '#editQuestionImageProgress',
        'questionImage' // Field name for hidden input
      );
    }
    
    // Add listener to show action buttons when file is uploaded
    const editImageFileInput = document.getElementById('editQuestionImageFile');
    if (editImageFileInput && !editImageFileInput.dataset.listenerAdded) {
      editImageFileInput.dataset.listenerAdded = 'true';
      
      editImageFileInput.addEventListener('change', function() {
        if (this.files && this.files.length > 0) {
          // Poll for upload completion (dataset.uploaded becomes 'true')
          const checkUploadInterval = setInterval(function() {
            if (editImageFileInput.dataset.uploaded === 'true') {
              clearInterval(checkUploadInterval);
              const imageActions = document.getElementById('editQuestionImageActions');
              if (imageActions) {
                imageActions.style.display = 'flex';
              }
            }
          }, 500);
          
          // Clear interval after 30 seconds as fallback
          setTimeout(function() {
            clearInterval(checkUploadInterval);
          }, 30000);
        }
      });
    }
    
    // Load previous tags with a small delay to ensure DOM is ready
    setTimeout(function() {
      loadPreviousTags();
    }, 150);
  });
  
  // Reset form visibility when modal is hidden
  document.getElementById('editQuestionModal')?.addEventListener('hidden.bs.modal', function() {
    // Reset loader and form content visibility
    const loader = document.getElementById('editQuestionLoader');
    const formContent = document.getElementById('editQuestionFormContent');
    if (loader) loader.style.display = 'none';
    if (formContent) formContent.style.display = 'block';
    
    // Enable footer buttons
    const footerButtons = document.querySelectorAll('#editQuestionModal .modal-footer button');
    footerButtons.forEach(btn => btn.disabled = false);
    
    // Clear form to prevent cached data
    clearEditForm();
  });

  // Show notification function
  function showNotification(message, type = 'info') {
    // Remove existing notifications
    const existingNotifications = document.querySelectorAll('.notification');
    existingNotifications.forEach(notification => notification.remove());

    // Create notification element
    const notification = document.createElement('div');
    notification.className = `notification notification-${type}`;
    notification.innerHTML = `
    <div class="notification-content">
      <i class="fas fa-${type === 'success' ? 'check-circle' : type === 'error' ? 'exclamation-circle' : 'info-circle'}"></i>
      <span>${message}</span>
      <button class="notification-close" onclick="this.parentElement.parentElement.remove()">
        <i class="fas fa-times"></i>
      </button>
    </div>
  `;

    // Add to page
    document.body.appendChild(notification);

    // Auto remove after 5 seconds
    setTimeout(() => {
      if (notification.parentElement) {
        notification.remove();
      }
    }, 5000);
  }

  // MathLive Functions
  function showMathKeyboard(fieldId) {
    const mathField = document.getElementById(fieldId);
    if (mathField && mathField.executeCommand) {
      mathField.executeCommand('showVirtualKeyboard');

      // Ensure virtual keyboard appears above modals
      setTimeout(() => {
        const virtualKeyboard = document.querySelector('.ML__virtual-keyboard');
        const keyboardContainer = document.querySelector('.ML__virtual-keyboard-container');
        const keyboardBackdrop = document.querySelector('.ML__virtual-keyboard-backdrop');
        const keyboard = document.querySelector('.ML__keyboard');

        if (virtualKeyboard) {
          virtualKeyboard.style.zIndex = '99999';
          virtualKeyboard.style.position = 'fixed';
        }
        if (keyboardContainer) {
          keyboardContainer.style.zIndex = '99999';
        }
        if (keyboardBackdrop) {
          keyboardBackdrop.style.zIndex = '99998';
        }
        if (keyboard) {
          keyboard.style.zIndex = '99999';
        }
      }, 100);
    }
  }

  // Enhanced MathLive functions for better text/math integration
  function switchToMathMode(fieldId) {
    const mathField = document.getElementById(fieldId);
    const fallbackField = document.getElementById(fieldId + '_Fallback');
    const mathModeBtn = document.getElementById(fieldId.replace('Text_', 'MathModeBtn').replace('Text', 'MathModeBtn'));
    const textModeBtn = document.getElementById(fieldId.replace('Text_', 'TextModeBtn').replace('Text', 'TextModeBtn'));
    const modeIndicator = document.getElementById(fieldId + 'ModeIndicator');

    if (mathField && fallbackField) {
      // Convert text to LaTeX if it contains math expressions
      let content = fallbackField.value.trim();
      if (content) {
        // Simple text to LaTeX conversion for common patterns
        content = convertTextToLatex(content);
        mathField.value = content;
      }

      // Switch to MathLive
      mathField.style.display = 'block';
      fallbackField.style.display = 'none';

      // Update button states
      if (mathModeBtn) mathModeBtn.style.display = 'none';
      if (textModeBtn) textModeBtn.style.display = 'inline-block';

      // Update indicator
      if (modeIndicator) {
        modeIndicator.textContent = 'Math Mode: Use LaTeX syntax for equations';
        modeIndicator.className = 'text-primary';
      }
    }
  }

  function switchToTextMode(fieldId) {
    const mathField = document.getElementById(fieldId);
    const fallbackField = document.getElementById(fieldId + '_Fallback');
    const mathModeBtn = document.getElementById(fieldId.replace('Text_', 'MathModeBtn').replace('Text', 'MathModeBtn'));
    const textModeBtn = document.getElementById(fieldId.replace('Text_', 'TextModeBtn').replace('Text', 'TextModeBtn'));
    const modeIndicator = document.getElementById(fieldId + 'ModeIndicator');

    if (mathField && fallbackField) {
      // Convert LaTeX to readable text
      let content = mathField.value.trim();
      if (content) {
        content = convertLatexToText(content);
        fallbackField.value = content;
      }

      // Switch to textarea
      mathField.style.display = 'none';
      fallbackField.style.display = 'block';

      // Update button states
      if (mathModeBtn) mathModeBtn.style.display = 'inline-block';
      if (textModeBtn) textModeBtn.style.display = 'none';

      // Update indicator
      if (modeIndicator) {
        modeIndicator.textContent = 'Text Mode: Plain text input';
        modeIndicator.className = 'text-secondary';
      }
    }
  }

  // Convert text to LaTeX for math expressions
  function convertTextToLatex(text) {
    // Common text to LaTeX conversions
    const conversions = [{
        from: /\^(\d+)/g,
        to: '^{$1}'
      }, // x^2 -> x^{2}
      {
        from: /sqrt\(([^)]+)\)/g,
        to: '\\sqrt{$1}'
      }, // sqrt(x) -> \sqrt{x}
      {
        from: /frac\(([^,]+),\s*([^)]+)\)/g,
        to: '\\frac{$1}{$2}'
      }, // frac(a,b) -> \frac{a}{b}
      {
        from: /pi/g,
        to: '\\pi'
      }, // pi -> \pi
      {
        from: /alpha/g,
        to: '\\alpha'
      }, // alpha -> \alpha
      {
        from: /beta/g,
        to: '\\beta'
      }, // beta -> \beta
      {
        from: /gamma/g,
        to: '\\gamma'
      }, // gamma -> \gamma
      {
        from: /delta/g,
        to: '\\delta'
      }, // delta -> \delta
      {
        from: /theta/g,
        to: '\\theta'
      }, // theta -> \theta
      {
        from: /lambda/g,
        to: '\\lambda'
      }, // lambda -> \lambda
      {
        from: /mu/g,
        to: '\\mu'
      }, // mu -> \mu
      {
        from: /sigma/g,
        to: '\\sigma'
      }, // sigma -> \sigma
      {
        from: /tau/g,
        to: '\\tau'
      }, // tau -> \tau
      {
        from: /phi/g,
        to: '\\phi'
      }, // phi -> \phi
      {
        from: /omega/g,
        to: '\\omega'
      }, // omega -> \omega
      {
        from: /infinity/g,
        to: '\\infty'
      }, // infinity -> \infty
      {
        from: /integral/g,
        to: '\\int'
      }, // integral -> \int
      {
        from: /sum/g,
        to: '\\sum'
      }, // sum -> \sum
      {
        from: /product/g,
        to: '\\prod'
      }, // product -> \prod
      {
        from: /limit/g,
        to: '\\lim'
      }, // limit -> \lim
      {
        from: /sin\(/g,
        to: '\\sin('
      }, // sin( -> \sin(
      {
        from: /cos\(/g,
        to: '\\cos('
      }, // cos( -> \cos(
      {
        from: /tan\(/g,
        to: '\\tan('
      }, // tan( -> \tan(
      {
        from: /log\(/g,
        to: '\\log('
      }, // log( -> \log(
      {
        from: /ln\(/g,
        to: '\\ln('
      }, // ln( -> \ln(
      {
        from: /exp\(/g,
        to: '\\exp('
      }, // exp( -> \exp(
      {
        from: /leq/g,
        to: '\\leq'
      }, // leq -> \leq
      {
        from: /geq/g,
        to: '\\geq'
      }, // geq -> \geq
      {
        from: /neq/g,
        to: '\\neq'
      }, // neq -> \neq
      {
        from: /approx/g,
        to: '\\approx'
      }, // approx -> \approx
      {
        from: /equiv/g,
        to: '\\equiv'
      }, // equiv -> \equiv
      {
        from: /subset/g,
        to: '\\subset'
      }, // subset -> \subset
      {
        from: /supset/g,
        to: '\\supset'
      }, // supset -> \supset
      {
        from: /in/g,
        to: '\\in'
      }, // in -> \in
      {
        from: /notin/g,
        to: '\\notin'
      }, // notin -> \notin
      {
        from: /cup/g,
        to: '\\cup'
      }, // cup -> \cup
      {
        from: /cap/g,
        to: '\\cap'
      }, // cap -> \cap
      {
        from: /union/g,
        to: '\\cup'
      }, // union -> \cup
      {
        from: /intersection/g,
        to: '\\cap'
      }, // intersection -> \cap
      {
        from: /rightarrow/g,
        to: '\\rightarrow'
      }, // rightarrow -> \rightarrow
      {
        from: /leftarrow/g,
        to: '\\leftarrow'
      }, // leftarrow -> \leftarrow
      {
        from: /Rightarrow/g,
        to: '\\Rightarrow'
      }, // Rightarrow -> \Rightarrow
      {
        from: /Leftarrow/g,
        to: '\\Leftarrow'
      }, // Leftarrow -> \Leftarrow
      {
        from: /forall/g,
        to: '\\forall'
      }, // forall -> \forall
      {
        from: /exists/g,
        to: '\\exists'
      }, // exists -> \exists
      {
        from: /pm/g,
        to: '\\pm'
      }, // pm -> \pm
      {
        from: /mp/g,
        to: '\\mp'
      }, // mp -> \mp
      {
        from: /times/g,
        to: '\\times'
      }, // times -> \times
      {
        from: /div/g,
        to: '\\div'
      }, // div -> \div
      {
        from: /cdot/g,
        to: '\\cdot'
      }, // cdot -> \cdot
      {
        from: /ast/g,
        to: '\\ast'
      }, // ast -> \ast
      {
        from: /star/g,
        to: '\\star'
      }, // star -> \star
      {
        from: /circ/g,
        to: '\\circ'
      }, // circ -> \circ
      {
        from: /bullet/g,
        to: '\\bullet'
      }, // bullet -> \bullet
      {
        from: /oplus/g,
        to: '\\oplus'
      }, // oplus -> \oplus
      {
        from: /ominus/g,
        to: '\\ominus'
      }, // ominus -> \ominus
      {
        from: /otimes/g,
        to: '\\otimes'
      }, // otimes -> \otimes
      {
        from: /odot/g,
        to: '\\odot'
      } // odot -> \odot
    ];

    let result = text;
    conversions.forEach(conversion => {
      result = result.replace(conversion.from, conversion.to);
    });

    return result;
  }

  // Convert LaTeX to readable text
  function convertLatexToText(text) {
    // Common LaTeX to text conversions
    const conversions = [{
        from: /\\sqrt\{([^}]+)\}/g,
        to: 'sqrt($1)'
      }, // \sqrt{x} -> sqrt(x)
      {
        from: /\\frac\{([^}]+)\}\{([^}]+)\}/g,
        to: 'frac($1, $2)'
      }, // \frac{a}{b} -> frac(a, b)
      {
        from: /\\pi/g,
        to: 'pi'
      }, // \pi -> pi
      {
        from: /\\alpha/g,
        to: 'alpha'
      }, // \alpha -> alpha
      {
        from: /\\beta/g,
        to: 'beta'
      }, // \beta -> beta
      {
        from: /\\gamma/g,
        to: 'gamma'
      }, // \gamma -> gamma
      {
        from: /\\delta/g,
        to: 'delta'
      }, // \delta -> delta
      {
        from: /\\theta/g,
        to: 'theta'
      }, // \theta -> theta
      {
        from: /\\lambda/g,
        to: 'lambda'
      }, // \lambda -> lambda
      {
        from: /\\mu/g,
        to: 'mu'
      }, // \mu -> mu
      {
        from: /\\sigma/g,
        to: 'sigma'
      }, // \sigma -> sigma
      {
        from: /\\tau/g,
        to: 'tau'
      }, // \tau -> tau
      {
        from: /\\phi/g,
        to: 'phi'
      }, // \phi -> phi
      {
        from: /\\omega/g,
        to: 'omega'
      }, // \omega -> omega
      {
        from: /\\infty/g,
        to: 'infinity'
      }, // \infty -> infinity
      {
        from: /\\int/g,
        to: 'integral'
      }, // \int -> integral
      {
        from: /\\sum/g,
        to: 'sum'
      }, // \sum -> sum
      {
        from: /\\prod/g,
        to: 'product'
      }, // \prod -> product
      {
        from: /\\lim/g,
        to: 'limit'
      }, // \lim -> limit
      {
        from: /\\sin\(/g,
        to: 'sin('
      }, // \sin( -> sin(
      {
        from: /\\cos\(/g,
        to: 'cos('
      }, // \cos( -> cos(
      {
        from: /\\tan\(/g,
        to: 'tan('
      }, // \tan( -> tan(
      {
        from: /\\log\(/g,
        to: 'log('
      }, // \log( -> log(
      {
        from: /\\ln\(/g,
        to: 'ln('
      }, // \ln( -> ln(
      {
        from: /\\exp\(/g,
        to: 'exp('
      }, // \exp( -> exp(
      {
        from: /\\leq/g,
        to: 'leq'
      }, // \leq -> leq
      {
        from: /\\geq/g,
        to: 'geq'
      }, // \geq -> geq
      {
        from: /\\neq/g,
        to: 'neq'
      }, // \neq -> neq
      {
        from: /\\approx/g,
        to: 'approx'
      }, // \approx -> approx
      {
        from: /\\equiv/g,
        to: 'equiv'
      }, // \equiv -> equiv
      {
        from: /\\subset/g,
        to: 'subset'
      }, // \subset -> subset
      {
        from: /\\supset/g,
        to: 'supset'
      }, // \supset -> supset
      {
        from: /\\in/g,
        to: 'in'
      }, // \in -> in
      {
        from: /\\notin/g,
        to: 'notin'
      }, // \notin -> notin
      {
        from: /\\cup/g,
        to: 'union'
      }, // \cup -> union
      {
        from: /\\cap/g,
        to: 'intersection'
      }, // \cap -> intersection
      {
        from: /\\rightarrow/g,
        to: 'rightarrow'
      }, // \rightarrow -> rightarrow
      {
        from: /\\leftarrow/g,
        to: 'leftarrow'
      }, // \leftarrow -> leftarrow
      {
        from: /\\Rightarrow/g,
        to: 'Rightarrow'
      }, // \Rightarrow -> Rightarrow
      {
        from: /\\Leftarrow/g,
        to: 'Leftarrow'
      }, // \Leftarrow -> Leftarrow
      {
        from: /\\forall/g,
        to: 'forall'
      }, // \forall -> forall
      {
        from: /\\exists/g,
        to: 'exists'
      }, // \exists -> exists
      {
        from: /\\pm/g,
        to: 'pm'
      }, // \pm -> pm
      {
        from: /\\mp/g,
        to: 'mp'
      }, // \mp -> mp
      {
        from: /\\times/g,
        to: 'times'
      }, // \times -> times
      {
        from: /\\div/g,
        to: 'div'
      }, // \div -> div
      {
        from: /\\cdot/g,
        to: 'cdot'
      }, // \cdot -> cdot
      {
        from: /\\ast/g,
        to: 'ast'
      }, // \ast -> ast
      {
        from: /\\star/g,
        to: 'star'
      }, // \star -> star
      {
        from: /\\circ/g,
        to: 'circ'
      }, // \circ -> circ
      {
        from: /\\bullet/g,
        to: 'bullet'
      }, // \bullet -> bullet
      {
        from: /\\oplus/g,
        to: 'oplus'
      }, // \oplus -> oplus
      {
        from: /\\ominus/g,
        to: 'ominus'
      }, // \ominus -> ominus
      {
        from: /\\otimes/g,
        to: 'otimes'
      }, // \otimes -> otimes
      {
        from: /\\odot/g,
        to: 'odot'
      }, // \odot -> odot
      {
        from: /\^(\{([^}]+)\})/g,
        to: '^$2'
      }, // ^{x} -> ^x
      {
        from: /\^(\w)/g,
        to: '^$1'
      }, // ^x -> ^x
      {
        from: /_(\{([^}]+)\})/g,
        to: '_$2'
      }, // _{x} -> _x
      {
        from: /_(\w)/g,
        to: '_$1'
      } // _x -> _x
    ];

    let result = text;
    conversions.forEach(conversion => {
      result = result.replace(conversion.from, conversion.to);
    });

    return result;
  }
</script>

<style>
  /* ==================== BULK ACTIONS STYLES ==================== */
  
  .bulk-actions-toolbar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 15px;
    padding: 15px 20px;
    background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
    border: 1px solid #e2e8f0;
    border-radius: 12px;
    margin-bottom: 20px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
  }
  
  .bulk-actions-left {
    display: flex;
    align-items: center;
    flex-wrap: wrap;
    gap: 10px;
  }
  
  .bulk-actions-right {
    display: flex;
    align-items: center;
    gap: 15px;
  }
  
  .btn-bulk-toggle {
    background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%);
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 8px;
    font-weight: 600;
    font-size: 14px;
    transition: all 0.3s ease;
    box-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);
  }
  
  .btn-bulk-toggle:hover {
    background: linear-gradient(135deg, #4f46e5 0%, #4338ca 100%);
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
  }
  
  .btn-bulk-toggle.active {
    background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
    box-shadow: 0 2px 8px rgba(239, 68, 68, 0.3);
  }
  
  .btn-bulk-toggle.active:hover {
    background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
  }
  
  .bulk-selection-controls {
    display: flex;
    align-items: center;
    flex-wrap: wrap;
    gap: 10px;
  }
  
  .bulk-divider {
    width: 1px;
    height: 30px;
    background: #cbd5e1;
    margin: 0 5px;
  }
  
  .btn-bulk-action {
    background: white;
    color: #475569;
    border: 1px solid #cbd5e1;
    padding: 8px 14px;
    border-radius: 6px;
    font-weight: 500;
    font-size: 13px;
    transition: all 0.2s ease;
  }
  
  .btn-bulk-action:hover {
    background: #f1f5f9;
    color: #1e293b;
    border-color: #94a3b8;
  }
  
  .bulk-select-dropdown {
    padding: 8px 12px;
    border: 1px solid #cbd5e1;
    border-radius: 6px;
    font-size: 13px;
    min-width: 160px;
    background: white;
    cursor: pointer;
  }
  
  .bulk-select-dropdown:focus {
    outline: none;
    border-color: #6366f1;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
  }
  
  .bulk-select-by-numbers {
    display: flex;
    gap: 8px;
  }
  
  .bulk-input {
    padding: 8px 12px;
    border: 1px solid #cbd5e1;
    border-radius: 6px;
    font-size: 13px;
    width: 140px;
  }
  
  .bulk-input:focus {
    outline: none;
    border-color: #6366f1;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
  }
  
  .bulk-selected-count {
    display: flex;
    align-items: center;
    padding: 8px 16px;
    background: #dbeafe;
    color: #1e40af;
    border-radius: 20px;
    font-weight: 600;
    font-size: 14px;
  }
  
  .btn-bulk-delete {
    background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 8px;
    font-weight: 600;
    font-size: 14px;
    transition: all 0.3s ease;
    box-shadow: 0 2px 8px rgba(239, 68, 68, 0.3);
  }
  
  .btn-bulk-delete:hover {
    background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);
  }
  
  /* Bulk Checkbox Styles */
  .bulk-checkbox-wrapper {
    display: none;
    align-items: center;
    justify-content: center;
    margin-right: 10px;
  }
  
  .bulk-checkbox-label {
    position: relative;
    cursor: pointer;
    margin: 0;
  }
  
  .bulk-question-checkbox {
    position: absolute;
    opacity: 0;
    cursor: pointer;
    height: 0;
    width: 0;
  }
  
  .bulk-checkbox-custom {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 24px;
    height: 24px;
    background: white;
    border: 2px solid #cbd5e1;
    border-radius: 6px;
    transition: all 0.2s ease;
  }
  
  .bulk-checkbox-custom::after {
    content: '✓';
    display: none;
    color: white;
    font-size: 14px;
    font-weight: bold;
  }
  
  .bulk-question-checkbox:checked + .bulk-checkbox-custom {
    background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%);
    border-color: #4f46e5;
  }
  
  .bulk-question-checkbox:checked + .bulk-checkbox-custom::after {
    display: block;
  }
  
  .bulk-checkbox-label:hover .bulk-checkbox-custom {
    border-color: #6366f1;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
  }
  
  /* Question Card in Bulk Mode */
  .question-card-modern.bulk-mode {
    transition: all 0.2s ease;
  }
  
  .question-card-modern.bulk-mode:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
  }
  
  .question-card-modern.selected {
    border: 2px solid #6366f1;
    background: linear-gradient(135deg, rgba(99, 102, 241, 0.05) 0%, rgba(99, 102, 241, 0.1) 100%);
    box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.15);
  }
  
  .question-card-modern.bulk-mode .question-card-header {
    display: flex;
    align-items: center;
  }
  
  /* Bulk Delete Modal Styles */
  .bulk-delete-warning {
    text-align: center;
    padding: 20px;
    background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%);
    border-radius: 12px;
    margin-bottom: 20px;
  }
  
  .bulk-delete-warning .warning-icon {
    width: 60px;
    height: 60px;
    background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 0 auto 15px;
  }
  
  .bulk-delete-warning .warning-icon i {
    color: white;
    font-size: 24px;
  }
  
  .questions-to-delete {
    max-height: 350px;
    overflow-y: auto;
    border: 1px solid #e5e7eb;
    border-radius: 8px;
    padding: 10px;
    background: #f9fafb;
  }
  
  .delete-question-item {
    background: white;
    border: 1px solid #e5e7eb;
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 8px;
    transition: all 0.2s ease;
  }
  
  .delete-question-item:last-child {
    margin-bottom: 0;
  }
  
  .delete-question-item:hover {
    border-color: #dc2626;
    background: #fef2f2;
  }
  
  .delete-question-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 8px;
  }
  
  .delete-question-num {
    font-weight: 700;
    color: #1e293b;
    font-size: 14px;
  }
  
  .delete-question-difficulty {
    padding: 2px 8px;
    border-radius: 4px;
    font-size: 11px;
    font-weight: 600;
  }
  
  .delete-question-difficulty.difficulty-easy {
    background: #dcfce7;
    color: #166534;
  }
  
  .delete-question-difficulty.difficulty-medium {
    background: #fef3c7;
    color: #92400e;
  }
  
  .delete-question-difficulty.difficulty-hard {
    background: #fee2e2;
    color: #991b1b;
  }
  
  .delete-question-text {
    font-size: 13px;
    color: #475569;
    margin-bottom: 6px;
    line-height: 1.4;
  }
  
  .delete-question-tags {
    font-size: 11px;
    color: #94a3b8;
  }
  
  /* Animation for deleted items */
  @keyframes fadeOutUp {
    from {
      opacity: 1;
      transform: translateY(0);
    }
    to {
      opacity: 0;
      transform: translateY(-20px);
    }
  }
  
  /* Responsive adjustments */
  @media (max-width: 768px) {
    .bulk-actions-toolbar {
      flex-direction: column;
      align-items: flex-start;
    }
    
    .bulk-selection-controls {
      flex-wrap: wrap;
    }
    
    .bulk-divider {
      display: none;
    }
    
    .bulk-select-by-numbers {
      width: 100%;
    }
    
    .bulk-input {
      flex: 1;
    }
  }
  
  /* Image action buttons styling */
  .image-actions {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
    justify-content: center;
    padding: 8px;
    background: rgba(0, 0, 0, 0.02);
    border-radius: 8px;
    border: 1px dashed rgba(0, 0, 0, 0.1);
  }
  
  .image-actions .btn {
    font-size: 0.85rem;
    padding: 0.4rem 0.8rem;
    border-radius: 6px;
    transition: all 0.2s ease;
  }
  
  .image-actions .btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
  }
  
  .image-actions .btn-outline-danger:hover {
    background-color: #dc3545;
    color: white;
  }
  
  .image-actions .btn-outline-primary:hover {
    background-color: #007bff;
    color: white;
  }
  
  /* Math field styles for preview */
  .preview-math-field {
    background: #f8f9fa !important;
    border: 1px solid #e9ecef !important;
    border-radius: 6px !important;
    font-family: 'KaTeX_Math', 'Times New Roman', serif !important;
  }

  .preview-math-field:focus {
    border-color: #007bff !important;
    box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25) !important;
  }

  /* Question preview option styles */
  .question-preview-option.correct {
    background-color: #d4edda;
    border-left: 4px solid #28a745;
  }

  .question-preview-option.correct .option-label {
    background-color: #28a745;
    color: white;
  }

  .question-preview-answer {
    display: flex;
    align-items: center;
    padding: 8px 12px;
    margin: 4px 0;
    background-color: #e7f3ff;
    border-left: 4px solid #007bff;
    border-radius: 4px;
    position: relative;
  }

  .question-preview-answer.mandatory {
    background-color: #d4edda;
    border-left-color: #28a745;
  }

  .question-preview-answer.optional {
    background-color: #fff3cd;
    border-left-color: #ffc107;
  }

  .answer-label {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 24px;
    height: 24px;
    background-color: #007bff;
    color: white;
    border-radius: 50%;
    font-size: 12px;
    font-weight: bold;
    margin-right: 12px;
    flex-shrink: 0;
  }

  .answer-text {
    flex: 1;
    font-size: 14px;
  }

  .answer-status {
    display: flex;
    align-items: center;
    margin-left: 12px;
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .answer-status i {
    margin-right: 4px;
    font-size: 10px;
  }

  .question-preview-answer.mandatory .answer-status {
    color: #155724;
  }

  .question-preview-answer.optional .answer-status {
    color: #856404;
  }

  /* Option math field styles */
  .option-math-field {
    background: #f8f9fa !important;
    border: 1px solid #e9ecef !important;
    border-radius: 4px !important;
    font-size: 14px !important;
    min-height: 30px !important;
  }

  .answer-math-field {
    background: #e7f3ff !important;
    border: 1px solid #b3d9ff !important;
    border-radius: 4px !important;
    font-size: 14px !important;
    min-height: 30px !important;
  }

  /* Correct answer indicator */
  .correct-indicator {
    color: #28a745;
    font-weight: bold;
    font-size: 12px;
    margin-left: 8px;
  }

  /* Option text container */
  .option-text {
    display: flex;
    align-items: center;
    flex: 1;
  }

  /* Checkbox styles for written answers */
  .option-checkbox {
    display: flex;
    align-items: center;
    margin-right: 12px;
  }

  .option-checkbox-input {
    display: none;
  }

  .option-checkbox-label {
    display: flex;
    align-items: center;
    cursor: pointer;
    padding: 6px 12px;
    border-radius: 6px;
    background: #f8f9fa;
    border: 2px solid #e9ecef;
    transition: all 0.2s ease;
    font-size: 12px;
    font-weight: 500;
    color: #6c757d;
  }

  .option-checkbox-label:hover {
    background: #e9ecef;
    border-color: #dee2e6;
  }

  .option-checkbox-input:checked+.option-checkbox-label {
    background: #d4edda;
    border-color: #28a745;
    color: #155724;
  }

  .option-checkbox-label i {
    margin-right: 6px;
    font-size: 10px;
  }

  .mandatory-text {
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  /* Optional answer styling */
  .option-checkbox-input:not(:checked)+.option-checkbox-label {
    background: #fff3cd;
    border-color: #ffc107;
    color: #856404;
  }

  /* Enhanced Answer Type Selector Styles */
  .answer-type-selector {
    display: flex;
    gap: 1rem;
    margin-bottom: 1.5rem;
  }

  .answer-type-option {
    flex: 1;
    position: relative;
  }

  .answer-type-radio {
    position: absolute;
    opacity: 0;
    pointer-events: none;
  }

  .answer-type-label {
    display: flex;
    align-items: flex-start;
    padding: 1.5rem;
    border: 2px solid #e5e7eb;
    border-radius: 12px;
    background: #ffffff;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
  }

  .answer-type-label::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    opacity: 0;
    transition: opacity 0.3s ease;
    z-index: 0;
  }

  .answer-type-label:hover {
    border-color: #3b82f6;
    box-shadow: 0 4px 12px rgba(59, 130, 246, 0.15);
    transform: translateY(-2px);
  }

  .answer-type-radio:checked+.answer-type-label {
    border-color: #3b82f6;
    background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
    color: white;
    box-shadow: 0 8px 25px rgba(59, 130, 246, 0.3);
    transform: translateY(-2px);
  }

  .answer-type-radio:checked+.answer-type-label::before {
    opacity: 0.1;
  }

  .answer-type-icon {
    margin-right: 1rem;
    font-size: 1.5rem;
    color: #6b7280;
    transition: all 0.3s ease;
    z-index: 1;
    position: relative;
  }

  .answer-type-radio:checked+.answer-type-label .answer-type-icon {
    color: white;
    transform: scale(1.1);
  }

  .answer-type-content {
    flex: 1;
    z-index: 1;
    position: relative;
  }

  .answer-type-title {
    font-size: 1.1rem;
    font-weight: 600;
    margin: 0 0 0.5rem 0;
    color: #1f2937;
    transition: color 0.3s ease;
  }

  .answer-type-radio:checked+.answer-type-label .answer-type-title {
    color: white;
  }

  .answer-type-description {
    font-size: 0.9rem;
    color: #6b7280;
    margin: 0 0 0.75rem 0;
    line-height: 1.4;
    transition: color 0.3s ease;
  }

  .answer-type-radio:checked+.answer-type-label .answer-type-description {
    color: rgba(255, 255, 255, 0.9);
  }

  .answer-type-badge {
    margin-top: 0.5rem;
  }

  .answer-type-badge .badge {
    font-size: 0.75rem;
    padding: 0.25rem 0.5rem;
    border-radius: 6px;
    font-weight: 500;
  }

  .answer-type-radio:checked+.answer-type-label .answer-type-badge .badge {
    background: rgba(255, 255, 255, 0.2) !important;
    color: white !important;
    border: 1px solid rgba(255, 255, 255, 0.3);
  }

  /* Responsive design */
  @media (max-width: 768px) {
    .answer-type-selector {
      flex-direction: column;
      gap: 0.75rem;
    }

    .answer-type-label {
      padding: 1rem;
    }

    .answer-type-icon {
      font-size: 1.25rem;
      margin-right: 0.75rem;
    }

    .answer-type-title {
      font-size: 1rem;
    }

    .answer-type-description {
      font-size: 0.85rem;
    }
  }

  /* Animation for selection */
  @keyframes answerTypeSelect {
    0% {
      transform: scale(1);
    }

    50% {
      transform: scale(1.02);
    }

    100% {
      transform: scale(1);
    }
  }

  .answer-type-radio:checked+.answer-type-label {
    animation: answerTypeSelect 0.3s ease;
  }

  .option-checkbox-input:not(:checked)+.option-checkbox-label .mandatory-text::after {
    content: " (Optional)";
    font-weight: 400;
    text-transform: none;
    letter-spacing: normal;
  }

  /* Always mandatory styling (first answer) */
  .mandatory-always {
    background: #d1ecf1 !important;
    border-color: #17a2b8 !important;
    color: #0c5460 !important;
    cursor: not-allowed !important;
  }

  .mandatory-always:hover {
    background: #d1ecf1 !important;
    border-color: #17a2b8 !important;
  }

  .mandatory-always i {
    color: #17a2b8 !important;
  }

  /* Fix for button clicking issues */
  .admin-header-actions {
    position: relative;
    z-index: 10;
  }

  .admin-header-actions .btn {
    position: relative;
    z-index: 11;
    pointer-events: auto;
    cursor: pointer;
  }

  /* Ensure modal backdrop doesn't interfere */
  .modal-backdrop {
    z-index: 1040;
  }

  .modal {
    z-index: 1050;
  }

  /* Bootstrap modal fix */
  .modal-open .modal {
    overflow-x: hidden;
    overflow-y: auto;
  }

  /* Math Symbol Keyboard Styles */
  .math-keyboard-container {
    background: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 10px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  }

  .math-keyboard-tabs {
    display: flex;
    gap: 4px;
    margin-bottom: 12px;
    flex-wrap: wrap;
    border-bottom: 2px solid #dee2e6;
    padding-bottom: 8px;
  }

  .math-keyboard-tab {
    padding: 6px 12px;
    background: #fff;
    border: 1px solid #dee2e6;
    border-radius: 4px;
    cursor: pointer;
    font-size: 12px;
    font-weight: 500;
    color: #6c757d;
    transition: all 0.2s ease;
  }

  .math-keyboard-tab:hover {
    background: #e9ecef;
    border-color: #adb5bd;
  }

  .math-keyboard-tab.active {
    background: #007bff;
    color: #fff;
    border-color: #007bff;
  }

  .math-keyboard-content {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
  }

  .math-symbol-btn {
    padding: 8px 12px;
    background: #fff;
    border: 1px solid #dee2e6;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 500;
    color: #495057;
    transition: all 0.2s ease;
    min-width: 50px;
    text-align: center;
  }

  .math-symbol-btn:hover {
    background: #007bff;
    color: #fff;
    border-color: #007bff;
    transform: translateY(-1px);
    box-shadow: 0 2px 4px rgba(0,123,255,0.3);
  }

  .math-symbol-btn:active {
    transform: translateY(0);
  }

  /* Previous Tags Styles */
  .previous-tags-container {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 10px;
    padding: 12px;
    background: #f8f9fa;
    border: 1px solid #e9ecef;
    border-radius: 8px;
  }

  .previous-tag {
    display: inline-block;
    padding: 6px 12px;
    background: #ffffff;
    border: 1px solid #dee2e6;
    border-radius: 20px;
    font-size: 13px;
    font-weight: 500;
    color: #495057;
    cursor: pointer;
    transition: all 0.2s ease;
    user-select: none;
  }

  .previous-tag:hover {
    background: #007bff;
    border-color: #007bff;
    color: #ffffff;
    transform: translateY(-2px);
    box-shadow: 0 2px 8px rgba(0, 123, 255, 0.3);
  }

  .previous-tag.tag-selected {
    background: #28a745;
    border-color: #28a745;
    color: #ffffff;
    transform: scale(1.1);
    box-shadow: 0 4px 12px rgba(40, 167, 69, 0.4);
  }
</style>

<script>
  // MathLive Editor Functions for Collapsible Sections
  const mathEditorFields = {};

  function initMathEditor(fieldId) {
    // Wait a bit for the collapse animation to start
    setTimeout(() => {
      const mathFieldId = `mathEditorField-${fieldId}`;
      const mathField = document.getElementById(mathFieldId);
      
      if (mathField && typeof MathLive !== 'undefined' && !mathEditorFields[fieldId]) {
        // Store reference
        mathEditorFields[fieldId] = mathField;
        
        // Update preview when math changes
        mathField.addEventListener('input', function() {
          updateMathPreview(fieldId);
        });
        
        // Set initial value if there's selected text in the textarea
        const textarea = document.getElementById(fieldId);
        if (textarea) {
          const start = textarea.selectionStart;
          const end = textarea.selectionEnd;
          const selectedText = textarea.value.substring(start, end);
          
          // If there's selected text and it looks like math, extract it
          if (selectedText && selectedText.includes('$')) {
            const mathMatch = selectedText.match(/\$([^$]+)\$/);
            if (mathMatch) {
              mathField.value = mathMatch[1];
            }
          }
        }
        
        updateMathPreview(fieldId);
      }
    }, 100);
  }

  function updateMathPreview(fieldId) {
    const previewId = `mathEditorPreview-${fieldId}`;
    const preview = document.getElementById(previewId);
    const mathField = mathEditorFields[fieldId];
    
    if (mathField && preview) {
      try {
        const latex = mathField.value;
        if (latex) {
          preview.innerHTML = `<math-field readonly style="display: inline-block; font-size: 16px; border: none; background: transparent; padding: 4px;">${latex}</math-field>`;
        } else {
          preview.innerHTML = '<span style="color: #6c757d;">Preview will appear here...</span>';
        }
      } catch (e) {
        preview.innerHTML = '<span style="color: #dc3545;">Error rendering preview</span>';
      }
    }
  }

  function insertMathExpression(fieldId) {
    const mathField = mathEditorFields[fieldId];
    const textarea = document.getElementById(fieldId);
    
    if (mathField && textarea) {
      const latex = mathField.value;
      if (latex) {
        // Get cursor position
        const start = textarea.selectionStart;
        const end = textarea.selectionEnd;
        const text = textarea.value;

        // Wrap in $$ and insert
        const mathExpression = `$${latex}$`;
        const newText = text.substring(0, start) + mathExpression + text.substring(end);
        textarea.value = newText;

        // Set cursor position after inserted expression
        const newCursorPos = start + mathExpression.length;
        textarea.setSelectionRange(newCursorPos, newCursorPos);
        textarea.focus();

        // Trigger input event
        textarea.dispatchEvent(new Event('input', { bubbles: true }));

        // Clear math editor (but keep it open)
        mathField.value = '';
        updateMathPreview(fieldId);
      }
    }
  }

  // Clean up when collapsible is hidden
  document.addEventListener('DOMContentLoaded', function() {
    // For create question modal
    const createCollapse = document.getElementById('mathEditorCollapse-questionText');
    if (createCollapse) {
      createCollapse.addEventListener('hidden.bs.collapse', function() {
        const mathField = mathEditorFields['questionText'];
        if (mathField) {
          mathField.value = '';
        }
        const preview = document.getElementById('mathEditorPreview-questionText');
        if (preview) {
          preview.innerHTML = 'Preview will appear here...';
        }
      });
    }

    // For edit question modal
    const editCollapse = document.getElementById('mathEditorCollapse-editQuestionText');
    if (editCollapse) {
      editCollapse.addEventListener('hidden.bs.collapse', function() {
        const mathField = mathEditorFields['editQuestionText'];
        if (mathField) {
          mathField.value = '';
        }
        const preview = document.getElementById('mathEditorPreview-editQuestionText');
        if (preview) {
          preview.innerHTML = 'Preview will appear here...';
        }
      });
    }
  });
</script>