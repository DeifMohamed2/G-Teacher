const mongoose = require('mongoose');

const QuestionSchema = new mongoose.Schema(
  {
    questionText: {
      type: String,
      required: true,
      trim: true,
      minlength: 10,
      maxlength: 1000,
    },
    questionImage: {
      type: String, // URL to question image
      default: '',
    },
    questionType: {
      type: String,
      enum: ['MCQ', 'True/False', 'Written'],
      default: 'MCQ',
    },
    options: [
      {
        text: {
          type: String,
          required: true,
          trim: true,
          maxlength: 500,
        },
        image: {
          type: String, // URL to option image
          default: '',
        },
        isCorrect: {
          type: Boolean,
          default: false,
        },
      },
    ],
    correctAnswer: {
      type: String, // Single correct answer (index as string) for MCQ/True-False
      required: false, // Auto-generated by pre-save middleware
    },
    correctAnswers: [
      {
        text: {
          type: String,
          trim: true,
          required: true,
        },
        isMandatory: {
          type: Boolean,
          default: true, // By default, all answers are mandatory
        },
      },
    ],
    answerMultiplicity: {
      type: String,
      enum: ['single', 'multiple'],
      default: 'single',
    },

    explanation: {
      type: String,
      trim: true,
      maxlength: 1000,
      default: '',
    },
    explanationImage: {
      type: String, // URL to explanation image
      default: '',
    },
    difficulty: {
      type: String,
      enum: ['Easy', 'Medium', 'Hard'],
      required: true,
    },
    tags: [
      {
        type: String,
        trim: true,
      },
    ],
    points: {
      type: Number,
      default: 1,
      min: 1,
      max: 10,
    },
    bank: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'QuestionBank',
      required: true,
    },
    createdBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Admin',
      default: null,
    },
    status: {
      type: String,
      enum: ['draft', 'active', 'archived'],
      default: 'draft',
    },
    isActive: {
      type: Boolean,
      default: true,
    },
    usageCount: {
      type: Number,
      default: 0,
    },
    averageScore: {
      type: Number,
      default: 0,
      min: 0,
      max: 100,
    },
  },
  {
    timestamps: true,
    toJSON: { virtuals: true },
    toObject: { virtuals: true },
  }
);

// Virtual for option count
QuestionSchema.virtual('optionCount').get(function () {
  return this.options ? this.options.length : 0;
});

// Virtual for correct option count
QuestionSchema.virtual('correctOptionCount').get(function () {
  return this.options
    ? this.options.filter((option) => option.isCorrect).length
    : 0;
});

// Helper method to check if a written answer is correct
QuestionSchema.methods.isCorrectWrittenAnswer = function (userAnswer) {
  if (
    this.questionType !== 'Written' ||
    !this.correctAnswers ||
    this.correctAnswers.length === 0
  ) {
    return false;
  }

  const normalizedUserAnswer = userAnswer
    ? userAnswer.trim().toLowerCase()
    : '';
  if (!normalizedUserAnswer) return false;

  // Check against all correct answers
  for (const correctAnswerObj of this.correctAnswers) {
    const correctAnswer = correctAnswerObj.text
      ? correctAnswerObj.text.trim().toLowerCase()
      : '';

    if (correctAnswer.includes(',')) {
      // Handle multiple answers separated by commas (e.g., "x+2,x+1" or "10,-10")
      const correctAnswers = correctAnswer
        .split(',')
        .map((a) => a.trim().toLowerCase());

      // Check if user provided multiple answers separated by comma
      if (normalizedUserAnswer.includes(',')) {
        const userAnswers = normalizedUserAnswer
          .split(',')
          .map((a) => a.trim().toLowerCase());

        // Check if any user answer matches any correct answer
        const hasMatch = userAnswers.some((userAns) =>
          correctAnswers.some(
            (correctAns) =>
              userAns === correctAns ||
              userAns.includes(correctAns) ||
              correctAns.includes(userAns)
          )
        );

        if (hasMatch) return true;
      } else {
        // Single answer from user, check against all correct answers
        if (
          correctAnswers.some(
            (answer) =>
              answer === normalizedUserAnswer ||
              normalizedUserAnswer.includes(answer) ||
              answer.includes(normalizedUserAnswer)
          )
        ) {
          return true;
        }
      }
    } else {
      // Single correct answer
      if (
        normalizedUserAnswer === correctAnswer ||
        normalizedUserAnswer.includes(correctAnswer) ||
        correctAnswer.includes(normalizedUserAnswer)
      ) {
        return true;
      }
    }
  }

  return false;
};

// Helper method to check if an MCQ/True-False answer is correct
QuestionSchema.methods.isCorrectMCQAnswer = function (userAnswer) {
  if (this.questionType === 'Written') {
    return this.isCorrectWrittenAnswer(userAnswer);
  }

  // Validate that the answer is within valid range
  if (!this.options || this.options.length === 0) {
    return false;
  }

  // Handle True/False questions with text-based answers
  if (this.questionType === 'True/False') {
    const userText = userAnswer.toString().toLowerCase().trim();

    // Find the correct option
    const correctOption = this.options.find((opt) => opt.isCorrect);
    if (correctOption) {
      const correctText = correctOption.text.toLowerCase().trim();
      // Check both text and index matching
      const correctIndex = this.options.indexOf(correctOption);
      return userText === correctText || userText === correctIndex.toString();
    }
    return false;
  }

  // For MCQ questions, handle both text-based and index-based answers
  // Text-based answers are shuffle-safe, index-based are for backward compatibility
  
  // First, try to match by option text (shuffle-safe approach)
  const userText = userAnswer.toString().trim();
  const textMatchIndex = this.options.findIndex(
    (opt) => opt.text && opt.text.trim() === userText
  );
  
  if (textMatchIndex !== -1) {
    // Found a text match - check if this option is correct
    return this.options[textMatchIndex].isCorrect === true;
  }
  
  // If no text match, try index-based matching (backward compatibility)
  let answerIndex;
  if (typeof userAnswer === 'string' && !isNaN(userAnswer)) {
    answerIndex = parseInt(userAnswer);
  } else if (typeof userAnswer === 'number') {
    answerIndex = userAnswer;
  } else {
    // Not a valid index and no text match found
    return false;
  }

  // Check if the answer index is valid
  if (answerIndex < 0 || answerIndex >= this.options.length) {
    return false;
  }

  // Check if the selected option is correct
  return this.options[answerIndex].isCorrect === true;
};

// Helper method to get detailed answer feedback
QuestionSchema.methods.getAnswerFeedback = function (
  userAnswer,
  showCorrectAnswer = false
) {
  const isCorrect =
    this.questionType === 'Written'
      ? this.isCorrectWrittenAnswer(userAnswer)
      : this.isCorrectMCQAnswer(userAnswer);

  let feedback = {
    isCorrect,
    message: isCorrect ? 'Correct!' : 'Incorrect.',
    explanation: this.explanation || '',
  };

  if (showCorrectAnswer && !isCorrect) {
    if (this.questionType === 'Written') {
      feedback.correctAnswer = this.getAllCorrectAnswers();
    } else {
      const correctOption = this.options.find((opt) => opt.isCorrect);
      if (correctOption) {
        feedback.correctAnswer = correctOption.text;
        feedback.correctIndex = this.options.indexOf(correctOption);
      }
    }
  }

  return feedback;
};

// Helper method to get all correct answers as a string
QuestionSchema.methods.getAllCorrectAnswers = function () {
  if (this.questionType !== 'Written' || !this.correctAnswers) {
    return '';
  }

  return this.correctAnswers.map((a) => a.text).join(', ');
};

// Validate question based on type
QuestionSchema.pre('save', function (next) {
  if (this.questionType === 'Written') {
    // For written questions, validate correctAnswers array
    if (!this.correctAnswers || this.correctAnswers.length === 0) {
      return next(
        new Error('Written questions must have at least one correct answer')
      );
    }

    // Remove empty answers and validate structure
    this.correctAnswers = this.correctAnswers.filter((answer) => {
      if (typeof answer === 'string') {
        // Handle legacy string format - convert to object
        return answer && answer.trim().length > 0;
      } else if (typeof answer === 'object' && answer.text) {
        // Handle new object format
        return answer.text && answer.text.trim().length > 0;
      }
      return false;
    });

    // Convert legacy string format to object format
    this.correctAnswers = this.correctAnswers.map((answer) => {
      if (typeof answer === 'string') {
        return {
          text: answer.trim(),
          isMandatory: true,
        };
      }
      return answer;
    });

    if (this.correctAnswers.length === 0) {
      return next(
        new Error(
          'Written questions must have at least one non-empty correct answer'
        )
      );
    }

    // Enforce multiplicity rules
    if (
      this.answerMultiplicity === 'single' &&
      this.correctAnswers.length !== 1
    ) {
      return next(
        new Error(
          'Written questions with single answer must have exactly one correct answer'
        )
      );
    }

    // Ensure at least one mandatory answer exists
    const hasMandatoryAnswer = this.correctAnswers.some(
      (answer) => answer.isMandatory === true
    );
    if (!hasMandatoryAnswer) {
      return next(
        new Error('Written questions must have at least one mandatory answer')
      );
    }
  } else {
    // For MCQ and True/False questions, validate options
    if (this.options && this.options.length > 0) {
      const hasCorrectOption = this.options.some((option) => option.isCorrect);
      if (!hasCorrectOption) {
        return next(new Error('At least one option must be marked as correct'));
      }

      // For True/False questions, ensure only 2 options exist
      if (this.questionType === 'True/False' && this.options.length !== 2) {
        return next(
          new Error('True/False questions must have exactly 2 options')
        );
      }

      // For True/False questions, ensure options are "True" and "False"
      if (this.questionType === 'True/False') {
        const optionTexts = this.options.map((option) =>
          option.text.toLowerCase().trim()
        );
        if (!optionTexts.includes('true') || !optionTexts.includes('false')) {
          return next(
            new Error(
              'True/False questions must have "True" and "False" as options'
            )
          );
        }
      }
    }
  }
  next();
});

// Validate and set correctAnswer based on correct option (only for MCQ and True/False)
QuestionSchema.pre('save', function (next) {
  if (
    this.questionType !== 'Written' &&
    this.options &&
    this.options.length > 0
  ) {
    const correctOptionIndex = this.options.findIndex(
      (option) => option.isCorrect
    );

    if (correctOptionIndex === -1) {
      return next(new Error('At least one option must be marked as correct'));
    }

    // Set correctAnswer to match the correct option index
    this.correctAnswer = correctOptionIndex.toString();
  } else if (
    this.questionType !== 'Written' &&
    (!this.options || this.options.length === 0)
  ) {
    return next(
      new Error('MCQ and True/False questions must have at least one option')
    );
  }
  next();
});

// Index for better search performance
QuestionSchema.index({ bank: 1, difficulty: 1 });
QuestionSchema.index({ bank: 1, tags: 1 });
QuestionSchema.index({ bank: 1, status: 1 });
QuestionSchema.index({ questionText: 'text', explanation: 'text' });

module.exports = mongoose.model('Question', QuestionSchema);
